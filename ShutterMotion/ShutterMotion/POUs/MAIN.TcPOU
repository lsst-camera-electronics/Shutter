<?xml version="1.0" encoding="utf-8"?>
<TcPlcObject Version="1.1.0.1" ProductVersion="3.1.4022.12">
  <POU Name="MAIN" Id="{f71d400f-d229-45a7-bebf-e505112d31c1}" SpecialFunc="None">
    <Declaration><![CDATA[PROGRAM MAIN
VAR
	//Axis
	stAxis		: ARRAY [GVL.cXP .. GVL.cXM] OF ST_AxisGroup;
	
	//state machine function block
	fbShutterSM	: FB_ShutterSM;
	
	//external input...... need to link
	bAuxElxPermit AT %I*	: BOOL;
	fMotorTemp				: LREAL;

	//other function block
	fbPower		: FB_Power;
	fbProtect	: FB_Protection;
	fbTracking	: FB_Tracking;

	//Timing test vars
	fbInputRtrig		: R_trig;
	fbInputFtrig		: F_trig;
	
	//
	eCommand		: E_Commands;
	
	//communication IN
	inCalibrate, ackCalibrate				: ST_Calibrate;
	inChangeAxisEnable, ackChangeAxisEnable	: ST_ChangeAxisEnable;
	inChangeBrakeState, ackChangeBrakeState	: ST_ChangeBrakeState;
	inClearAllFaults, ackClearAllFaults		: ST_ClearAllFaults;
	inClearAxisFaults, ackClearAxisFaults	: ST_ClearAxisFaults;
	inCloseShutter, ackCloseShutter			: ST_CloseShutter;
	inDisableAllAxes, ackDisableAllAxes		: ST_DisableAllAxes;
	inEnableAllAxes, ackEnableAllAxes		: ST_EnableAllAxes;
	inGoToProd, ackGoToProd					: ST_GoToProd;
	inHomeAxis, ackHomeAxis					: ST_HomeAxis;
	inMoveAxisAbsolute, ackMoveAxisAbsolute	: ST_MoveAxisAbsolute;
	inMoveAxisRelative, ackMoveAxisRelative	: ST_MoveAxisRelative;
	inOpenShutter, ackOpenShutter			: ST_OpenShutter;
	inReset, ackReset						: ST_Reset;
	inTakeExposure, ackTakeExposure			: ST_TakeExposure;
	
	//communication OUT
	fbOutTimer			: TON;
	bVersionSet			: BOOL;
	outCalibDone		: ST_CalibDone;
	outDisable			: ST_Disable;
	outEnable			: ST_Enable;
	outError			: ST_Error;
	outIgnored			: ST_Ignored;
	outMotionDone		: ST_MotionDone;
	outShutterStatus	: ST_ShutterStatus;
	outTimer			: ST_Timer;
	
	//edge detection
	stDisable_ftrig		: F_TRIG;
	stDisable_rtrig		: R_TRIG;
	stError_rtrig		: R_TRIG;
	stExpoTimer_rtrig	: R_TRIG;
	stCalibDone_rtrig	: R_TRIG;
	
	//TestVar
	a,b,c,d,e,f,g, h: INT;
	num : ARRAY [0..14] OF INT;
	i : int;
	fbEL1259Read : FB_EcCoESdoRead;
	testInt : INT;
	tTimeTest : T_DCTIME64;
	
END_VAR
VAR CONSTANT
	//Will change later once motionProfile and version are decided
	nMotionProfile	: DINT := 0;
	nVersion		: DINT := 1;
	tUpdateTimer	: TIME := T#2S;
END_VAR

(*
SN001 scaling factor
motor 1: 0.0498281
motor 2: 0.0498517
*)
(*
SN002 scaling factor
motor 1: 0.0498327596
motor 2: 0.0498327596
*)	
]]></Declaration>
    <Implementation>
      <ST><![CDATA[(*update Axis_Ref status*)
stAxis[GVL.cXP].axisRef.ReadStatus();
stAxis[GVL.cXM].axisRef.ReadStatus();

////////////////////////////////////////////////////////////////////
//CCS to PLC
////////////////////////////////////////////////////////////////////
(* Check for new messages from CCS *)
eCommand := E_Commands.noCommand;
IF F_HaveDifferentIDs(inCalibrate, ackCalibrate) THEN
	ackCalibrate := inCalibrate;
	IF ackCalibrate.version <> nVersion THEN
		outIgnored.reason := 0; (*wrong version*)
		outIgnored.sequence := outIgnored.sequence + 1;
	ELSIF fbShutterSM.nSMState<>E_StatesMaint.Still AND ((fbShutterSM.nSMState<>E_StatesProd.Closing) OR (fbShutterSM.nSMState<>E_StatesProd.Traveling)) THEN
		outIgnored.reason := 1; (*ignored by state machine*)
		outIgnored.sequence := outIgnored.sequence + 1;
	ELSE
		eCommand := E_Commands.calibrate;
	END_IF
	
ELSIF F_HaveDifferentIDs(inChangeAxisEnable, ackChangeAxisEnable) THEN
	ackChangeAxisEnable	:= inChangeAxisEnable;
	IF ackChangeAxisEnable.version <> nVersion THEN
		outIgnored.reason := 0; (*wrong version*)
		outIgnored.sequence := outIgnored.sequence + 1;
	ELSIF fbShutterSM.nSMState <> E_StatesMaint.Still AND ((fbShutterSM.nSMState<>E_StatesProd.Closing) OR (fbShutterSM.nSMState<>E_StatesProd.Traveling)) THEN
		outIgnored.reason := 1; (*ignored by state machine*)
		outIgnored.sequence := outIgnored.sequence + 1;
	ELSE
		eCommand := E_Commands.changeAxisEnable;
	END_IF
	
ELSIF F_HaveDifferentIDs(inChangeBrakeState, ackChangeBrakeState) THEN
	ackChangeBrakeState	:= inChangeBrakeState;
	IF ackChangeBrakeState.version <> nVersion THEN
		outIgnored.reason := 0; (*wrong version*)
		outIgnored.sequence := outIgnored.sequence + 1;
	ELSIF fbShutterSM.nSMState <> E_StatesMaint.Still AND ((fbShutterSM.nSMState<>E_StatesProd.Closing) OR (fbShutterSM.nSMState<>E_StatesProd.Traveling)) THEN
		outIgnored.reason := 1; (*ignored by state machine*)
		outIgnored.sequence := outIgnored.sequence + 1;
	ELSE
		eCommand := E_Commands.changeBrakeState;
	END_IF
	
ELSIF F_HaveDifferentIDs(inClearAllFaults, ackClearAllFaults) THEN
	ackClearAllFaults := inClearAllFaults;
	IF ackClearAllFaults.version <> nVersion THEN
		outIgnored.reason := 0; (*wrong version*)
		outIgnored.sequence := outIgnored.sequence + 1;
	ELSIF fbShutterSM.nSMState <> E_StatesMaint.Still AND ((fbShutterSM.nSMState<>E_StatesProd.Closing) OR (fbShutterSM.nSMState<>E_StatesProd.Traveling)) THEN
		outIgnored.reason := 1; (*ignored by state machine*)
		outIgnored.sequence := outIgnored.sequence + 1;
	ELSE
		eCommand := E_Commands.clearAllFaults;
	END_IF
	
ELSIF F_HaveDifferentIDs(inClearAxisFaults, ackClearAxisFaults) THEN
	ackClearAxisFaults 	:= inClearAxisFaults;
	IF ackClearAxisFaults.version <> nVersion THEN
		outIgnored.reason := 0; (*wrong version*)
		outIgnored.sequence := outIgnored.sequence + 1;
	ELSIF fbShutterSM.nSMState <> E_StatesMaint.Still AND ((fbShutterSM.nSMState<>E_StatesProd.Closing) OR (fbShutterSM.nSMState<>E_StatesProd.Traveling)) THEN
		outIgnored.reason := 1; (*ignored by state machine*)
		outIgnored.sequence := outIgnored.sequence + 1;
	ELSE
		eCommand := E_Commands.clearAxisFaults;
	END_IF
	
ELSIF F_HaveDifferentIDs(inCloseShutter, ackCloseShutter) THEN
	ackCloseShutter 	:= inCloseShutter;
	IF ackCloseShutter.version <> nVersion THEN
		outIgnored.reason := 0; (*wrong version*)
		outIgnored.sequence := outIgnored.sequence + 1;
	ELSIF fbShutterSM.nSMState <> E_StatesProd.Opened AND ((fbShutterSM.nSMState<>E_StatesProd.Closing) OR (fbShutterSM.nSMState<>E_StatesProd.Traveling)) THEN
		outIgnored.reason := 1; (*ignored by state machine*)
		outIgnored.sequence := outIgnored.sequence + 1;
	ELSE
		eCommand := E_Commands.closeShutter;
	END_IF
	
ELSIF F_HaveDifferentIDs(inDisableAllAxes, ackDisableAllAxes) THEN
	ackDisableAllAxes :=  inDisableAllAxes;
	IF ackDisableAllAxes.version <> nVersion THEN
		outIgnored.reason := 0; (*wrong version*)
		outIgnored.sequence := outIgnored.sequence + 1;
	ELSIF fbShutterSM.nSMState <> E_StatesMaint.Still AND ((fbShutterSM.nSMState<>E_StatesProd.Closing) OR (fbShutterSM.nSMState<>E_StatesProd.Traveling)) THEN
		outIgnored.reason := 1; (*ignored by state machine*)
		outIgnored.sequence := outIgnored.sequence + 1;
	ELSE
		eCommand := E_Commands.disableAllAxes;
	END_IF
	
ELSIF F_HaveDifferentIDs( inEnableAllAxes, ackEnableAllAxes) THEN
	ackEnableAllAxes :=  inEnableAllAxes;
	IF ackEnableAllAxes.version <> nVersion THEN
		outIgnored.reason := 0; (*wrong version*)
		outIgnored.sequence := outIgnored.sequence + 1;
	ELSIF fbShutterSM.nSMState <> E_StatesMaint.Still AND ((fbShutterSM.nSMState<>E_StatesProd.Closing) OR (fbShutterSM.nSMState<>E_StatesProd.Traveling)) THEN
		outIgnored.reason := 1; (*ignored by state machine*)
		outIgnored.sequence := outIgnored.sequence + 1;
	ELSE
		eCommand := E_Commands.enableAllAxes;
	END_IF
	
ELSIF F_HaveDifferentIDs( inGoToProd, ackGoToProd) THEN
	ackGoToProd :=  inGoToProd;
	IF ackGoToProd.version <> nVersion THEN
		outIgnored.reason := 0; (*wrong version*)
		outIgnored.sequence := outIgnored.sequence + 1;
	ELSIF fbShutterSM.nSMState <> E_StatesMaint.Still AND ((fbShutterSM.nSMState<>E_StatesProd.Closing) OR (fbShutterSM.nSMState<>E_StatesProd.Traveling)) THEN
		outIgnored.reason := 1; (*ignored by state machine*)
		outIgnored.sequence := outIgnored.sequence + 1;
	ELSE
		eCommand := E_Commands.goToProd; 
	END_IF	
	
ELSIF F_HaveDifferentIDs( inHomeAxis, ackHomeAxis) THEN
	ackHomeAxis :=  inHomeAxis;
	IF ackHomeAxis.version <> nVersion THEN
		outIgnored.reason := 0; (*wrong version*)
		outIgnored.sequence := outIgnored.sequence + 1;
	ELSIF fbShutterSM.nSMState <> E_StatesMaint.Still AND ((fbShutterSM.nSMState<>E_StatesProd.Closing) OR (fbShutterSM.nSMState<>E_StatesProd.Traveling)) THEN
		outIgnored.reason := 1; (*ignored by state machine*)
		outIgnored.sequence := outIgnored.sequence + 1;
	ELSE
		eCommand := E_Commands.homeAxis;
	END_IF
	
ELSIF F_HaveDifferentIDs( inMoveAxisAbsolute, ackMoveAxisAbsolute) THEN
	ackMoveAxisAbsolute :=  inMoveAxisAbsolute;	
	IF ackMoveAxisAbsolute.version <> nVersion THEN
		outIgnored.reason := 0; (*wrong version*)
		outIgnored.sequence := outIgnored.sequence + 1;
	ELSIF fbShutterSM.nSMState <> E_StatesMaint.Still AND ((fbShutterSM.nSMState<>E_StatesProd.Closing) OR (fbShutterSM.nSMState<>E_StatesProd.Traveling)) THEN
		outIgnored.reason := 1; (*ignored by state machine*)
		outIgnored.sequence := outIgnored.sequence + 1;
	ELSE
		eCommand := E_Commands.moveAxisAbsolute;
	END_IF
	
ELSIF F_HaveDifferentIDs( inMoveAxisRelative, ackMoveAxisRelative) THEN
	ackMoveAxisRelative := inMoveAxisRelative;	
	IF ackMoveAxisRelative.version <> nVersion THEN
		outIgnored.reason := 0; (*wrong version*)
		outIgnored.sequence := outIgnored.sequence + 1;
	ELSIF fbShutterSM.nSMState <> E_StatesMaint.Still AND ((fbShutterSM.nSMState<>E_StatesProd.Closing) OR (fbShutterSM.nSMState<>E_StatesProd.Traveling)) THEN
		outIgnored.reason := 1; (*ignored by state machine*)
		outIgnored.sequence := outIgnored.sequence + 1;
	ELSE
		eCommand := E_Commands.moveAxisRelative;
	END_IF
	
ELSIF F_HaveDifferentIDs(inOpenShutter, ackOpenShutter) THEN
	ackOpenShutter := inOpenShutter;
	IF ackOpenShutter.version <> nVersion THEN
		outIgnored.reason := 0; (*wrong version*)
		outIgnored.sequence := outIgnored.sequence + 1;
	ELSIF fbShutterSM.nSMState <> E_StatesProd.Closed AND ((fbShutterSM.nSMState<>E_StatesProd.Closing) OR (fbShutterSM.nSMState<>E_StatesProd.Traveling)) THEN
		outIgnored.reason := 1; (*ignored by state machine*)
		outIgnored.sequence := outIgnored.sequence + 1;
	ELSE
		eCommand := E_Commands.openShutter;
	END_IF
	
ELSIF F_HaveDifferentIDs(inReset, ackReset) THEN
	ackReset := inReset;	
	IF ackClearAxisFaults.version <> nVersion THEN
		outIgnored.reason := 0; (*wrong version*)
		outIgnored.sequence := outIgnored.sequence + 1;
	ELSIF NOT bAuxElxPermit THEN
		outIgnored.reason := 1; (*ignored by state machine*)
		outIgnored.sequence := outIgnored.sequence + 1;
	ELSE
		eCommand := E_Commands.reset;
	END_IF
	
ELSIF F_HaveDifferentIDs(inTakeExposure, ackTakeExposure) THEN
	ackTakeExposure := inTakeExposure;	
	IF ackTakeExposure.version <> nVersion THEN
		outIgnored.reason := 0; (*wrong version*)
		outIgnored.sequence := outIgnored.sequence + 1;
	ELSIF fbShutterSM.nSMState <> E_StatesProd.Closed AND ((fbShutterSM.nSMState<>E_StatesProd.Closing) OR (fbShutterSM.nSMState<>E_StatesProd.Traveling)) THEN
		outIgnored.reason := 1; (*ignored by state machine*)
		outIgnored.sequence := outIgnored.sequence + 1;
	ELSE
		eCommand := E_Commands.takeExposure;
	END_IF
END_IF

////////////////////////////////////////////////////////////////////
(*shutter protection module*)
////////////////////////////////////////////////////////////////////

fbProtect(
	stAxis 				:= stAxis, 
	bAuxElxPermit 		:= bAuxElxPermit, 
	nState 				:= fbShutterSM.nSMState, 
	inTakeExposure		:= inTakeExposure,
	inMoveAxisAbsolute	:= inMoveAxisAbsolute,
	inMoveAxisRelative	:= inMoveAxisRelative,
	eCommand 			:= eCommand);

////////////////////////////////////////////////////////////////////
//Shutter State Machine
////////////////////////////////////////////////////////////////////
fbShutterSM(
	//inputs
	stAxis				:= stAxis,
	bAuxElxPermit		:= bAuxElxPermit,
	eCommand			:= eCommand,
	stCalibrate			:= inCalibrate,
	stChangeAxisEnable	:= inChangeAxisEnable,
	stChangeBrakeState	:= inChangeBrakeState,
	stClearAllFaults	:= inClearAllFaults,
	stClearAxisFaults	:= inClearAxisFaults,
	stCloseShutter		:= inCloseShutter,
	stDisableAllAxes	:= inDisableAllAxes,
	stEnableAllAxes		:= inEnableAllAxes,
	stGoToProd			:= inGoToProd,
	stHomeAxis			:= inHomeAxis,
	stMoveAxisAbsolute	:= inMoveAxisAbsolute,
	stMoveAxisRelative	:= inMoveAxisRelative,
	stOpenShutter		:= inOpenShutter,
	stReset				:= inReset,
	stTakeExposure		:= inTakeExposure);
////////////////////////////////////////////////////////////////////
//PLC to CCS
////////////////////////////////////////////////////////////////////
(*Set version*)
IF NOT bVersionSet THEN
	bVersionSet := TRUE;
	outShutterStatus.version := nVersion;
	outDisable.version := nVersion;
	outEnable.version := nVersion;
	outError.version := nVersion;
	outIgnored.version := nVersion;
	outTimer.version := nVersion;
	outCalibDone.version := nVersion;
END_IF

//updates upon changes---------------------------------------------
//Shutter disabled/enabled
stDisable_rtrig(CLK:=(fbShutterSM.nSMState = E_StatesTop.Disabled));
IF stDisable_rtrig.Q THEN
	outDisable.sequence := outDisable.sequence + 1;
END_IF
stDisable_ftrig(CLK:=(fbShutterSM.nSMState = E_StatesTop.Disabled));
IF stDisable_ftrig.Q THEN
	outEnable.sequence := outEnable.sequence + 1;
END_IF

//Exposure timer ended
outTimer.sequence := fbShutterSM.stOutTimer.sequence;

//Calibration Done
stCalibDone_rtrig(CLK:=fbShutterSM.bCalibDone);
IF stCalibDone_rtrig.Q THEN
	outCalibDone.hallPosCal := fbShutterSM.stOutCalibDone.hallPosCal;
	outCalibDone.sequence := outCalibDone.sequence + 1;
END_IF


//Periodic updates---------------------------------------------
fbOutTimer(IN:=TRUE, PT:=tUpdateTimer);
IF fbOutTimer.Q THEN
	fbOutTimer(IN:=FALSE);
	
	(*increment sequence*)
	outShutterStatus.sequence := outShutterStatus.sequence +1;
	
	(*shutter status update*)
	outShutterStatus.motionProfile := nMotionProfile;
	outShutterStatus.isCalibrated := (stAxis[GVL.cXP].bIsCalibrated AND stAxis[GVL.cXM].bIsCalibrated);
	outShutterStatus.smState := fbShutterSM.nSMState;

	(*shutter status update, axis XP specific*)
	outShutterStatus.axis[GVL.cXP].actPos := stAxis[GVL.cXP].axisRef.NcToPlc.ActPos;
	outShutterStatus.axis[GVL.cXP].actVel := stAxis[GVL.cXP].axisRef.NcToPlc.ActVelo;
	outShutterStatus.axis[GVL.cXP].setAcc := stAxis[GVL.cXP].axisRef.NcToPlc.SetAcc;
	outShutterStatus.axis[GVL.cXP].brakeSet := NOT stAxis[GVL.cXP].bBrake;
	outShutterStatus.axis[GVL.cXP].enabled := (stAxis[GVL.cXP].axisRef.PlcToNc.ControlDWord.0 AND	(*controlDword bit 0, 1, 2 corresponds to*)
												stAxis[GVL.cXP].axisRef.PlcToNc.ControlDWord.1 AND 	(*MC_Power parameters Enable, Enable_Positive, Enable_Negative*)
												stAxis[GVL.cXP].axisRef.PlcToNc.ControlDWord.2);
	outShutterStatus.axis[GVL.cXP].errorID	:= stAxis[GVL.cXP].axisRef.Status.ErrorID;
	outShutterStatus.axis[GVL.cXP].highLimit := stAxis[GVL.cXP].bLimitDeployed;
	outShutterStatus.axis[GVL.cXP].lowLimit := stAxis[GVL.cXP].bLimitHome;
	outShutterStatus.axis[GVL.cXP].isHomed := stAxis[GVL.cXP].axisRef.Status.Homed;
	outShutterStatus.axis[GVL.cXP].motorTemp := fMotorTemp;
	
	(*shutter status update, axis XM specific*)
	outShutterStatus.axis[GVL.cXM].actPos := stAxis[GVL.cXM].axisRef.NcToPlc.ActPos;
	outShutterStatus.axis[GVL.cXM].actVel := stAxis[GVL.cXM].axisRef.NcToPlc.ActVelo;
	outShutterStatus.axis[GVL.cXM].setAcc := stAxis[GVL.cXM].axisRef.NcToPlc.SetAcc;
	outShutterStatus.axis[GVL.cXM].brakeSet := NOT stAxis[GVL.cXM].bBrake;
	outShutterStatus.axis[GVL.cXM].enabled := (stAxis[GVL.cXM].axisRef.PlcToNc.ControlDWord.0 AND	(*controlDword bit 0, 1, 2 corresponds to*)
												stAxis[GVL.cXM].axisRef.PlcToNc.ControlDWord.1 AND 	(*MC_Power parameters Enable, Enable_Positive, Enable_Negative*)
												stAxis[GVL.cXM].axisRef.PlcToNc.ControlDWord.2);
	outShutterStatus.axis[GVL.cXM].errorID	:= stAxis[GVL.cXM].axisRef.Status.ErrorID;
	outShutterStatus.axis[GVL.cXM].highLimit := stAxis[GVL.cXM].bLimitHome;
	outShutterStatus.axis[GVL.cXM].lowLimit := stAxis[GVL.cXM].bLimitDeployed;
	outShutterStatus.axis[GVL.cXM].isHomed := stAxis[GVL.cXM].axisRef.Status.Homed;
	outShutterStatus.axis[GVL.cXM].motorTemp := fMotorTemp;
	
END_IF

////////////////////////////////////////////////////////////////////
//Other (protection, tracking, etc.
////////////////////////////////////////////////////////////////////

(*track motion of both blades*)
fbTracking(
	stAxis				:=stAxis, 
	eCommand			:=eCommand, 
	bMotionDone			:=fbShutterSM.bMotionDone, 
	inReset				:= inReset,
	inMoveAxisAbsolute	:= inMoveAxisAbsolute,
	inMoveAxisRelative	:= inMoveAxisRelative,
	stOutMotionDone		=>outMotionDone);

(*
//write persistent data to file every second
IF fbWriteDelay.Q THEN
	GVL.fbWritePersistentData(NETID:='', PORT:=851, START:=TRUE, TMOUT:=T#1S);
	fbWriteDelay(IN:=FALSE);
ELSE
	fbWriteDelay(IN:=TRUE, PT:=T#2S);
END_IF
*)
]]></ST>
    </Implementation>
    <LineIds Name="MAIN">
      <LineId Id="2480" Count="328" />
      <LineId Id="324" Count="0" />
    </LineIds>
  </POU>
</TcPlcObject>
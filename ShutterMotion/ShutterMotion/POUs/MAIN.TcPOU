<?xml version="1.0" encoding="utf-8"?>
<TcPlcObject Version="1.1.0.1" ProductVersion="3.1.4024.3">
  <POU Name="MAIN" Id="{f71d400f-d229-45a7-bebf-e505112d31c1}" SpecialFunc="None">
    <Declaration><![CDATA[PROGRAM MAIN
VAR
	//Axis
	{attribute 'TcLinkTo' := '	[0].bLimitHome		:= TIID^Device 1 (EtherCAT)^MCD-00 (EK1200)^MDR-00 (EL7047)^STM Status^Status^Digital input 1;
								[0].bLimitDeployed	:= TIID^Device 1 (EtherCAT)^MCD-00 (EK1200)^MDR-00 (EL7047)^STM Status^Status^Digital input 2;
								[0].bBrake			:= TIID^Device 1 (EtherCAT)^MCD-00 (EK1200)^MRE-01 (EL2622)^Channel 1^Output;
								[1].bLimitHome		:= TIID^Device 1 (EtherCAT)^MCD-00 (EK1200)^MDR-01 (EL7047)^STM Status^Status^Digital input 1;
								[1].bLimitDeployed	:= TIID^Device 1 (EtherCAT)^MCD-00 (EK1200)^MDR-01 (EL7047)^STM Status^Status^Digital input 2;
								[1].bBrake			:= TIID^Device 1 (EtherCAT)^MCD-00 (EK1200)^MRE-01 (EL2622)^Channel 2^Output'}
	stAxis		: ARRAY [GVL.cXP .. GVL.cXM] OF ST_AxisGroup;
	
	//state machine function block
	fbShutterSM	: FB_ShutterSM;
	
	//external input
	{attribute 'TcLinkTo' := 'TIID^Device 1 (EtherCAT)^MCD-00 (EK1200)^MIO-01 (EL1259)^MTI Inputs 2x Channel 8^Status^Input state'}
	bAuxElxPermit AT %I*	: BOOL;
	{attribute 'TcLinkTo' := 'TIID^Device 1 (EtherCAT)^MCD-00 (EK1200)^MIO-01 (EL1259)^MTO Outputs 2x Channel 1^Outputs^Output event state 1'}
	bFesPermit AT %Q*		: BOOL;
	{attribute 'TcLinkTo' := '	[0] := TIID^Device 1 (EtherCAT)^MCD-00 (EK1200)^MDR-00 (EL7047)^STM Synchron info data^Info data 1;
								[1] := TIID^Device 1 (EtherCAT)^MCD-00 (EK1200)^MDR-01 (EL7047)^STM Synchron info data^Info data 1'}
	fMotorTemp	AT %Q*		: ARRAY [0..1] OF UINT;  //temp in 1 degree C per increment

	//other function block and var
	fbPower		: FB_Power;
	fbProtect	: FB_Protection;
	fbProtectA	: FB_Protection;
	bSafetyOn	: BOOL := TRUE;
	fSpeedRel	: LREAL;
	fbTracking	: FB_Tracking;

	//Timing test vars
	fbInputRtrig	: R_trig;
	fbInputFtrig	: F_trig;
	
	//
	eCommand		: E_Commands;
	
	//communication IN
	inCalibrate, 			ackCalibrate			: ST_Calibrate;
	inChangeAxisEnable,		ackChangeAxisEnable		: ST_ChangeAxisEnable;
	inChangeBrakeState,		ackChangeBrakeState		: ST_ChangeBrakeState;
	inClearAllFaults,		ackClearAllFaults		: ST_ClearAllFaults;
	inClearAxisFaults,		ackClearAxisFaults		: ST_ClearAxisFaults;
	inCloseShutter,			ackCloseShutter			: ST_CloseShutter;
	inDisableAllAxes,		ackDisableAllAxes		: ST_DisableAllAxes;
	inEnableAllAxes,		ackEnableAllAxes		: ST_EnableAllAxes;
	inGoToProd,				ackGoToProd				: ST_GoToProd;
	inHomeAxis,				ackHomeAxis				: ST_HomeAxis;
	inMoveAxisAbsolute,		ackMoveAxisAbsolute		: ST_MoveAxisAbsolute;
	inMoveAxisRelative,		ackMoveAxisRelative		: ST_MoveAxisRelative;
	inOpenShutter,			ackOpenShutter			: ST_OpenShutter;
	inReset,				ackReset				: ST_Reset;
	inTakeExposure,			ackTakeExposure			: ST_TakeExposure;
	inToggleSafetyCheck,	ackToggleSafetyCheck	: ST_ToggleSafetyCheck;
	
	//communication OUT
	fbOutTimer			: TON;
	bVersionSet			: BOOL;
	outCalibDone		: ST_CalibDone;
	outDisable			: ST_Disable;
	outEnable			: ST_Enable;
	outError			: ST_Error;
	outIgnored			: ST_Ignored;
	outMotionDone		: ST_MotionDone;
	outShutterStatus	: ST_ShutterStatus;
	outTimer			: ST_Timer;
	
	//edge detection
	stDisable_ftrig		: F_TRIG;
	stDisable_rtrig		: R_TRIG;
	stError_rtrig		: R_TRIG;
	stExpoTimer_rtrig	: R_TRIG;
	stCalibDone_rtrig	: R_TRIG;
	
	//Read COE
	fbRead		: ARRAY [0..1] OF FB_EcCoeSdoRead;
	
END_VAR
VAR CONSTANT
	//Will change later once motionProfile and version are decided
	nMotionProfile		: DINT := 0;
	nVersion			: DINT := 2;
	tUpdateTimer		: TIME := T#2S;
	cMaxSpeedSafetyOFF	: LREAL := 1;
END_VAR

(*
SN001 scaling factor
motor 1: 0.0498281
motor 2: 0.0498517
*)
(*
SN002 scaling factor
motor 1: 0.0498327596
motor 2: 0.0498327596
*)	
]]></Declaration>
    <Implementation>
      <ST><![CDATA[(*update Axis_Ref status*)
stAxis[GVL.cXP].axisRef.ReadStatus();
stAxis[GVL.cXM].axisRef.ReadStatus();

////////////////////////////////////////////////////////////////////
//CCS to PLC
////////////////////////////////////////////////////////////////////
(* Check for new messages from CCS *)
eCommand := E_Commands.noCommand;
IF F_HaveDifferentIDs(inCalibrate, ackCalibrate) THEN
	ackCalibrate := inCalibrate;
	IF ackCalibrate.version <> nVersion THEN
		outIgnored.reason := 0; (*wrong version*)
		outIgnored.sequence := outIgnored.sequence + 1;
	ELSIF fbShutterSM.nSMState<>E_StatesMaint.Still THEN//AND ((fbShutterSM.nSMState<>E_StatesProd.Closing) OR (fbShutterSM.nSMState<>E_StatesProd.Traveling)) THEN
		outIgnored.reason := 1; (*ignored by state machine*)
		outIgnored.sequence := outIgnored.sequence + 1;
	ELSE
		eCommand := E_Commands.calibrate;
	END_IF
	
ELSIF F_HaveDifferentIDs(inChangeAxisEnable, ackChangeAxisEnable) THEN
	ackChangeAxisEnable	:= inChangeAxisEnable;
	IF ackChangeAxisEnable.version <> nVersion THEN
		outIgnored.reason := 0; (*wrong version*)
		outIgnored.sequence := outIgnored.sequence + 1;
	ELSIF fbShutterSM.nSMState <> E_StatesMaint.Still THEN //AND ((fbShutterSM.nSMState<>E_StatesProd.Closing) OR (fbShutterSM.nSMState<>E_StatesProd.Traveling)) THEN
		outIgnored.reason := 1; (*ignored by state machine*)
		outIgnored.sequence := outIgnored.sequence + 1;
	ELSE
		eCommand := E_Commands.changeAxisEnable;
	END_IF
	
ELSIF F_HaveDifferentIDs(inChangeBrakeState, ackChangeBrakeState) THEN
	ackChangeBrakeState	:= inChangeBrakeState;
	IF ackChangeBrakeState.version <> nVersion THEN
		outIgnored.reason := 0; (*wrong version*)
		outIgnored.sequence := outIgnored.sequence + 1;
	ELSIF fbShutterSM.nSMState <> E_StatesMaint.Still THEN //AND ((fbShutterSM.nSMState<>E_StatesProd.Closing) OR (fbShutterSM.nSMState<>E_StatesProd.Traveling)) THEN
		outIgnored.reason := 1; (*ignored by state machine*)
		outIgnored.sequence := outIgnored.sequence + 1;
	ELSE
		eCommand := E_Commands.changeBrakeState;
	END_IF
	
ELSIF F_HaveDifferentIDs(inClearAllFaults, ackClearAllFaults) THEN
	ackClearAllFaults := inClearAllFaults;
	IF ackClearAllFaults.version <> nVersion THEN
		outIgnored.reason := 0; (*wrong version*)
		outIgnored.sequence := outIgnored.sequence + 1;
	ELSIF fbShutterSM.nSMState <> E_StatesMaint.Still THEN //AND ((fbShutterSM.nSMState<>E_StatesProd.Closing) OR (fbShutterSM.nSMState<>E_StatesProd.Traveling)) THEN
		outIgnored.reason := 1; (*ignored by state machine*)
		outIgnored.sequence := outIgnored.sequence + 1;
	ELSE
		eCommand := E_Commands.clearAllFaults;
	END_IF
	
ELSIF F_HaveDifferentIDs(inClearAxisFaults, ackClearAxisFaults) THEN
	ackClearAxisFaults 	:= inClearAxisFaults;
	IF ackClearAxisFaults.version <> nVersion THEN
		outIgnored.reason := 0; (*wrong version*)
		outIgnored.sequence := outIgnored.sequence + 1;
	ELSIF fbShutterSM.nSMState <> E_StatesMaint.Still THEN //AND ((fbShutterSM.nSMState<>E_StatesProd.Closing) OR (fbShutterSM.nSMState<>E_StatesProd.Traveling)) THEN
		outIgnored.reason := 1; (*ignored by state machine*)
		outIgnored.sequence := outIgnored.sequence + 1;
	ELSE
		eCommand := E_Commands.clearAxisFaults;
	END_IF
	
ELSIF F_HaveDifferentIDs(inCloseShutter, ackCloseShutter) THEN
	ackCloseShutter 	:= inCloseShutter;
	IF ackCloseShutter.version <> nVersion THEN
		outIgnored.reason := 0; (*wrong version*)
		outIgnored.sequence := outIgnored.sequence + 1;
	ELSIF fbShutterSM.nSMState <> E_StatesProd.Opened THEN //AND ((fbShutterSM.nSMState<>E_StatesProd.Closing) OR (fbShutterSM.nSMState<>E_StatesProd.Traveling)) THEN
		outIgnored.reason := 1; (*ignored by state machine*)
		outIgnored.sequence := outIgnored.sequence + 1;
	ELSE
		eCommand := E_Commands.closeShutter;
	END_IF
	
ELSIF F_HaveDifferentIDs(inDisableAllAxes, ackDisableAllAxes) THEN
	ackDisableAllAxes :=  inDisableAllAxes;
	IF ackDisableAllAxes.version <> nVersion THEN
		outIgnored.reason := 0; (*wrong version*)
		outIgnored.sequence := outIgnored.sequence + 1;
	ELSIF fbShutterSM.nSMState <> E_StatesMaint.Still THEN //AND ((fbShutterSM.nSMState<>E_StatesProd.Closing) OR (fbShutterSM.nSMState<>E_StatesProd.Traveling)) THEN
		outIgnored.reason := 1; (*ignored by state machine*)
		outIgnored.sequence := outIgnored.sequence + 1;
	ELSE
		eCommand := E_Commands.disableAllAxes;
	END_IF
	
ELSIF F_HaveDifferentIDs( inEnableAllAxes, ackEnableAllAxes) THEN
	ackEnableAllAxes :=  inEnableAllAxes;
	IF ackEnableAllAxes.version <> nVersion THEN
		outIgnored.reason := 0; (*wrong version*)
		outIgnored.sequence := outIgnored.sequence + 1;
	ELSIF fbShutterSM.nSMState <> E_StatesMaint.Still THEN //AND ((fbShutterSM.nSMState<>E_StatesProd.Closing) OR (fbShutterSM.nSMState<>E_StatesProd.Traveling)) THEN
		outIgnored.reason := 1; (*ignored by state machine*)
		outIgnored.sequence := outIgnored.sequence + 1;
	ELSE
		eCommand := E_Commands.enableAllAxes;
	END_IF
	
ELSIF F_HaveDifferentIDs( inGoToProd, ackGoToProd) THEN
	ackGoToProd :=  inGoToProd;
	IF ackGoToProd.version <> nVersion THEN
		outIgnored.reason := 0; (*wrong version*)
		outIgnored.sequence := outIgnored.sequence + 1;
	ELSIF fbShutterSM.nSMState <> E_StatesMaint.Still THEN //AND ((fbShutterSM.nSMState<>E_StatesProd.Closing) OR (fbShutterSM.nSMState<>E_StatesProd.Traveling)) THEN
		outIgnored.reason := 1; (*ignored by state machine*)
		outIgnored.sequence := outIgnored.sequence + 1;
	ELSE
		eCommand := E_Commands.goToProd; 
	END_IF	
	
ELSIF F_HaveDifferentIDs( inHomeAxis, ackHomeAxis) THEN
	ackHomeAxis :=  inHomeAxis;
	IF ackHomeAxis.version <> nVersion THEN
		outIgnored.reason := 0; (*wrong version*)
		outIgnored.sequence := outIgnored.sequence + 1;
	ELSIF fbShutterSM.nSMState <> E_StatesMaint.Still THEN //AND ((fbShutterSM.nSMState<>E_StatesProd.Closing) OR (fbShutterSM.nSMState<>E_StatesProd.Traveling)) THEN
		outIgnored.reason := 1; (*ignored by state machine*)
		outIgnored.sequence := outIgnored.sequence + 1;
	ELSE
		eCommand := E_Commands.homeAxis;
	END_IF
	
ELSIF F_HaveDifferentIDs( inMoveAxisAbsolute, ackMoveAxisAbsolute) THEN
	ackMoveAxisAbsolute :=  inMoveAxisAbsolute;	
	IF ackMoveAxisAbsolute.version <> nVersion THEN
		outIgnored.reason := 0; (*wrong version*)
		outIgnored.sequence := outIgnored.sequence + 1;
	ELSIF fbShutterSM.nSMState <> E_StatesMaint.Still THEN //AND ((fbShutterSM.nSMState<>E_StatesProd.Closing) OR (fbShutterSM.nSMState<>E_StatesProd.Traveling)) THEN
		outIgnored.reason := 1; (*ignored by state machine*)
		outIgnored.sequence := outIgnored.sequence + 1;
	ELSE
		eCommand := E_Commands.moveAxisAbsolute;
	END_IF
	
ELSIF F_HaveDifferentIDs( inMoveAxisRelative, ackMoveAxisRelative) THEN
	ackMoveAxisRelative := inMoveAxisRelative;	
	IF ackMoveAxisRelative.version <> nVersion THEN
		outIgnored.reason := 0; (*wrong version*)
		outIgnored.sequence := outIgnored.sequence + 1;
	ELSIF fbShutterSM.nSMState <> E_StatesMaint.Still THEN //AND ((fbShutterSM.nSMState<>E_StatesProd.Closing) OR (fbShutterSM.nSMState<>E_StatesProd.Traveling)) THEN
		outIgnored.reason := 1; (*ignored by state machine*)
		outIgnored.sequence := outIgnored.sequence + 1;
	ELSE
		eCommand := E_Commands.moveAxisRelative;
	END_IF
	
ELSIF F_HaveDifferentIDs(inOpenShutter, ackOpenShutter) THEN
	ackOpenShutter := inOpenShutter;
	IF ackOpenShutter.version <> nVersion THEN
		outIgnored.reason := 0; (*wrong version*)
		outIgnored.sequence := outIgnored.sequence + 1;
	ELSIF fbShutterSM.nSMState <> E_StatesProd.Closed THEN //AND ((fbShutterSM.nSMState<>E_StatesProd.Closing) OR (fbShutterSM.nSMState<>E_StatesProd.Traveling)) THEN
		outIgnored.reason := 1; (*ignored by state machine*)
		outIgnored.sequence := outIgnored.sequence + 1;
	ELSE
		eCommand := E_Commands.openShutter;
	END_IF
	
ELSIF F_HaveDifferentIDs(inReset, ackReset) THEN
	ackReset := inReset;	
	IF ackReset.version <> nVersion THEN
		outIgnored.reason := 0; (*wrong version*)
		outIgnored.sequence := outIgnored.sequence + 1;
	ELSIF NOT bAuxElxPermit THEN
		outIgnored.reason := 1; (*ignored by state machine*)
		outIgnored.sequence := outIgnored.sequence + 1;
	ELSE
		eCommand := E_Commands.reset;
	END_IF
	
ELSIF F_HaveDifferentIDs(inTakeExposure, ackTakeExposure) THEN
	ackTakeExposure := inTakeExposure;	
	IF ackTakeExposure.version <> nVersion THEN
		outIgnored.reason := 0; (*wrong version*)
		outIgnored.sequence := outIgnored.sequence + 1;
	ELSIF fbShutterSM.nSMState <> E_StatesProd.Closed THEN //AND ((fbShutterSM.nSMState<>E_StatesProd.Closing) OR (fbShutterSM.nSMState<>E_StatesProd.Traveling)) THEN
		outIgnored.reason := 1; (*ignored by state machine*)
		outIgnored.sequence := outIgnored.sequence + 1;
	ELSE
		eCommand := E_Commands.takeExposure;
	END_IF
	
ELSIF F_HaveDifferentIDs(inToggleSafetyCheck, ackToggleSafetyCheck) THEN
	ackToggleSafetyCheck := inToggleSafetyCheck;	
	IF ackToggleSafetyCheck.version <> nVersion THEN
		outIgnored.reason := 0; (*wrong version*)
		outIgnored.sequence := outIgnored.sequence + 1;
	ELSIF fbShutterSM.nSMState <> E_StatesProd.Closed THEN
		outIgnored.reason := 1; (*ignored by state machine*)
		outIgnored.sequence := outIgnored.sequence + 1;
	ELSE
		eCommand := E_Commands.turnSafetyOff;
	END_IF
	
END_IF

////////////////////////////////////////////////////////////////////
(*shutter protection module*)
////////////////////////////////////////////////////////////////////
IF (eCommand = E_Commands.turnSafetyOff) THEN
	bSafetyOn := NOT bSafetyOn;
	outShutterStatus.isSafetyOn := bSafetyOn;
	outShutterStatus.sequence := outShutterStatus.sequence +1;
END_IF
IF (fbTracking.bMotionDone) THEN
	bSafetyOn := TRUE;
END_IF

IF bSafetyOn THEN
	fbProtect(
		stAxis 				:= stAxis, 
		bAuxElxPermit 		:= bAuxElxPermit, 
		nState 				:= fbShutterSM.nSMState,
		eCommand 			:= eCommand,
		
		inCalibrate			:= inCalibrate,
		inChangeAxisEnable	:= inChangeAxisEnable,
		inChangeBrakeState	:= inChangeBrakeState,
		inClearAllFaults	:= inClearAllFaults,
		inClearAxisFaults	:= inClearAxisFaults,
		inCloseShutter		:= inCloseShutter,
		inDisableAllAxes	:= inDisableAllAxes,
		inEnableAllAxes		:= inEnableAllAxes,
		inGoToProd			:= inGoToProd,
		inHomeAxis			:= inHomeAxis,
		inMoveAxisAbsolute	:= inMoveAxisAbsolute,
		inMoveAxisRelative	:= inMoveAxisRelative,
		inOpenShutter		:= inOpenShutter,
		inReset				:= inReset,
		inTakeExposure		:= inTakeExposure,
		inToggleSafetyCheck	:= inToggleSafetyCheck);
ELSE
	IF (inReset.speed > cMaxSpeedSafetyOFF) THEN
		inReset.speed := cMaxSpeedSafetyOFF;
	END_IF
	IF (inMoveAxisAbsolute.speed > cMaxSpeedSafetyOFF) THEN
		inMoveAxisAbsolute.speed := cMaxSpeedSafetyOFF;
	END_IF
	
	fSpeedRel	:= (2*ABS(inMoveAxisRelative.distance)/(TIME_TO_LREAL(inMoveAxisRelative.moveTime)/1000));
	if (fSpeedRel > cMaxSpeedSafetyOFF) THEN
		fSpeedRel := cMaxSpeedSafetyOFF;
		inMoveAxisRelative.moveTime := LREAL_TO_TIME(1000*2*ABS(inMoveAxisRelative.distance)/(fSpeedRel));
	END_IF
END_IF
	
////////////////////////////////////////////////////////////////////
//Shutter State Machine
////////////////////////////////////////////////////////////////////
fbShutterSM(
	//inputs
	stAxis				:= stAxis,
	bAuxElxPermit		:= bAuxElxPermit,
	eCommand			:= eCommand,
	stCalibrate			:= inCalibrate,
	stChangeAxisEnable	:= inChangeAxisEnable,
	stChangeBrakeState	:= inChangeBrakeState,
	stClearAllFaults	:= inClearAllFaults,
	stClearAxisFaults	:= inClearAxisFaults,
	stCloseShutter		:= inCloseShutter,
	stDisableAllAxes	:= inDisableAllAxes,
	stEnableAllAxes		:= inEnableAllAxes,
	stGoToProd			:= inGoToProd,
	stHomeAxis			:= inHomeAxis,
	stMoveAxisAbsolute	:= inMoveAxisAbsolute,
	stMoveAxisRelative	:= inMoveAxisRelative,
	stOpenShutter		:= inOpenShutter,
	stReset				:= inReset,
	stTakeExposure		:= inTakeExposure);
	
////////////////////////////////////////////////////////////////////
//PLC to CCS
////////////////////////////////////////////////////////////////////
(*Set version*)
IF NOT bVersionSet THEN
	bVersionSet 				:= TRUE;
	outShutterStatus.version 	:= nVersion;
	outDisable.version 			:= nVersion;
	outEnable.version 			:= nVersion;
	outError.version 			:= nVersion;
	outIgnored.version 			:= nVersion;
	outTimer.version 			:= nVersion;
	outCalibDone.version 		:= nVersion;
	outMotionDone.version		:= nVersion;
END_IF

//updates upon changes---------------------------------------------
//Shutter disabled/enabled
stDisable_rtrig(CLK:=(fbShutterSM.nSMState = E_StatesTop.Disabled));
IF stDisable_rtrig.Q THEN
	outDisable.sequence := outDisable.sequence + 1;
END_IF
stDisable_ftrig(CLK:=(fbShutterSM.nSMState = E_StatesTop.Disabled));
IF stDisable_ftrig.Q THEN
	outEnable.sequence := outEnable.sequence + 1;
END_IF

//Exposure timer ended
outTimer.sequence := fbShutterSM.stOutTimer.sequence;

//Calibration Done
stCalibDone_rtrig(CLK:=fbShutterSM.bCalibDone);
IF stCalibDone_rtrig.Q THEN
	outCalibDone.hallPosCal := fbShutterSM.stOutCalibDone.hallPosCal;
	outCalibDone.sequence := outCalibDone.sequence + 1;
END_IF

//Periodic updates---------------------------------------------
fbOutTimer(IN:=TRUE, PT:=tUpdateTimer);
IF fbOutTimer.Q THEN
	fbOutTimer(IN:=FALSE);
	
	(*increment sequence*)
	outShutterStatus.sequence := outShutterStatus.sequence +1;

	(*shutter status update, common*)
	outShutterStatus.motionProfile := nMotionProfile;
	outShutterStatus.isCalibrated := (stAxis[GVL.cXP].bIsCalibrated AND stAxis[GVL.cXM].bIsCalibrated);
	outShutterStatus.smState := fbShutterSM.nSMState;
	
	(*shutter status update, axis XP specific*)
	outShutterStatus.axis[GVL.cXP].actPos := stAxis[GVL.cXP].axisRef.NcToPlc.ActPos;
	outShutterStatus.axis[GVL.cXP].actVel := stAxis[GVL.cXP].axisRef.NcToPlc.ActVelo;
	outShutterStatus.axis[GVL.cXP].setAcc := stAxis[GVL.cXP].axisRef.NcToPlc.SetAcc;
	outShutterStatus.axis[GVL.cXP].brakeSet := NOT stAxis[GVL.cXP].bBrake;
	outShutterStatus.axis[GVL.cXP].enabled := (stAxis[GVL.cXP].axisRef.PlcToNc.ControlDWord.0 AND	(*controlDword bit 0, 1, 2 corresponds to*)
												stAxis[GVL.cXP].axisRef.PlcToNc.ControlDWord.1 AND 	(*MC_Power parameters Enable, Enable_Positive, Enable_Negative*)
												stAxis[GVL.cXP].axisRef.PlcToNc.ControlDWord.2);
	outShutterStatus.axis[GVL.cXP].errorID	:= stAxis[GVL.cXP].axisRef.Status.ErrorID;
	outShutterStatus.axis[GVL.cXP].highLimit := stAxis[GVL.cXP].bLimitDeployed;
	outShutterStatus.axis[GVL.cXP].lowLimit := stAxis[GVL.cXP].bLimitHome;
	outShutterStatus.axis[GVL.cXP].isHomed := stAxis[GVL.cXP].axisRef.Status.Homed;
	outShutterStatus.axis[GVL.cXP].motorTemp := fMotorTemp[0];
	
	(*shutter status update, axis XM specific*)
	outShutterStatus.axis[GVL.cXM].actPos := stAxis[GVL.cXM].axisRef.NcToPlc.ActPos;
	outShutterStatus.axis[GVL.cXM].actVel := stAxis[GVL.cXM].axisRef.NcToPlc.ActVelo;
	outShutterStatus.axis[GVL.cXM].setAcc := stAxis[GVL.cXM].axisRef.NcToPlc.SetAcc;
	outShutterStatus.axis[GVL.cXM].brakeSet := NOT stAxis[GVL.cXM].bBrake;
	outShutterStatus.axis[GVL.cXM].enabled := (stAxis[GVL.cXM].axisRef.PlcToNc.ControlDWord.0 AND	(*controlDword bit 0, 1, 2 corresponds to*)
												stAxis[GVL.cXM].axisRef.PlcToNc.ControlDWord.1 AND 	(*MC_Power parameters Enable, Enable_Positive, Enable_Negative*)
												stAxis[GVL.cXM].axisRef.PlcToNc.ControlDWord.2);
	outShutterStatus.axis[GVL.cXM].errorID	:= stAxis[GVL.cXM].axisRef.Status.ErrorID;
	outShutterStatus.axis[GVL.cXM].highLimit := stAxis[GVL.cXM].bLimitHome;
	outShutterStatus.axis[GVL.cXM].lowLimit := stAxis[GVL.cXM].bLimitDeployed;
	outShutterStatus.axis[GVL.cXM].isHomed := stAxis[GVL.cXM].axisRef.Status.Homed;
	outShutterStatus.axis[GVL.cXM].motorTemp := fMotorTemp[1];
	
END_IF

////////////////////////////////////////////////////////////////////
//Other (tracking, temperature, etc.)
////////////////////////////////////////////////////////////////////

(*track motion of both blades*)
fbTracking(
	stAxis				:=stAxis, 
	eCommand			:=eCommand, 
	bMotionDone			:=fbShutterSM.bMotionDone, 
	inReset				:= inReset,
	inMoveAxisAbsolute	:= inMoveAxisAbsolute,
	inMoveAxisRelative	:= inMoveAxisRelative,
	stOutMotionDone		=>outMotionDone);

(*When shutter is in motion, remove permit for Filter Changer*)	
IF (Main.outShutterStatus.smState=E_StatesMaint.Still OR Main.outShutterStatus.smState=E_StatesProd.Closed OR 
	Main.outShutterStatus.smState=E_StatesProd.Opened OR Main.outShutterStatus.smState=E_StatesTop.Disabled) THEN
		bFesPermit := TRUE;
ELSE
		bFesPermit := FALSE;
END_IF
	
(*
//write persistent data to file every second
IF fbWriteDelay.Q THEN
	GVL.fbWritePersistentData(NETID:='', PORT:=851, START:=TRUE, TMOUT:=T#1S);
	fbWriteDelay(IN:=FALSE);
ELSE
	fbWriteDelay(IN:=TRUE, PT:=T#2S);
END_IF
*)
]]></ST>
    </Implementation>
    <LineIds Name="MAIN">
      <LineId Id="2480" Count="187" />
      <LineId Id="3130" Count="0" />
      <LineId Id="3133" Count="9" />
      <LineId Id="3131" Count="1" />
      <LineId Id="2668" Count="4" />
      <LineId Id="3469" Count="0" />
      <LineId Id="3471" Count="0" />
      <LineId Id="3473" Count="1" />
      <LineId Id="3472" Count="0" />
      <LineId Id="3475" Count="2" />
      <LineId Id="3467" Count="0" />
      <LineId Id="3403" Count="0" />
      <LineId Id="3251" Count="3" />
      <LineId Id="3307" Count="0" />
      <LineId Id="3306" Count="0" />
      <LineId Id="2682" Count="0" />
      <LineId Id="3260" Count="14" />
      <LineId Id="3412" Count="0" />
      <LineId Id="3461" Count="2" />
      <LineId Id="3413" Count="0" />
      <LineId Id="3464" Count="2" />
      <LineId Id="3420" Count="0" />
      <LineId Id="3415" Count="0" />
      <LineId Id="3423" Count="0" />
      <LineId Id="3421" Count="1" />
      <LineId Id="3248" Count="1" />
      <LineId Id="2683" Count="22" />
      <LineId Id="3101" Count="0" />
      <LineId Id="2706" Count="12" />
      <LineId Id="3102" Count="0" />
      <LineId Id="2719" Count="21" />
      <LineId Id="2742" Count="7" />
      <LineId Id="3149" Count="0" />
      <LineId Id="3151" Count="2" />
      <LineId Id="2755" Count="0" />
      <LineId Id="3150" Count="0" />
      <LineId Id="2756" Count="42" />
      <LineId Id="2888" Count="0" />
      <LineId Id="2799" Count="0" />
      <LineId Id="2891" Count="0" />
      <LineId Id="2893" Count="1" />
      <LineId Id="2897" Count="1" />
      <LineId Id="2895" Count="0" />
      <LineId Id="2890" Count="0" />
      <LineId Id="2800" Count="8" />
      <LineId Id="324" Count="0" />
    </LineIds>
  </POU>
</TcPlcObject>
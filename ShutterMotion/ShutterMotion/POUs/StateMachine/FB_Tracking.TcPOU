<?xml version="1.0" encoding="utf-8"?>
<TcPlcObject Version="1.1.0.1" ProductVersion="3.1.4022.18">
  <POU Name="FB_Tracking" Id="{462a5933-fe60-42d4-a574-27170521c4c5}" SpecialFunc="None">
    <Declaration><![CDATA[FUNCTION_BLOCK FB_Tracking
VAR_IN_OUT
	stAxis  : ARRAY [GVL.cXP .. GVL.cXM] OF ST_AxisGroup;	
END_VAR
VAR_INPUT
	eCommand 			: E_Commands;
	bMotionDone			: BOOL;
	inReset				: ST_Reset;
	inMoveAxisAbsolute	: ST_MoveAxisAbsolute;
	inMoveAxisRelative	: ST_MoveAxisRelative;
END_VAR
VAR_OUTPUT
	stOutMotionDone : ST_MotionDone;
END_VAR
VAR
	//used in tracking Action
	stTrack			: ARRAY [0 .. 4] OF ST_TRACK;
	stTrackTemp		: ST_TRACK;
	bGoNextSeq		: BOOL;
	nAxisID			: INT;
	nMask			: ULINT := 16#FFFF_FFFF_0000_0000;
	
	//used in determining target duration
	fSpeed			: LREAL;
	tTargetDur		: LTIME;
	fDistance		: LREAL;
	
	fbMoving_Rtrig : ARRAY[0 .. 1] OF R_TRIG;
	fbRtrig		: ARRAY[GVL.cHallLower..GVL.cHallUpper] OF R_Trig;
	bInMotion	: BOOL;
	stMotionDone : ARRAY [0..1] OF ST_MotionDone;	
	nSequence	: DINT;
	nLastMoved	: INT;
	
	//counter
	i, j, k, m		: INT := 0;
	nTPC	: INT; //Trip Per Cycle
	
	(*
	//TestVar
	testRtrig : R_TRIG;
	testRtrig2 : R_TRIG;
	testInt: INT;
	testInt3: INT;
	testInt4: INT;
	testLREAL : LREAL;
	testTemp : ARRAY[0 .. 4] OF ST_Track;
	testTime : ARRAY[0 .. 4] OF T_DCTIME64;
	teststTrack : ARRAY[0 .. 4] OF T_DCTIME64;
	testDCTime	: ARRAY[0 .. 4] OF T_DCTIME64;
	nMask2	 : ULINT := 16#0000_0000_FFFF_FFFF;
	a, b : INT;
	*)
	
	// Record these times at the start of a new motion.
	ptpStartExtTime: ARRAY [GVL.cXP .. GVL.cXM] OF T_DCTIME64;   // The external time from the PTP module MTM-00.
	plcStartDcTime: ARRAY [GVL.cXP .. GVL.cXM] OF T_DCTIME64;    // The result of F_GetCurDcTaskTime64().
	adc0StartDcTime: ARRAY [GVL.cXP .. GVL.cXM] OF T_DCTIME64;   // What MIO-00 thinks the DC time is.
	adc1StartDcTime: ARRAY [GVL.cXP .. GVL.cXM] OF T_DCTIME64;   // What MIO-01 thinks the DC time is.
	
	(* Do we need to make another pass of sorting of Hall timestamps. *)
	newPass: BOOL:= TRUE;
	
	// Temporary variables used in the calculation of absolute (ext) timestamps
	// for Hall events and encoder samples.
	adcBase: T_DCTIME64;     // The 32-bit motion start time for the right axis and ADC module.
	adcEvent: T_DCTIME64;    // The elapsed time since adcBase for the Hall event.
	adcExtTime: T_DCTIME64;  // The final absolute timestamp for the Hall event.
	encExtTime: T_DCTIME64;
END_VAR


]]></Declaration>
    <Implementation>
      <ST><![CDATA[//////////////////////////////////////////////////////////////
// Call this function block to process any updated information about blade set motion and send updates to CCS if required.
//////////////////////////////////////////////////////////////

stAxis[GVL.cXP].bTrackedFlag:=FALSE;
stAxis[GVL.cXM].bTrackedFlag:=FALSE;
nTPC:=0;

(* variable for debugging
testInt3:=0;
testInt4:=0;
*)

// Detect start of motion for the +X blade set, rising edge of its Moving flag from the motor controller.
// Reset motion profile parameters in a local motion-done message not monitored by CCS.
fbMoving_Rtrig[GVL.cXP](CLK:=stAxis[GVL.cXP].axisRef.Status.Moving);
IF fbMoving_Rtrig[GVL.cXP].Q THEN
	// Record clock values for the various players: PLC, ADCs, PTP module.
	ptpStartExtTime[GVL.cXP] := GVL.ptpExtTime;
	plcStartDcTime[GVL.cXP] := F_GetCurDcTaskTime64();
	adc0StartDcTime[GVL.cXP] := GVL.adc0DcTime;
	adc1StartDcTime[GVL.cXP] := GVL.adc1DcTime;
	// Prepare to record motion profile information.
	bInMotion:=TRUE;  // We're moving!
	stMotionDone[GVL.cXP].axisNum := GVL.cXP; // Axis is +X.
	stMotionDone[GVL.cXP].nsamples := 0;      // No encoder samples yet.
	stMotionDone[GVL.cXP].ntrans := 0;        // No Hall transitions yet.
	stMotionDone[gvl.cXP].startPos := stAxis[GVL.cXP].axisRef.NcToPlc.ActPos;   // Where are we now?
	stMotionDone[GVL.cXP].startTime := ptpStartExtTime[GVL.cXP];
	stMotionDone[GVL.cXP].targetDur := LTIME#0D0H0M0S0MS0US0NS;  // Don't know yet how long this motion will take.
END_IF

// The same, but for the -X blade set.
fbMoving_Rtrig[GVL.cXM](CLK:=stAxis[GVL.cXM].axisRef.Status.Moving);
IF fbMoving_Rtrig[GVL.cXM].Q THEN
	// Record clock values for the various players: PLC, ADCs, PTP module.
	ptpStartExtTime[GVL.cXM] := GVL.ptpExtTime;
	plcStartDcTime[GVL.cXM] := F_GetCurDcTaskTime64();
	adc0StartDcTime[GVL.cXM] := GVL.adc0DcTime;
	adc1StartDcTime[GVL.cXM] := GVL.adc1DcTime;
	// Prepare to record motion profile information.
	bInMotion:=TRUE;
	stMotionDone[gvl.cXM].axisNum := GVL.cXM;
	stMotionDone[gvl.cXM].nsamples := 0;
	stMotionDone[gvl.cXM].ntrans := 0;
	stMotionDone[gvl.cXM].startPos := stAxis[GVL.cXM].axisRef.NcToPlc.ActPos;
	stMotionDone[gvl.cXM].startTime := ptpStartExtTime[GVL.cXM];
	stMotionDone[gvl.cXM].targetDur := LTIME#0D0H0M0S0MS0US0NS;
END_IF

// Assuming that a motion command was issued by CCS, calculate how long the motion is supposed to last.
// Output is tTargetDur.
IF eCommand = E_Commands.takeExposure THEN
	fSpeed	:= inReset.speed;   // Speed from reset command (actually now set elsewhere in this PLC code).
	IF (fSpeed>0) THEN
		IF (fSpeed>1668.355556) THEN
			fSpeed:=1668.355556;
		END_IF
		tTargetDur 	:= LREAL_TO_LTIME((2*GVL.cPosEnd)/(fSpeed)*EXPT(10,9));
	END_IF
ELSIF eCommand = E_Commands.moveAxisAbsolute THEN
	// MoveAxisAbsolute message contains target position and speed of motion.
	fDistance := ABS(stAxis[inMoveAxisAbsolute.axisIndex].axisRef.NcToPlc.ActPos - inMoveAxisAbsolute.position);
	fSpeed	:= inMoveAxisAbsolute.speed;
	IF (fSpeed>0) THEN
		IF (fSpeed>1668.355556) THEN
			fSpeed:=1668.355556;
		END_IF
		tTargetDur 	:= LREAL_TO_LTIME(((2*fDistance)/(fSpeed))*EXPT(10,9));
	END_IF
ELSIF eCommand = E_Commands.moveAxisRelative THEN
	// MoveAxisRelative message contains position change and how long to take to do it.
	tTargetDur	:= TIME_TO_LTIME(inMoveAxisRelative.moveTime);
END_IF

//Checks to see which blade set last moved.
// This seems to assume that only one blade set is moving.
IF (stAxis[GVL.cXM].axisRef.Status.Moving AND stAxis[GVL.cXP].axisRef.Status.InTargetPosition) THEN
	nLastMoved:=GVL.cXM;
ELSIF (stAxis[GVL.cXP].axisRef.Status.Moving AND stAxis[GVL.cXM].axisRef.Status.InTargetPosition) THEN
	nLastMoved:=GVL.cXP;
END_IF

////////// Handle the completion of a blade set motion. //////////
IF bMotionDone THEN
	//use for determining which blade set has finished during a travelling slit motion
	IF (stAxis[GVL.cXM].axisRef.Status.Moving AND stAxis[GVL.cXP].axisRef.Status.InTargetPosition) THEN
		nAxisID:=GVL.cXP;
	ELSIF (stAxis[GVL.cXP].axisRef.Status.Moving AND stAxis[GVL.cXM].axisRef.Status.InTargetPosition) THEN
		nAxisID:=GVL.cXM;
	ELSE 
		nAxisID:=nLastMoved;
	END_IF
	//bInMotion flag remains true if any of the blade set is still in motion
	IF ((NOT stAxis[GVL.cXP].axisRef.Status.Moving) AND (NOT stAxis[GVL.cXM].axisRef.Status.Moving)) THEN
		bInMotion := FALSE;
	END_IF
	// Complete our local motion-done message.
	nSequence := nSequence+1;
	// The motor controller doesn't report exactly when motion was completed, so we assume that it was when the process data
	// from the controller reached us, i.e., at the start of the current cycle.
	stMotionDone[nAxisID].actualDur := ULINT_TO_LTIME(F_TaskStartDcTimeToExt() - stMotionDone[nAxisID].startTime);
	stMotionDone[nAxisID].targetDur := tTargetDur;
	stMotionDone[nAxisID].targetPos := stAxis[nAxisID].axisRef.NcToPlc.TargetPos;
	stMotionDone[nAxisID].endPos := stAxis[nAxisID].axisRef.NcToPlc.ActPos;
	stMotionDone[nAxisId].ptpState := MAIN.ptpDiagInfo.PTPState;
	stMotionDone[nAxisId].leapSeconds := MAIN.ptpDiagInfo.CurrentUtcOffset;
	stMotionDone[nAxisId].leapIsValid := TO_BOOL(MAIN.ptpDiagInfo.CurrentUtcOffsetIsValid);
	// Copy our local motion-done message to the location that's monitored by CCS.
	stOutMotionDone:=stMotionDone[nAxisID];
	stOutMotionDone.sequence:=nSequence;  // Ensure message gets sent to CCS by making sure that at least one field has a changed value.
END_IF


////////// Collect information on any Hall switch transitions from the time-stamping ADCs. //////////
// The time stamps recorded are DC time, so must eventually be converted to ext time. Actually, only the lower 32 bits of DC time are recorded, making
// it necessary to correct for possible rollover of those lower 32 bits in the time since the stamp was recorded. In order to correct for this,
// we first naively add the upper 32 bits of the DC time of the start of the cycle. We know that all the transitions we see now must have
// occurred before the start of the current cycle, so if the naively corrected DC time is later than that we subtract one from the upper
// 32 bits. This works only if at most one rollover occurred which means that timestamps must be less than 2^32 nanoseconds old, or
// about 4.29 seconds.
//
// nNumOfINputs[i] is linked to the event count for the ADC channel assigned to Hall sensor i.
// bInputEventState[i] is linked to the current ADC channel state for Hall sensor i.
// nInputEventTime[i] is linked to the first transition timestamp for Hall sensor i. We assume there is at most one.
// New timestamps are added to the end of the stTrack array.

// N. B.: Both blade sets may be moving so we can't assign the Hall events to one or the other just yet. Neither can
// we calculate time since motion start since we don't know which start time to use.
FOR i:=GVL.cHallLower TO GVL.cHallUpper BY 1 DO
	fbRtrig[i](CLK:=GVL.nNumOfInputs[i].0);  // Look for a rising edge in channel status, which means we have a transition timestamp.
	IF fbRtrig[i].Q THEN
		// Identifies which Hall switch tripped
		stTrack[nTPC].nSeqToCompare := INT_TO_WORD((i*10)+5);
		stTrack[nTPC].bEdgeToCompare := GVL.bInputEventState[i];
		stTrack[nTPC].nHallID := i;
		stTrack[nTPC].tScanTime := GVL.nInputEventTime[stTrack[nTPC].nHallID];
		// Count the number of entries stored in stTrack.
		nTPC:=nTPC+1;

(*
		//For debugging only: To see the highest number of trip per cycle
		testRTrig2(CLK:=(nTPC>=2));
		IF testRTrig2.Q THEN
			testInt3 := 1;
		END_IF
		testRTrig(CLK:=(nTPC>=3));
		IF testRTrig.Q THEN
			testTemp := stTrack;
			testInt4 := 1;
		END_IF
		IF m<nTPC THEN
			m:= nTPC;
		END_IF
		
		//For debugging only: To see the highest number of trip per cycle
		IF ((tCycleStart - stTrack[0].tScanTime)>2000000) AND nTPC=1 THEN
			testTime[0]	:= tCycleStart - stTrack[0].tScanTime;
			teststTrack[0] := stTrack[0].tScanTime;
			 testDCTime[0] := tCycleStart;
		END_IF
		IF ((tCycleStart - stTrack[1].tScanTime)>2000000) AND nTPC=2 THEN
			testTime[1]	:= tCycleStart - stTrack[1].tScanTime;
			teststTrack[1] := stTrack[1].tScanTime;
			testDCTime[1] := tCycleStart;
		END_IF
		IF ((tCycleStart - stTrack[2].tScanTime)>2000000) AND nTPC=3 THEN
			testTime[2]	:= tCycleStart - stTrack[2].tScanTime;
			teststTrack[2] := stTrack[2].tScanTime;
			testDCTime[2] := tCycleStart;
		END_IF
		IF ((tCycleStart - stTrack[3].tScanTime)>2000000) AND nTPC=4 THEN
			testTime[3]	:= tCycleStart - stTrack[3].tScanTime;
			teststTrack[3] := stTrack[3].tScanTime;
			testDCTime[3] := tCycleStart;
		END_IF
	*)
	END_IF
(*
	//For debugging - checks to see if the same hall switch is tripped twice in one cycle
	IF GVL.nNumOfInputs[i]=2 THEN
		testInt:=testint+1;
	END_IF
*)
END_FOR


	
// If we picked up some Hall transitions this cycle, then we need to take position samples (encoder readout).
// We want to check if the position of a blade set at the time of a Hall transition agrees with the
// Hall switch position taken from the last calibration.
IF nTPC>0 THEN
	FOR k:=0 TO nTPC-1 BY 1 DO
		IF (stAxis[GVL.cXP].axisRef.Status.Moving AND stAxis[GVL.cXM].axisRef.Status.Moving) AND
			(stAxis[GVL.cXP].axisRef.Status.PositiveDirection AND stAxis[GVL.cXM].axisRef.Status.PositiveDirection) THEN
			ACT_TrackingDoublePositive();
		ELSIF (stAxis[GVL.cXP].axisRef.Status.Moving AND stAxis[GVL.cXM].axisRef.Status.Moving) AND
			(stAxis[GVL.cXP].axisRef.Status.NegativeDirection AND stAxis[GVL.cXM].axisRef.Status.NegativeDirection) THEN
			ACT_TrackingDoubleNegative();
		ELSE
			ACT_TrackingSingle();
		END_IF
		bGoNextSeq:=FALSE;
	END_FOR
END_IF
]]></ST>
    </Implementation>
    <Action Name="ACT_TrackingDoubleNegative" Id="{0039cb21-b703-43f6-867c-8fbe57c73e86}">
      <Implementation>
        <ST><![CDATA[// Take encoder samples and compare against Hall transitions when both blade sets are moving toward decreasing camera X coordinate.
// Remember, this code is being called from inside a loop over the contents of stTrack[] with k being the loop variable.
// We have to first assign a Hall event to a blade set before we can find out the motion start time and
// calculate an elapsed time from that. 

// +X blade set
IF stAxis[GVL.cXP].axisRef.Status.Moving THEN
	//Compare current sequence with recorded sequence. Update position if match. Negative direction.
	IF stAxis[GVL.cXP].axisRef.status.NegativeDirection AND stAxis[GVL.cXP].stHall[GVL.cDirNeg, stAxis[GVL.cXP].nTripCount].nSeq = stTrack[k].nSeqToCompare AND
			stAxis[GVL.cXP].stHall[GVL.cDirNeg, stAxis[GVL.cXP].nTripCount].bEdge = stTrack[k].bEdgeToCompare AND (NOT bGoNextSeq) THEN
		stAxis[GVL.cXP].fHallPosAct := stAxis[GVL.cXP].fHallPosCal[GVL.cDirNeg, stAxis[GVL.cXP].nTripCount];
		stAxis[GVL.cXP].nTripCount := stAxis[GVL.cXP].nTripCount - 1;		
		//track difference between hall sensor and encoder data at trip point
		stAxis[GVL.cXP].fPosDiffAtTrip := stAxis[GVL.cXP].axisRef.NcToPlc.ActPos - stAxis[GVL.cXP].fHallPosAct;
		stAxis[GVL.cXP].bTrackedFlag:=TRUE;
		bGoNextSeq:=TRUE;
		
		IF bInMotion AND MAIN.outShutterStatus.smState<>E_StatesMaint.Calibrating THEN
			// The Hall event belongs to the +X blade set.
			// We need to determine the time elapsed since the blade set started moving then add that
			// to the PTP timestamp saved at the start of motion. There are two complications we have
			// to deal with. The first is that the ADC start time has to be the one taken from the ADC
			// to which the Hall sensor is attached. The second is that the event times from the ADCs 
			// capture only the low order 32 bits of the ADC clock, so event times could roll over
			// during motion. If the motion lasts less than 2^32 nanoseconds, about 4.29 seconds, then there can have been
			// at most one rollover, for which we can correct.
			nAxisID:= GVL.cXP;
			IF stTrack[k].nHallID < GVL.cHallOnAdc1 THEN
				adcBase := adc0StartDcTime[nAxisID];
			ELSE
				adcBase := adc1StartDcTime[nAxisID];
			END_IF
			adcBase := adcBase AND 16#00_00_00_00_FF_FF_FF_FF;  // Make this a 32-bit time.
			adcEvent := stTrack[k].tScanTime;    // This was always 32-bit.
			IF adcEvent <= adcBase THEN
				// Correct for rollover.
				adcEvent := adcEvent + 16#00_00_00_01_00_00_00_00;
			END_IF
			adcExtTime := ptpStartExtTime[nAxisID] + (adcEvent - adcBase);
			stMotionDone[GVL.cXP].trans[stMotionDone[GVL.cXP].ntrans].extTime := adcExtTime;
			stMotionDone[GVL.cXP].trans[stMotionDone[GVL.cXP].ntrans].id := stTrack[k].nHallID;
			stMotionDone[GVL.cXP].trans[stMotionDone[GVL.cXP].ntrans].on := stTrack[k].bEdgeToCompare;
			stMotionDone[GVL.cXP].trans[stMotionDone[GVL.cXP].ntrans].pos := stAxis[GVL.cXP].fHallPosAct;
			stMotionDone[GVL.cXP].ntrans := stMotionDone[GVL.cXP].ntrans +1;
			
			// Calculate the sample external time by again calculating the elapsed time and adding
			// it to the absolute starting time.
			encExtTime := ptpStartExtTime[nAxisId] + (F_GetCurDcTaskTime64() - plcStartDcTime[nAxisID]);
			stMotionDone[GVL.cXP].samples[stMotionDone[GVL.cXP].nsamples].extTime := encExtTime;
			stMotionDone[GVL.cXP].samples[stMotionDone[GVL.cXP].nsamples].pos := stAxis[GVL.cXP].axisRef.NcToPlc.ActPos;
			stMotionDone[GVL.cXP].nsamples := stMotionDone[GVL.cXP].nsamples + 1;
		END_IF
		
	END_IF
END_IF

// -X blade set
IF stAxis[GVL.cXM].axisRef.Status.Moving THEN
	//Compare current sequence with recorded sequence. Update position if match. Negative direction.
	IF stAxis[GVL.cXM].axisRef.status.NegativeDirection AND stAxis[GVL.cXM].stHall[GVL.cDirNeg, stAxis[GVL.cXM].nTripCount].nSeq = stTrack[k].nSeqToCompare AND
			stAxis[GVL.cXM].stHall[GVL.cDirNeg, stAxis[GVL.cXM].nTripCount].bEdge = stTrack[k].bEdgeToCompare AND (NOT bGoNextSeq) THEN
		stAxis[GVL.cXM].fHallPosAct := stAxis[GVL.cXM].fHallPosCal[GVL.cDirNeg, stAxis[GVL.cXM].nTripCount];
		stAxis[GVL.cXM].nTripCount := stAxis[GVL.cXM].nTripCount + 1;	
		//track difference between hall sensor and encoder data at trip point
		stAxis[GVL.cXM].fPosDiffAtTrip := stAxis[GVL.cXM].axisRef.NcToPlc.ActPos - stAxis[GVL.cXM].fHallPosAct;
		stAxis[GVL.cXM].bTrackedFlag:=TRUE;
		bGoNextSeq:=TRUE;
		
		IF bInMotion AND MAIN.outShutterStatus.smState<>E_StatesMaint.Calibrating THEN
			nAxisID:= GVL.cXM;
			stMotionDone[GVL.cXM].trans[stMotionDone[GVL.cXM].ntrans].extTime := stTrack[k].tScanTime;
			stMotionDone[GVL.cXM].trans[stMotionDone[GVL.cXM].ntrans].id := stTrack[k].nHallID;
			stMotionDone[GVL.cXM].trans[stMotionDone[GVL.cXM].ntrans].on := stTrack[k].bEdgeToCompare;
			stMotionDone[GVL.cXM].trans[stMotionDone[GVL.cXM].ntrans].pos := stAxis[GVL.cXM].fHallPosAct;
			stMotionDone[GVL.cXM].ntrans := stMotionDone[GVL.cXM].ntrans +1;
			
			stMotionDone[GVL.cXM].samples[stMotionDone[GVL.cXM].nsamples].extTime := F_TaskStartDcTimeToExt();
			stMotionDone[GVL.cXM].samples[stMotionDone[GVL.cXM].nsamples].pos := stAxis[GVL.cXM].axisRef.NcToPlc.ActPos;
			stMotionDone[GVL.cXM].nsamples := stMotionDone[GVL.cXM].nsamples + 1;
		END_IF
		
	END_IF
END_IF]]></ST>
      </Implementation>
    </Action>
    <Action Name="ACT_TrackingDoublePositive" Id="{015fe346-39d0-42ba-a488-79403589a261}">
      <Implementation>
        <ST><![CDATA[// Take encoder samples and compare against Hall transitions when both blade sets are moving toward increasing camera X coordinate.

// -X blade set
IF stAxis[GVL.cXM].axisRef.Status.Moving THEN
	//Compare current sequence with recorded sequence. Update position if match. Positive direction.
	IF stAxis[GVL.cXM].axisRef.status.PositiveDirection AND stAxis[GVL.cXM].stHall[GVL.cDirPos, stAxis[GVL.cXM].nTripCount].nSeq = stTrack[k].nSeqToCompare AND
			stAxis[GVL.cXM].stHall[GVL.cDirPos, stAxis[GVL.cXM].nTripCount].bEdge = stTrack[k].bEdgeToCompare AND (NOT bGoNextSeq) THEN
		stAxis[GVL.cXM].fHallPosAct := stAxis[GVL.cXM].fHallPosCal[GVL.cDirPos, stAxis[GVL.cXM].nTripCount];
		stAxis[GVL.cXM].nTripCount := stAxis[GVL.cXM].nTripCount - 1;	
		//track difference between hall sensor and encoder data at trip point
		stAxis[GVL.cXM].fPosDiffAtTrip := stAxis[GVL.cXM].axisRef.NcToPlc.ActPos - stAxis[GVL.cXM].fHallPosAct;
		stAxis[GVL.cXM].bTrackedFlag:=TRUE;
		bGoNextSeq:=TRUE;
		
		IF bInMotion AND MAIN.outShutterStatus.smState<>E_StatesMaint.Calibrating THEN
			nAxisID:= GVL.cXM;
			stMotionDone[GVL.cXM].trans[stMotionDone[GVL.cXM].ntrans].extTime := stTrack[k].tScanTime;
			stMotionDone[GVL.cXM].trans[stMotionDone[GVL.cXM].ntrans].id := stTrack[k].nHallID;
			stMotionDone[GVL.cXM].trans[stMotionDone[GVL.cXM].ntrans].on := stTrack[k].bEdgeToCompare;
			stMotionDone[GVL.cXM].trans[stMotionDone[GVL.cXM].ntrans].pos := stAxis[GVL.cXM].fHallPosAct;
			stMotionDone[GVL.cXM].ntrans := stMotionDone[GVL.cXM].ntrans +1;
			
			stMotionDone[GVL.cXM].samples[stMotionDone[GVL.cXM].nsamples].extTime := F_TaskStartDcTimeToExt();
			stMotionDone[GVL.cXM].samples[stMotionDone[GVL.cXM].nsamples].pos := stAxis[GVL.cXM].axisRef.NcToPlc.ActPos;
			stMotionDone[GVL.cXM].nsamples := stMotionDone[GVL.cXM].nsamples + 1;
		END_IF
		
	END_IF
END_IF

// +X blade set
IF stAxis[GVL.cXP].axisRef.Status.Moving THEN
	//Compare current sequence with recorded sequence. Update position if match. Positive direction.
	IF stAxis[GVL.cXP].axisRef.status.PositiveDirection AND stAxis[GVL.cXP].stHall[GVL.cDirPos, stAxis[GVL.cXP].nTripCount].nSeq = stTrack[k].nSeqToCompare AND 
			stAxis[GVL.cXP].stHall[GVL.cDirPos, stAxis[GVL.cXP].nTripCount].bEdge = stTrack[k].bEdgeToCompare AND (NOT bGoNextSeq) THEN
		stAxis[GVL.cXP].fHallPosAct := stAxis[GVL.cXP].fHallPosCal[GVL.cDirPos, stAxis[GVL.cXP].nTripCount];
		stAxis[GVL.cXP].nTripCount := stAxis[GVL.cXP].nTripCount + 1;
		//track difference between hall sensor and encoder data at trip point
		stAxis[GVL.cXP].fPosDiffAtTrip := stAxis[GVL.cXP].axisRef.NcToPlc.ActPos - stAxis[GVL.cXP].fHallPosAct;
		stAxis[GVL.cXP].bTrackedFlag:=TRUE;
		bGoNextSeq:=TRUE;
		
		IF bInMotion AND MAIN.outShutterStatus.smState<>E_StatesMaint.Calibrating THEN
			nAxisID:= GVL.cXP;
			stMotionDone[GVL.cXP].trans[stMotionDone[GVL.cXP].ntrans].extTime := stTrack[k].tScanTime;
			stMotionDone[GVL.cXP].trans[stMotionDone[GVL.cXP].ntrans].id := stTrack[k].nHallID;
			stMotionDone[GVL.cXP].trans[stMotionDone[GVL.cXP].ntrans].on := stTrack[k].bEdgeToCompare;
			stMotionDone[GVL.cXP].trans[stMotionDone[GVL.cXP].ntrans].pos := stAxis[GVL.cXP].fHallPosAct;
			stMotionDone[GVL.cXP].ntrans := stMotionDone[GVL.cXP].ntrans +1;
			
			stMotionDone[GVL.cXP].samples[stMotionDone[GVL.cXP].nsamples].extTime := F_TaskStartDcTimeToExt();
			stMotionDone[GVL.cXP].samples[stMotionDone[GVL.cXP].nsamples].pos := stAxis[GVL.cXP].axisRef.NcToPlc.ActPos;
			stMotionDone[GVL.cXP].nsamples := stMotionDone[GVL.cXP].nsamples + 1;
		END_IF
		
	END_IF
END_IF
]]></ST>
      </Implementation>
    </Action>
    <Action Name="ACT_TrackingSingle" Id="{68bb727f-4301-4350-9f19-54a85b8d6b0c}">
      <Implementation>
        <ST><![CDATA[// Take encoder samples and compare against Hall transitions when only one blade set is moving.

// +X blade set
IF stAxis[GVL.cXP].axisRef.Status.Moving THEN
	//Compare current sequence with recorded sequence. Update position if match. Positive direction.
	IF stAxis[GVL.cXP].axisRef.status.PositiveDirection AND stAxis[GVL.cXP].stHall[GVL.cDirPos, stAxis[GVL.cXP].nTripCount].nSeq = stTrack[k].nSeqToCompare AND 
			stAxis[GVL.cXP].stHall[GVL.cDirPos, stAxis[GVL.cXP].nTripCount].bEdge = stTrack[k].bEdgeToCompare AND (NOT bGoNextSeq) THEN
		stAxis[GVL.cXP].fHallPosAct := stAxis[GVL.cXP].fHallPosCal[GVL.cDirPos, stAxis[GVL.cXP].nTripCount];
		stAxis[GVL.cXP].nTripCount := stAxis[GVL.cXP].nTripCount + 1;
		//track difference between hall sensor and encoder data at trip point
		stAxis[GVL.cXP].fPosDiffAtTrip := stAxis[GVL.cXP].axisRef.NcToPlc.ActPos - stAxis[GVL.cXP].fHallPosAct;
		stAxis[GVL.cXP].bTrackedFlag:=TRUE;
		bGoNextSeq:=TRUE;
		
		IF bInMotion AND MAIN.outShutterStatus.smState<>E_StatesMaint.Calibrating THEN
			nAxisID:= GVL.cXP;
			stMotionDone[GVL.cXP].trans[stMotionDone[GVL.cXP].ntrans].extTime := stTrack[k].tScanTime;
			stMotionDone[GVL.cXP].trans[stMotionDone[GVL.cXP].ntrans].id := stTrack[k].nHallID;
			stMotionDone[GVL.cXP].trans[stMotionDone[GVL.cXP].ntrans].on := stTrack[k].bEdgeToCompare;
			stMotionDone[GVL.cXP].trans[stMotionDone[GVL.cXP].ntrans].pos := stAxis[GVL.cXP].fHallPosAct;
			stMotionDone[GVL.cXP].ntrans := stMotionDone[GVL.cXP].ntrans +1;
			
			stMotionDone[GVL.cXP].samples[stMotionDone[GVL.cXP].nsamples].extTime := F_TaskStartDcTimeToExt();
			stMotionDone[GVL.cXP].samples[stMotionDone[GVL.cXP].nsamples].pos := stAxis[GVL.cXP].axisRef.NcToPlc.ActPos;
			stMotionDone[GVL.cXP].nsamples := stMotionDone[GVL.cXP].nsamples + 1;
		END_IF
		
	END_IF
	//Compare current sequence with recorded sequence. Update position if match. Negative direction.
	IF stAxis[GVL.cXP].axisRef.status.NegativeDirection AND stAxis[GVL.cXP].stHall[GVL.cDirNeg, stAxis[GVL.cXP].nTripCount].nSeq = stTrack[k].nSeqToCompare AND
			stAxis[GVL.cXP].stHall[GVL.cDirNeg, stAxis[GVL.cXP].nTripCount].bEdge = stTrack[k].bEdgeToCompare AND (NOT bGoNextSeq) THEN
		stAxis[GVL.cXP].fHallPosAct := stAxis[GVL.cXP].fHallPosCal[GVL.cDirNeg, stAxis[GVL.cXP].nTripCount];
		stAxis[GVL.cXP].nTripCount := stAxis[GVL.cXP].nTripCount - 1;		
		//track difference between hall sensor and encoder data at trip point
		stAxis[GVL.cXP].fPosDiffAtTrip := stAxis[GVL.cXP].axisRef.NcToPlc.ActPos - stAxis[GVL.cXP].fHallPosAct;
		stAxis[GVL.cXP].bTrackedFlag:=TRUE;
		bGoNextSeq:=TRUE;
		
		IF bInMotion AND MAIN.outShutterStatus.smState<>E_StatesMaint.Calibrating THEN
			nAxisID:= GVL.cXP;
			stMotionDone[GVL.cXP].trans[stMotionDone[GVL.cXP].ntrans].extTime := stTrack[k].tScanTime;
			stMotionDone[GVL.cXP].trans[stMotionDone[GVL.cXP].ntrans].id := stTrack[k].nHallID;
			stMotionDone[GVL.cXP].trans[stMotionDone[GVL.cXP].ntrans].on := stTrack[k].bEdgeToCompare;
			stMotionDone[GVL.cXP].trans[stMotionDone[GVL.cXP].ntrans].pos := stAxis[GVL.cXP].fHallPosAct;
			stMotionDone[GVL.cXP].ntrans := stMotionDone[GVL.cXP].ntrans +1;
			
			stMotionDone[GVL.cXP].samples[stMotionDone[GVL.cXP].nsamples].extTime := F_TaskStartDcTimeToExt();
			stMotionDone[GVL.cXP].samples[stMotionDone[GVL.cXP].nsamples].pos := stAxis[GVL.cXP].axisRef.NcToPlc.ActPos;
			stMotionDone[GVL.cXP].nsamples := stMotionDone[GVL.cXP].nsamples + 1;
		END_IF
		
	END_IF
END_IF

// -X blade set
IF stAxis[GVL.cXM].axisRef.Status.Moving THEN
	//Compare current sequence with recorded sequence. Update position if match. Positive direction.
	IF stAxis[GVL.cXM].axisRef.status.PositiveDirection AND stAxis[GVL.cXM].stHall[GVL.cDirPos, stAxis[GVL.cXM].nTripCount].nSeq = stTrack[k].nSeqToCompare AND
			stAxis[GVL.cXM].stHall[GVL.cDirPos, stAxis[GVL.cXM].nTripCount].bEdge = stTrack[k].bEdgeToCompare AND (NOT bGoNextSeq) THEN
		stAxis[GVL.cXM].fHallPosAct := stAxis[GVL.cXM].fHallPosCal[GVL.cDirPos, stAxis[GVL.cXM].nTripCount];
		stAxis[GVL.cXM].nTripCount := stAxis[GVL.cXM].nTripCount - 1;	
		//track difference between hall sensor and encoder data at trip point
		stAxis[GVL.cXM].fPosDiffAtTrip := stAxis[GVL.cXM].axisRef.NcToPlc.ActPos - stAxis[GVL.cXM].fHallPosAct;
		stAxis[GVL.cXM].bTrackedFlag:=TRUE;
		bGoNextSeq:=TRUE;
		
		IF bInMotion AND MAIN.outShutterStatus.smState<>E_StatesMaint.Calibrating THEN
			nAxisID:= GVL.cXM;
			stMotionDone[GVL.cXM].trans[stMotionDone[GVL.cXM].ntrans].extTime := stTrack[k].tScanTime;
			stMotionDone[GVL.cXM].trans[stMotionDone[GVL.cXM].ntrans].id := stTrack[k].nHallID;
			stMotionDone[GVL.cXM].trans[stMotionDone[GVL.cXM].ntrans].on := stTrack[k].bEdgeToCompare;
			stMotionDone[GVL.cXM].trans[stMotionDone[GVL.cXM].ntrans].pos := stAxis[GVL.cXM].fHallPosAct;
			stMotionDone[GVL.cXM].ntrans := stMotionDone[GVL.cXM].ntrans +1;
			
			stMotionDone[GVL.cXM].samples[stMotionDone[GVL.cXM].nsamples].extTime := F_TaskStartDcTimeToExt();
			stMotionDone[GVL.cXM].samples[stMotionDone[GVL.cXM].nsamples].pos := stAxis[GVL.cXM].axisRef.NcToPlc.ActPos;
			stMotionDone[GVL.cXM].nsamples := stMotionDone[GVL.cXM].nsamples + 1;
		END_IF
		
	END_IF
	//Compare current sequence with recorded sequence. Update position if match. Negative direction.
	IF stAxis[GVL.cXM].axisRef.status.NegativeDirection AND stAxis[GVL.cXM].stHall[GVL.cDirNeg, stAxis[GVL.cXM].nTripCount].nSeq = stTrack[k].nSeqToCompare AND
			stAxis[GVL.cXM].stHall[GVL.cDirNeg, stAxis[GVL.cXM].nTripCount].bEdge = stTrack[k].bEdgeToCompare AND (NOT bGoNextSeq) THEN
		stAxis[GVL.cXM].fHallPosAct := stAxis[GVL.cXM].fHallPosCal[GVL.cDirNeg, stAxis[GVL.cXM].nTripCount];
		stAxis[GVL.cXM].nTripCount := stAxis[GVL.cXM].nTripCount + 1;	
		//track difference between hall sensor and encoder data at trip point
		stAxis[GVL.cXM].fPosDiffAtTrip := stAxis[GVL.cXM].axisRef.NcToPlc.ActPos - stAxis[GVL.cXM].fHallPosAct;
		stAxis[GVL.cXM].bTrackedFlag:=TRUE;
		bGoNextSeq:=TRUE;
		
		IF bInMotion AND MAIN.outShutterStatus.smState<>E_StatesMaint.Calibrating THEN
			nAxisID:= GVL.cXM;
			stMotionDone[GVL.cXM].trans[stMotionDone[GVL.cXM].ntrans].extTime := stTrack[k].tScanTime;
			stMotionDone[GVL.cXM].trans[stMotionDone[GVL.cXM].ntrans].id := stTrack[k].nHallID;
			stMotionDone[GVL.cXM].trans[stMotionDone[GVL.cXM].ntrans].on := stTrack[k].bEdgeToCompare;
			stMotionDone[GVL.cXM].trans[stMotionDone[GVL.cXM].ntrans].pos := stAxis[GVL.cXM].fHallPosAct;
			stMotionDone[GVL.cXM].ntrans := stMotionDone[GVL.cXM].ntrans +1;
			
			stMotionDone[GVL.cXM].samples[stMotionDone[GVL.cXM].nsamples].extTime := F_TaskStartDcTimeToExt();
			stMotionDone[GVL.cXM].samples[stMotionDone[GVL.cXM].nsamples].pos := stAxis[GVL.cXM].axisRef.NcToPlc.ActPos;
			stMotionDone[GVL.cXM].nsamples := stMotionDone[GVL.cXM].nsamples + 1;
		END_IF
		
	END_IF
END_IF]]></ST>
      </Implementation>
    </Action>
    <LineIds Name="FB_Tracking">
      <LineId Id="3" Count="2" />
      <LineId Id="9" Count="13" />
      <LineId Id="588" Count="0" />
      <LineId Id="590" Count="3" />
      <LineId Id="589" Count="0" />
      <LineId Id="23" Count="11" />
      <LineId Id="594" Count="5" />
      <LineId Id="35" Count="63" />
      <LineId Id="269" Count="2" />
      <LineId Id="99" Count="17" />
      <LineId Id="603" Count="0" />
      <LineId Id="600" Count="0" />
      <LineId Id="602" Count="0" />
      <LineId Id="118" Count="7" />
      <LineId Id="130" Count="1" />
      <LineId Id="145" Count="65" />
      <LineId Id="2" Count="0" />
    </LineIds>
    <LineIds Name="FB_Tracking.ACT_TrackingDoubleNegative">
      <LineId Id="2" Count="1" />
      <LineId Id="58" Count="2" />
      <LineId Id="4" Count="12" />
      <LineId Id="61" Count="7" />
      <LineId Id="17" Count="0" />
      <LineId Id="69" Count="1" />
      <LineId Id="72" Count="1" />
      <LineId Id="71" Count="0" />
      <LineId Id="83" Count="0" />
      <LineId Id="75" Count="1" />
      <LineId Id="84" Count="0" />
      <LineId Id="77" Count="2" />
      <LineId Id="18" Count="5" />
      <LineId Id="80" Count="2" />
      <LineId Id="24" Count="33" />
      <LineId Id="1" Count="0" />
    </LineIds>
    <LineIds Name="FB_Tracking.ACT_TrackingDoublePositive">
      <LineId Id="2" Count="56" />
      <LineId Id="1" Count="0" />
    </LineIds>
    <LineIds Name="FB_Tracking.ACT_TrackingSingle">
      <LineId Id="2" Count="103" />
      <LineId Id="1" Count="0" />
    </LineIds>
  </POU>
</TcPlcObject>
<?xml version="1.0" encoding="utf-8"?>
<TcPlcObject Version="1.1.0.1" ProductVersion="3.1.4022.18">
  <POU Name="FB_Tracking" Id="{462a5933-fe60-42d4-a574-27170521c4c5}" SpecialFunc="None">
    <Declaration><![CDATA[FUNCTION_BLOCK FB_Tracking
VAR_IN_OUT
	stAxis  : ARRAY [GVL.cXP .. GVL.cXM] OF ST_AxisGroup;	
END_VAR
VAR_INPUT
	eCommand 			: E_Commands;
	bMotionDone			: BOOL;
	inReset				: ST_Reset;
	inMoveAxisAbsolute	: ST_MoveAxisAbsolute;
	inMoveAxisRelative	: ST_MoveAxisRelative;
END_VAR
VAR_OUTPUT
	stOutMotionDone : ST_MotionDone;
END_VAR
VAR
	//used in tracking Action
	stTrack			: ARRAY [0 .. 4] OF ST_TRACK;
	stTrackTemp		: ST_TRACK;
	bGoNextSeq		: BOOL;
	nAxisID			: INT;
	nMask			: ULINT := 16#FFFF_FFFF_0000_0000;
	
	//used in determining target duration
	fSpeed			: LREAL;
	tTargetDur		: LTIME;
	fDistance		: LREAL;
	
	fbMoving_Rtrig : ARRAY[0 .. 1] OF R_TRIG;
	fbRtrig		: ARRAY[GVL.cHallLower..GVL.cHallUpper] OF R_Trig;
	bInMotion	: BOOL;
	stMotionDone : ARRAY [0..1] OF ST_MotionDone;	
	nSequence	: DINT;
	nLastMoved	: INT;
	
	//counter
	i, j, k, m		: INT := 0;
	nTPC	: INT; //Trip Per Cycle
	
	(*
	//TestVar
	testRtrig : R_TRIG;
	testRtrig2 : R_TRIG;
	testInt: INT;
	testInt3: INT;
	testInt4: INT;
	testLREAL : LREAL;
	testTemp : ARRAY[0 .. 4] OF ST_Track;
	testTime : ARRAY[0 .. 4] OF T_DCTIME64;
	teststTrack : ARRAY[0 .. 4] OF T_DCTIME64;
	testDCTime	: ARRAY[0 .. 4] OF T_DCTIME64;
	nMask2	 : ULINT := 16#0000_0000_FFFF_FFFF;
	a, b : INT;
	*)
	
	// Record these times at the start of a new motion.
	motionStartTime: ARRAY [GVL.cXP .. GVL.cXM] OF ST_StartTimes;
	
	(* Do we need to make another pass of sorting of Hall timestamps. *)
	newPass: BOOL:= TRUE;
	
	// Temporary variables used in the calculation of absolute (ext) timestamps
	// for Hall events and encoder samples.
	adcBase: T_DCTIME64;     // The 32-bit motion start time for the right axis and ADC module.
	adcEvent: T_DCTIME64;    // The elapsed time since adcBase for the Hall event.
	adcExtTime: T_DCTIME64;  // The final absolute timestamp for the Hall event.
	encExtTime: T_DCTIME64;
END_VAR


]]></Declaration>
    <Implementation>
      <ST><![CDATA[//////////////////////////////////////////////////////////////
// Call this function block to process any updated information about blade set motion and send updates to CCS if required.
//////////////////////////////////////////////////////////////

stAxis[GVL.cXP].bTrackedFlag:=FALSE;
stAxis[GVL.cXM].bTrackedFlag:=FALSE;
nTPC:=0;

(* variable for debugging
testInt3:=0;
testInt4:=0;
*)

// Detect start of motion for the +X blade set, rising edge of its Moving flag from the motor controller.
// Reset motion profile parameters in a local motion-done message not monitored by CCS.
fbMoving_Rtrig[GVL.cXP](CLK:=stAxis[GVL.cXP].axisRef.Status.Moving);
IF fbMoving_Rtrig[GVL.cXP].Q THEN
	// Record clock values for the various players: PLC, ADCs, PTP module.
	motionStartTime[GVL.cXP].ptpTime := GVL.ptpExtTime;
	motionStartTime[GVL.cXP].plcDcTime := F_GetCurDcTaskTime64();
	motionStartTime[GVL.cXP].adcDcTime := GVL.curAdcDcTime;
	// Prepare to record motion profile information.
	bInMotion:=TRUE;  // We're moving!
	stMotionDone[GVL.cXP].axisNum := GVL.cXP; // Axis is +X.
	stMotionDone[GVL.cXP].nsamples := 0;      // No encoder samples yet.
	stMotionDone[GVL.cXP].ntrans := 0;        // No Hall transitions yet.
	stMotionDone[gvl.cXP].startPos := stAxis[GVL.cXP].axisRef.NcToPlc.ActPos;   // Where are we now?
	stMotionDone[GVL.cXP].startTime := motionStartTime[GVL.cXP].ptpTime;
	stMotionDone[GVL.cXP].targetDur := LTIME#0D0H0M0S0MS0US0NS;  // Don't know yet how long this motion will take.
END_IF

// The same, but for the -X blade set.
fbMoving_Rtrig[GVL.cXM](CLK:=stAxis[GVL.cXM].axisRef.Status.Moving);
IF fbMoving_Rtrig[GVL.cXM].Q THEN
	// Record clock values for the various players: PLC, ADCs, PTP module.
	motionStartTime[GVL.cXM].ptpTime := GVL.ptpExtTime;
	motionStartTime[GVL.cXM].plcDcTime := F_GetCurDcTaskTime64();
	motionStartTime[GVL.cXM].adcDcTime := GVL.curAdcDcTime;
	// Prepare to record motion profile information.
	bInMotion:=TRUE;
	stMotionDone[gvl.cXM].axisNum := GVL.cXM;
	stMotionDone[gvl.cXM].nsamples := 0;
	stMotionDone[gvl.cXM].ntrans := 0;
	stMotionDone[gvl.cXM].startPos := stAxis[GVL.cXM].axisRef.NcToPlc.ActPos;
	stMotionDone[gvl.cXM].startTime := motionStartTime[GVL.cXM].ptpTime;
	stMotionDone[gvl.cXM].targetDur := LTIME#0D0H0M0S0MS0US0NS;
END_IF

// Assuming that a motion command was issued by CCS, calculate how long the motion is supposed to last.
// Output is tTargetDur.
IF eCommand = E_Commands.takeExposure THEN
	fSpeed	:= inReset.speed;   // Speed from reset command (actually now set elsewhere in this PLC code).
	IF (fSpeed>0) THEN
		IF (fSpeed>1668.355556) THEN
			fSpeed:=1668.355556;
		END_IF
		tTargetDur 	:= LREAL_TO_LTIME((2*GVL.cPosEnd)/(fSpeed)*EXPT(10,9));
	END_IF
ELSIF eCommand = E_Commands.moveAxisAbsolute THEN
	// MoveAxisAbsolute message contains target position and speed of motion.
	fDistance := ABS(stAxis[inMoveAxisAbsolute.axisIndex].axisRef.NcToPlc.ActPos - inMoveAxisAbsolute.position);
	fSpeed	:= inMoveAxisAbsolute.speed;
	IF (fSpeed>0) THEN
		IF (fSpeed>1668.355556) THEN
			fSpeed:=1668.355556;
		END_IF
		tTargetDur 	:= LREAL_TO_LTIME(((2*fDistance)/(fSpeed))*EXPT(10,9));
	END_IF
ELSIF eCommand = E_Commands.moveAxisRelative THEN
	// MoveAxisRelative message contains position change and how long to take to do it.
	tTargetDur	:= TIME_TO_LTIME(inMoveAxisRelative.moveTime);
END_IF

//Checks to see which blade set last started moving.
IF (stAxis[GVL.cXM].axisRef.Status.Moving AND stAxis[GVL.cXP].axisRef.Status.InTargetPosition) THEN
	nLastMoved:=GVL.cXM;
ELSIF (stAxis[GVL.cXP].axisRef.Status.Moving AND stAxis[GVL.cXM].axisRef.Status.InTargetPosition) THEN
	nLastMoved:=GVL.cXP;
END_IF

////////// Handle the completion of a blade set motion. //////////
IF bMotionDone THEN
	//use for determining which blade set has finished during a travelling slit motion
	IF (stAxis[GVL.cXM].axisRef.Status.Moving AND stAxis[GVL.cXP].axisRef.Status.InTargetPosition) THEN
		nAxisID:=GVL.cXP;
	ELSIF (stAxis[GVL.cXP].axisRef.Status.Moving AND stAxis[GVL.cXM].axisRef.Status.InTargetPosition) THEN
		nAxisID:=GVL.cXM;
	ELSE 
		nAxisID:=nLastMoved;
	END_IF
	//bInMotion flag remains true if either of the blade sets is still in motion
	IF ((NOT stAxis[GVL.cXP].axisRef.Status.Moving) AND (NOT stAxis[GVL.cXM].axisRef.Status.Moving)) THEN
		bInMotion := FALSE;
	END_IF
	// Complete our local motion-done message.
	nSequence := nSequence+1;
	// The motor controller doesn't report exactly when motion was completed, so we assume that it was when the process data
	// from the controller reached us, i.e., at the start of the current cycle.
	stMotionDone[nAxisID].actualDur := ULINT_TO_LTIME(F_TaskStartDcTimeToExt() - stMotionDone[nAxisID].startTime);
	stMotionDone[nAxisID].targetDur := tTargetDur;
	stMotionDone[nAxisID].targetPos := stAxis[nAxisID].axisRef.NcToPlc.TargetPos;
	stMotionDone[nAxisID].endPos := stAxis[nAxisID].axisRef.NcToPlc.ActPos;
	stMotionDone[nAxisId].ptpState := MAIN.ptpDiagInfo.PTPState;
	stMotionDone[nAxisId].leapSeconds := MAIN.ptpDiagInfo.CurrentUtcOffset;
	stMotionDone[nAxisId].leapIsValid := TO_BOOL(MAIN.ptpDiagInfo.CurrentUtcOffsetIsValid);
	// Copy our local motion-done message to the location that's monitored by CCS.
	stOutMotionDone:=stMotionDone[nAxisID];
	stOutMotionDone.sequence:=nSequence;  // Ensure message gets sent to CCS by making sure that at least one field has a changed value.
END_IF


////////// Collect information on any Hall switch transitions from the time-stamping ADCs. //////////
// nNumOfINputs[i] is linked to the event count for the ADC channel assigned to Hall sensor i.
// bInputEventState[i] is linked to the current ADC channel state for Hall sensor i.
// nInputEventTime[i] is linked to the first transition timestamp for Hall sensor i. We assume there is at most one per cycle.
// New timestamps are added to the end of the stTrack array.

// N. B.: Both blade sets may be moving so we can't assign the Hall events to one or the other just yet. Neither can
// we calculate time since motion start since we don't know which start time to use.
FOR i:=GVL.cHallLower TO GVL.cHallUpper BY 1 DO
	fbRtrig[i](CLK:=GVL.nNumOfInputs[i].0);  // Look for a rising edge in channel status, which means we have a transition timestamp.
	IF fbRtrig[i].Q THEN
		// Identifies which Hall switch tripped
		stTrack[nTPC].nSeqToCompare := INT_TO_WORD((i*10)+5);
		stTrack[nTPC].bEdgeToCompare := GVL.bInputEventState[i];
		stTrack[nTPC].nHallID := i;
		stTrack[nTPC].tScanTime := GVL.nInputEventTime[stTrack[nTPC].nHallID];
		// Count the number of entries stored in stTrack.
		nTPC:=nTPC+1;
	END_IF
END_FOR

// If we picked up some Hall transitions this cycle, then we need to take position samples (encoder readout).
// We want to check if the position of a blade set at the time of a Hall transition agrees with the
// Hall switch position taken from the last calibration.
IF nTPC>0 THEN
	FOR k:=0 TO nTPC-1 BY 1 DO
		IF (stAxis[GVL.cXP].axisRef.Status.Moving AND stAxis[GVL.cXM].axisRef.Status.Moving) AND
			(stAxis[GVL.cXP].axisRef.Status.PositiveDirection AND stAxis[GVL.cXM].axisRef.Status.PositiveDirection) THEN
			ACT_TrackingDoublePositive();
		ELSIF (stAxis[GVL.cXP].axisRef.Status.Moving AND stAxis[GVL.cXM].axisRef.Status.Moving) AND
			(stAxis[GVL.cXP].axisRef.Status.NegativeDirection AND stAxis[GVL.cXM].axisRef.Status.NegativeDirection) THEN
			ACT_TrackingDoubleNegative();
		ELSE
			ACT_TrackingSingle();
		END_IF
		bGoNextSeq:=FALSE;
	END_FOR
END_IF
]]></ST>
    </Implementation>
    <Action Name="ACT_TrackingDoubleNegative" Id="{0039cb21-b703-43f6-867c-8fbe57c73e86}">
      <Implementation>
        <ST><![CDATA[// Take encoder samples and compare against Hall transitions when both blade sets are moving toward decreasing camera X coordinate.
// Remember, this code is being called from inside a loop over the contents of stTrack[] with k being the loop variable.
// We have to first assign a Hall event to a blade set before we can find out the motion start times and
// calculate elapsed times from that. 

// +X blade set
IF stAxis[GVL.cXP].axisRef.Status.Moving THEN
	//Compare current sequence with recorded sequence. Update position if match. Negative direction.
	IF stAxis[GVL.cXP].axisRef.status.NegativeDirection AND stAxis[GVL.cXP].stHall[GVL.cDirNeg, stAxis[GVL.cXP].nTripCount].nSeq = stTrack[k].nSeqToCompare AND
			stAxis[GVL.cXP].stHall[GVL.cDirNeg, stAxis[GVL.cXP].nTripCount].bEdge = stTrack[k].bEdgeToCompare AND (NOT bGoNextSeq) THEN
		stAxis[GVL.cXP].fHallPosAct := stAxis[GVL.cXP].fHallPosCal[GVL.cDirNeg, stAxis[GVL.cXP].nTripCount];
		stAxis[GVL.cXP].nTripCount := stAxis[GVL.cXP].nTripCount - 1;		
		//track difference between hall sensor and encoder data at trip point
		stAxis[GVL.cXP].fPosDiffAtTrip := stAxis[GVL.cXP].axisRef.NcToPlc.ActPos - stAxis[GVL.cXP].fHallPosAct;
		stAxis[GVL.cXP].bTrackedFlag:=TRUE;
		bGoNextSeq:=TRUE;
		
		IF bInMotion AND MAIN.outShutterStatus.smState<>E_StatesMaint.Calibrating THEN
			nAxisID := GVL.cXP;
			// The Hall event belongs to the +X blade set.
			adcExtTime := F_AdcPtpTime(stTrack[k].nHallID, stTrack[k].tScanTime, motionStartTime[GVL.cXP]);
			stMotionDone[GVL.cXP].trans[stMotionDone[GVL.cXP].ntrans].extTime := adcExtTime;
			stMotionDone[GVL.cXP].trans[stMotionDone[GVL.cXP].ntrans].id := stTrack[k].nHallID;
			stMotionDone[GVL.cXP].trans[stMotionDone[GVL.cXP].ntrans].on := stTrack[k].bEdgeToCompare;
			stMotionDone[GVL.cXP].trans[stMotionDone[GVL.cXP].ntrans].pos := stAxis[GVL.cXP].fHallPosAct;
			stMotionDone[GVL.cXP].ntrans := stMotionDone[GVL.cXP].ntrans +1;
			// We're taking the encoder value from process data for this cycle, so the closest
			// approximation we have to the actual sample time is the DC time at the start of the cycle.
			encExtTime := F_EncPtpTime(F_GetCurDcTaskTime64(), motionStartTime[GVL.cXP]);
			stMotionDone[GVL.cXP].samples[stMotionDone[GVL.cXP].nsamples].extTime := encExtTime;
			stMotionDone[GVL.cXP].samples[stMotionDone[GVL.cXP].nsamples].pos := stAxis[GVL.cXP].axisRef.NcToPlc.ActPos;
			stMotionDone[GVL.cXP].nsamples := stMotionDone[GVL.cXP].nsamples + 1;
		END_IF
		
	END_IF
END_IF

// -X blade set
IF stAxis[GVL.cXM].axisRef.Status.Moving THEN
	//Compare current sequence with recorded sequence. Update position if match. Negative direction.
	IF stAxis[GVL.cXM].axisRef.status.NegativeDirection AND stAxis[GVL.cXM].stHall[GVL.cDirNeg, stAxis[GVL.cXM].nTripCount].nSeq = stTrack[k].nSeqToCompare AND
			stAxis[GVL.cXM].stHall[GVL.cDirNeg, stAxis[GVL.cXM].nTripCount].bEdge = stTrack[k].bEdgeToCompare AND (NOT bGoNextSeq) THEN
		stAxis[GVL.cXM].fHallPosAct := stAxis[GVL.cXM].fHallPosCal[GVL.cDirNeg, stAxis[GVL.cXM].nTripCount];
		stAxis[GVL.cXM].nTripCount := stAxis[GVL.cXM].nTripCount + 1;	
		//track difference between hall sensor and encoder data at trip point
		stAxis[GVL.cXM].fPosDiffAtTrip := stAxis[GVL.cXM].axisRef.NcToPlc.ActPos - stAxis[GVL.cXM].fHallPosAct;
		stAxis[GVL.cXM].bTrackedFlag:=TRUE;
		bGoNextSeq:=TRUE;
		
		IF bInMotion AND MAIN.outShutterStatus.smState<>E_StatesMaint.Calibrating THEN
			nAxisID:= GVL.cXM;
			// The Hall event belongs to the -X blade set.
			adcExtTime := F_AdcPtpTime(stTrack[k].nHallID, stTrack[k].tScanTime, motionStartTime[GVL.cXM]);
			stMotionDone[GVL.cXM].trans[stMotionDone[GVL.cXM].ntrans].extTime := adcExtTime;
			stMotionDone[GVL.cXM].trans[stMotionDone[GVL.cXM].ntrans].id := stTrack[k].nHallID;
			stMotionDone[GVL.cXM].trans[stMotionDone[GVL.cXM].ntrans].on := stTrack[k].bEdgeToCompare;
			stMotionDone[GVL.cXM].trans[stMotionDone[GVL.cXM].ntrans].pos := stAxis[GVL.cXM].fHallPosAct;
			stMotionDone[GVL.cXM].ntrans := stMotionDone[GVL.cXM].ntrans +1;
			
			encExtTime := F_EncPtpTime(F_GetCurDcTaskTime64(), motionStartTime[GVL.cXM]);
			stMotionDone[GVL.cXM].samples[stMotionDone[GVL.cXM].nsamples].extTime := encExtTime;
			stMotionDone[GVL.cXM].samples[stMotionDone[GVL.cXM].nsamples].pos := stAxis[GVL.cXM].axisRef.NcToPlc.ActPos;
			stMotionDone[GVL.cXM].nsamples := stMotionDone[GVL.cXM].nsamples + 1;
		END_IF
		
	END_IF
END_IF]]></ST>
      </Implementation>
    </Action>
    <Action Name="ACT_TrackingDoublePositive" Id="{015fe346-39d0-42ba-a488-79403589a261}">
      <Implementation>
        <ST><![CDATA[// Take encoder samples and compare against Hall transitions when both blade sets are moving toward increasing camera X coordinate.

// -X blade set
IF stAxis[GVL.cXM].axisRef.Status.Moving THEN
	//Compare current sequence with recorded sequence. Update position if match. Positive direction.
	IF stAxis[GVL.cXM].axisRef.status.PositiveDirection AND stAxis[GVL.cXM].stHall[GVL.cDirPos, stAxis[GVL.cXM].nTripCount].nSeq = stTrack[k].nSeqToCompare AND
			stAxis[GVL.cXM].stHall[GVL.cDirPos, stAxis[GVL.cXM].nTripCount].bEdge = stTrack[k].bEdgeToCompare AND (NOT bGoNextSeq) THEN
		stAxis[GVL.cXM].fHallPosAct := stAxis[GVL.cXM].fHallPosCal[GVL.cDirPos, stAxis[GVL.cXM].nTripCount];
		stAxis[GVL.cXM].nTripCount := stAxis[GVL.cXM].nTripCount - 1;	
		//track difference between hall sensor and encoder data at trip point
		stAxis[GVL.cXM].fPosDiffAtTrip := stAxis[GVL.cXM].axisRef.NcToPlc.ActPos - stAxis[GVL.cXM].fHallPosAct;
		stAxis[GVL.cXM].bTrackedFlag:=TRUE;
		bGoNextSeq:=TRUE;
		
		IF bInMotion AND MAIN.outShutterStatus.smState<>E_StatesMaint.Calibrating THEN
			nAxisID:= GVL.cXM;
			// The Hall event belongs to the -X blade set.
			adcExtTime := F_AdcPtpTime(stTrack[k].nHallID, stTrack[k].tScanTime, motionStartTime[GVL.cXM]);
			stMotionDone[GVL.cXM].trans[stMotionDone[GVL.cXM].ntrans].extTime := adcExtTime;
			stMotionDone[GVL.cXM].trans[stMotionDone[GVL.cXM].ntrans].id := stTrack[k].nHallID;
			stMotionDone[GVL.cXM].trans[stMotionDone[GVL.cXM].ntrans].on := stTrack[k].bEdgeToCompare;
			stMotionDone[GVL.cXM].trans[stMotionDone[GVL.cXM].ntrans].pos := stAxis[GVL.cXM].fHallPosAct;
			stMotionDone[GVL.cXM].ntrans := stMotionDone[GVL.cXM].ntrans +1;
			
			encExtTime := F_EncPtpTime(F_GetCurDcTaskTime64(), motionStartTime[GVL.cXM]);
			stMotionDone[GVL.cXM].samples[stMotionDone[GVL.cXM].nsamples].extTime := encExtTime;
			stMotionDone[GVL.cXM].samples[stMotionDone[GVL.cXM].nsamples].pos := stAxis[GVL.cXM].axisRef.NcToPlc.ActPos;
			stMotionDone[GVL.cXM].nsamples := stMotionDone[GVL.cXM].nsamples + 1;
		END_IF
		
	END_IF
END_IF

// +X blade set
IF stAxis[GVL.cXP].axisRef.Status.Moving THEN
	//Compare current sequence with recorded sequence. Update position if match. Positive direction.
	IF stAxis[GVL.cXP].axisRef.status.PositiveDirection AND stAxis[GVL.cXP].stHall[GVL.cDirPos, stAxis[GVL.cXP].nTripCount].nSeq = stTrack[k].nSeqToCompare AND 
			stAxis[GVL.cXP].stHall[GVL.cDirPos, stAxis[GVL.cXP].nTripCount].bEdge = stTrack[k].bEdgeToCompare AND (NOT bGoNextSeq) THEN
		stAxis[GVL.cXP].fHallPosAct := stAxis[GVL.cXP].fHallPosCal[GVL.cDirPos, stAxis[GVL.cXP].nTripCount];
		stAxis[GVL.cXP].nTripCount := stAxis[GVL.cXP].nTripCount + 1;
		//track difference between hall sensor and encoder data at trip point
		stAxis[GVL.cXP].fPosDiffAtTrip := stAxis[GVL.cXP].axisRef.NcToPlc.ActPos - stAxis[GVL.cXP].fHallPosAct;
		stAxis[GVL.cXP].bTrackedFlag:=TRUE;
		bGoNextSeq:=TRUE;
		
		IF bInMotion AND MAIN.outShutterStatus.smState<>E_StatesMaint.Calibrating THEN
			nAxisID:= GVL.cXP;
			// The Hall event belongs to the +X blade set.
			adcExtTime := F_AdcPtpTime(stTrack[k].nHallID, stTrack[k].tScanTime, motionStartTime[GVL.cXP]);
			stMotionDone[GVL.cXP].trans[stMotionDone[GVL.cXP].ntrans].extTime := adcExtTime;
			stMotionDone[GVL.cXP].trans[stMotionDone[GVL.cXP].ntrans].id := stTrack[k].nHallID;
			stMotionDone[GVL.cXP].trans[stMotionDone[GVL.cXP].ntrans].on := stTrack[k].bEdgeToCompare;
			stMotionDone[GVL.cXP].trans[stMotionDone[GVL.cXP].ntrans].pos := stAxis[GVL.cXP].fHallPosAct;
			stMotionDone[GVL.cXP].ntrans := stMotionDone[GVL.cXP].ntrans +1;
			
			// We're taking the encoder value from process data for this cycle, so the closest
			// approximation we have to the actual sample time is the DC time at the start of the cycle.
			encExtTime := F_EncPtpTime(F_GetCurDcTaskTime64(), motionStartTime[GVL.cXP]);
			stMotionDone[GVL.cXP].samples[stMotionDone[GVL.cXP].nsamples].extTime := encExtTime;
			stMotionDone[GVL.cXP].samples[stMotionDone[GVL.cXP].nsamples].pos := stAxis[GVL.cXP].axisRef.NcToPlc.ActPos;
			stMotionDone[GVL.cXP].nsamples := stMotionDone[GVL.cXP].nsamples + 1;
		END_IF
		
	END_IF
END_IF
]]></ST>
      </Implementation>
    </Action>
    <Action Name="ACT_TrackingSingle" Id="{68bb727f-4301-4350-9f19-54a85b8d6b0c}">
      <Implementation>
        <ST><![CDATA[// Take encoder samples and compare against Hall transitions when only one blade set is moving.

// +X blade set
IF stAxis[GVL.cXP].axisRef.Status.Moving THEN
	//Compare current sequence with recorded sequence. Update position if match. Positive direction.
	IF stAxis[GVL.cXP].axisRef.status.PositiveDirection AND stAxis[GVL.cXP].stHall[GVL.cDirPos, stAxis[GVL.cXP].nTripCount].nSeq = stTrack[k].nSeqToCompare AND 
			stAxis[GVL.cXP].stHall[GVL.cDirPos, stAxis[GVL.cXP].nTripCount].bEdge = stTrack[k].bEdgeToCompare AND (NOT bGoNextSeq) THEN
		stAxis[GVL.cXP].fHallPosAct := stAxis[GVL.cXP].fHallPosCal[GVL.cDirPos, stAxis[GVL.cXP].nTripCount];
		stAxis[GVL.cXP].nTripCount := stAxis[GVL.cXP].nTripCount + 1;
		//track difference between hall sensor and encoder data at trip point
		stAxis[GVL.cXP].fPosDiffAtTrip := stAxis[GVL.cXP].axisRef.NcToPlc.ActPos - stAxis[GVL.cXP].fHallPosAct;
		stAxis[GVL.cXP].bTrackedFlag:=TRUE;
		bGoNextSeq:=TRUE;
		
		IF bInMotion AND MAIN.outShutterStatus.smState<>E_StatesMaint.Calibrating THEN
			nAxisID:= GVL.cXP;
			// The Hall event belongs to the +X blade set.
			adcExtTime := F_AdcPtpTime(stTrack[k].nHallID, stTrack[k].tScanTime, motionStartTime[GVL.cXP]);
			stMotionDone[GVL.cXP].trans[stMotionDone[GVL.cXP].ntrans].extTime := adcExtTime;
			stMotionDone[GVL.cXP].trans[stMotionDone[GVL.cXP].ntrans].id := stTrack[k].nHallID;
			stMotionDone[GVL.cXP].trans[stMotionDone[GVL.cXP].ntrans].on := stTrack[k].bEdgeToCompare;
			stMotionDone[GVL.cXP].trans[stMotionDone[GVL.cXP].ntrans].pos := stAxis[GVL.cXP].fHallPosAct;
			stMotionDone[GVL.cXP].ntrans := stMotionDone[GVL.cXP].ntrans +1;			
			// We're taking the encoder value from process data for this cycle, so the closest
			// approximation we have to the actual sample time is the DC time at the start of the cycle.
			encExtTime := F_EncPtpTime(F_GetCurDcTaskTime64(), motionStartTime[GVL.cXP]);
			stMotionDone[GVL.cXP].samples[stMotionDone[GVL.cXP].nsamples].extTime := encExtTime;
			stMotionDone[GVL.cXP].samples[stMotionDone[GVL.cXP].nsamples].pos := stAxis[GVL.cXP].axisRef.NcToPlc.ActPos;
			stMotionDone[GVL.cXP].nsamples := stMotionDone[GVL.cXP].nsamples + 1;
		END_IF
		
	END_IF
	//Compare current sequence with recorded sequence. Update position if match. Negative direction.
	IF stAxis[GVL.cXP].axisRef.status.NegativeDirection AND stAxis[GVL.cXP].stHall[GVL.cDirNeg, stAxis[GVL.cXP].nTripCount].nSeq = stTrack[k].nSeqToCompare AND
			stAxis[GVL.cXP].stHall[GVL.cDirNeg, stAxis[GVL.cXP].nTripCount].bEdge = stTrack[k].bEdgeToCompare AND (NOT bGoNextSeq) THEN
		stAxis[GVL.cXP].fHallPosAct := stAxis[GVL.cXP].fHallPosCal[GVL.cDirNeg, stAxis[GVL.cXP].nTripCount];
		stAxis[GVL.cXP].nTripCount := stAxis[GVL.cXP].nTripCount - 1;		
		//track difference between hall sensor and encoder data at trip point
		stAxis[GVL.cXP].fPosDiffAtTrip := stAxis[GVL.cXP].axisRef.NcToPlc.ActPos - stAxis[GVL.cXP].fHallPosAct;
		stAxis[GVL.cXP].bTrackedFlag:=TRUE;
		bGoNextSeq:=TRUE;
		
		IF bInMotion AND MAIN.outShutterStatus.smState<>E_StatesMaint.Calibrating THEN
			nAxisID:= GVL.cXP;
			// The Hall event belongs to the +X blade set.
			adcExtTime := F_AdcPtpTime(stTrack[k].nHallID, stTrack[k].tScanTime, motionStartTime[GVL.cXP]);
			stMotionDone[GVL.cXP].trans[stMotionDone[GVL.cXP].ntrans].extTime := adcExtTime;
			stMotionDone[GVL.cXP].trans[stMotionDone[GVL.cXP].ntrans].id := stTrack[k].nHallID;
			stMotionDone[GVL.cXP].trans[stMotionDone[GVL.cXP].ntrans].on := stTrack[k].bEdgeToCompare;
			stMotionDone[GVL.cXP].trans[stMotionDone[GVL.cXP].ntrans].pos := stAxis[GVL.cXP].fHallPosAct;
			stMotionDone[GVL.cXP].ntrans := stMotionDone[GVL.cXP].ntrans +1;
			
			encExtTime := F_EncPtpTime(F_GetCurDcTaskTime64(), motionStartTime[GVL.cXP]);
			stMotionDone[GVL.cXM].samples[stMotionDone[GVL.cXP].nsamples].extTime := encExtTime;
			stMotionDone[GVL.cXP].samples[stMotionDone[GVL.cXP].nsamples].pos := stAxis[GVL.cXP].axisRef.NcToPlc.ActPos;
			stMotionDone[GVL.cXP].nsamples := stMotionDone[GVL.cXP].nsamples + 1;
		END_IF
		
	END_IF
END_IF

// -X blade set
IF stAxis[GVL.cXM].axisRef.Status.Moving THEN
	//Compare current sequence with recorded sequence. Update position if match. Positive direction.
	IF stAxis[GVL.cXM].axisRef.status.PositiveDirection AND stAxis[GVL.cXM].stHall[GVL.cDirPos, stAxis[GVL.cXM].nTripCount].nSeq = stTrack[k].nSeqToCompare AND
			stAxis[GVL.cXM].stHall[GVL.cDirPos, stAxis[GVL.cXM].nTripCount].bEdge = stTrack[k].bEdgeToCompare AND (NOT bGoNextSeq) THEN
		stAxis[GVL.cXM].fHallPosAct := stAxis[GVL.cXM].fHallPosCal[GVL.cDirPos, stAxis[GVL.cXM].nTripCount];
		stAxis[GVL.cXM].nTripCount := stAxis[GVL.cXM].nTripCount - 1;	
		//track difference between hall sensor and encoder data at trip point
		stAxis[GVL.cXM].fPosDiffAtTrip := stAxis[GVL.cXM].axisRef.NcToPlc.ActPos - stAxis[GVL.cXM].fHallPosAct;
		stAxis[GVL.cXM].bTrackedFlag:=TRUE;
		bGoNextSeq:=TRUE;
		
		IF bInMotion AND MAIN.outShutterStatus.smState<>E_StatesMaint.Calibrating THEN
			nAxisID:= GVL.cXM;
			// The Hall event belongs to the -X blade set.
			adcExtTime := F_AdcPtpTime(stTrack[k].nHallID, stTrack[k].tScanTime, motionStartTime[GVL.cXM]);
			stMotionDone[GVL.cXM].trans[stMotionDone[GVL.cXM].ntrans].extTime := adcExtTime;
			stMotionDone[GVL.cXM].trans[stMotionDone[GVL.cXM].ntrans].id := stTrack[k].nHallID;
			stMotionDone[GVL.cXM].trans[stMotionDone[GVL.cXM].ntrans].on := stTrack[k].bEdgeToCompare;
			stMotionDone[GVL.cXM].trans[stMotionDone[GVL.cXM].ntrans].pos := stAxis[GVL.cXM].fHallPosAct;
			stMotionDone[GVL.cXM].ntrans := stMotionDone[GVL.cXM].ntrans +1;
			
			encExtTime := F_EncPtpTime(F_GetCurDcTaskTime64(), motionStartTime[GVL.cXM]);
			stMotionDone[GVL.cXM].samples[stMotionDone[GVL.cXM].nsamples].extTime := encExtTime;
			stMotionDone[GVL.cXM].samples[stMotionDone[GVL.cXM].nsamples].pos := stAxis[GVL.cXM].axisRef.NcToPlc.ActPos;
			stMotionDone[GVL.cXM].nsamples := stMotionDone[GVL.cXM].nsamples + 1;
		END_IF
		
	END_IF
	//Compare current sequence with recorded sequence. Update position if match. Negative direction.
	IF stAxis[GVL.cXM].axisRef.status.NegativeDirection AND stAxis[GVL.cXM].stHall[GVL.cDirNeg, stAxis[GVL.cXM].nTripCount].nSeq = stTrack[k].nSeqToCompare AND
			stAxis[GVL.cXM].stHall[GVL.cDirNeg, stAxis[GVL.cXM].nTripCount].bEdge = stTrack[k].bEdgeToCompare AND (NOT bGoNextSeq) THEN
		stAxis[GVL.cXM].fHallPosAct := stAxis[GVL.cXM].fHallPosCal[GVL.cDirNeg, stAxis[GVL.cXM].nTripCount];
		stAxis[GVL.cXM].nTripCount := stAxis[GVL.cXM].nTripCount + 1;	
		//track difference between hall sensor and encoder data at trip point
		stAxis[GVL.cXM].fPosDiffAtTrip := stAxis[GVL.cXM].axisRef.NcToPlc.ActPos - stAxis[GVL.cXM].fHallPosAct;
		stAxis[GVL.cXM].bTrackedFlag:=TRUE;
		bGoNextSeq:=TRUE;
		
		IF bInMotion AND MAIN.outShutterStatus.smState<>E_StatesMaint.Calibrating THEN
			nAxisID:= GVL.cXM;
			// The Hall event belongs to the -X blade set.
			adcExtTime := F_AdcPtpTime(stTrack[k].nHallID, stTrack[k].tScanTime, motionStartTime[GVL.cXM]);
			stMotionDone[GVL.cXM].trans[stMotionDone[GVL.cXM].ntrans].extTime := adcExtTime;
			stMotionDone[GVL.cXM].trans[stMotionDone[GVL.cXM].ntrans].id := stTrack[k].nHallID;
			stMotionDone[GVL.cXM].trans[stMotionDone[GVL.cXM].ntrans].on := stTrack[k].bEdgeToCompare;
			stMotionDone[GVL.cXM].trans[stMotionDone[GVL.cXM].ntrans].pos := stAxis[GVL.cXM].fHallPosAct;
			stMotionDone[GVL.cXM].ntrans := stMotionDone[GVL.cXM].ntrans +1;
			
			encExtTime := F_EncPtpTime(F_GetCurDcTaskTime64(), motionStartTime[GVL.cXM]);
			stMotionDone[GVL.cXM].samples[stMotionDone[GVL.cXM].nsamples].extTime := encExtTime;
			stMotionDone[GVL.cXM].samples[stMotionDone[GVL.cXM].nsamples].pos := stAxis[GVL.cXM].axisRef.NcToPlc.ActPos;
			stMotionDone[GVL.cXM].nsamples := stMotionDone[GVL.cXM].nsamples + 1;
		END_IF
		
	END_IF
END_IF]]></ST>
      </Implementation>
    </Action>
    <LineIds Name="FB_Tracking">
      <LineId Id="3" Count="2" />
      <LineId Id="9" Count="13" />
      <LineId Id="588" Count="0" />
      <LineId Id="590" Count="2" />
      <LineId Id="589" Count="0" />
      <LineId Id="23" Count="11" />
      <LineId Id="594" Count="0" />
      <LineId Id="677" Count="2" />
      <LineId Id="599" Count="0" />
      <LineId Id="35" Count="33" />
      <LineId Id="680" Count="0" />
      <LineId Id="71" Count="27" />
      <LineId Id="269" Count="2" />
      <LineId Id="99" Count="6" />
      <LineId Id="113" Count="3" />
      <LineId Id="603" Count="0" />
      <LineId Id="600" Count="0" />
      <LineId Id="602" Count="0" />
      <LineId Id="118" Count="7" />
      <LineId Id="130" Count="1" />
      <LineId Id="183" Count="0" />
      <LineId Id="190" Count="0" />
      <LineId Id="193" Count="17" />
      <LineId Id="2" Count="0" />
    </LineIds>
    <LineIds Name="FB_Tracking.ACT_TrackingDoubleNegative">
      <LineId Id="2" Count="1" />
      <LineId Id="58" Count="2" />
      <LineId Id="4" Count="12" />
      <LineId Id="87" Count="0" />
      <LineId Id="61" Count="0" />
      <LineId Id="79" Count="0" />
      <LineId Id="18" Count="4" />
      <LineId Id="85" Count="1" />
      <LineId Id="82" Count="0" />
      <LineId Id="24" Count="21" />
      <LineId Id="88" Count="1" />
      <LineId Id="46" Count="5" />
      <LineId Id="90" Count="0" />
      <LineId Id="52" Count="5" />
      <LineId Id="1" Count="0" />
    </LineIds>
    <LineIds Name="FB_Tracking.ACT_TrackingDoublePositive">
      <LineId Id="2" Count="15" />
      <LineId Id="64" Count="1" />
      <LineId Id="18" Count="5" />
      <LineId Id="66" Count="1" />
      <LineId Id="25" Count="20" />
      <LineId Id="59" Count="1" />
      <LineId Id="46" Count="5" />
      <LineId Id="61" Count="2" />
      <LineId Id="52" Count="6" />
      <LineId Id="1" Count="0" />
    </LineIds>
    <LineIds Name="FB_Tracking.ACT_TrackingSingle">
      <LineId Id="2" Count="15" />
      <LineId Id="106" Count="2" />
      <LineId Id="19" Count="3" />
      <LineId Id="109" Count="2" />
      <LineId Id="24" Count="17" />
      <LineId Id="121" Count="2" />
      <LineId Id="43" Count="4" />
      <LineId Id="119" Count="1" />
      <LineId Id="49" Count="20" />
      <LineId Id="124" Count="1" />
      <LineId Id="70" Count="5" />
      <LineId Id="126" Count="0" />
      <LineId Id="76" Count="17" />
      <LineId Id="127" Count="2" />
      <LineId Id="95" Count="4" />
      <LineId Id="130" Count="1" />
      <LineId Id="101" Count="4" />
      <LineId Id="1" Count="0" />
    </LineIds>
  </POU>
</TcPlcObject>
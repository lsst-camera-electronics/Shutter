<?xml version="1.0" encoding="utf-8"?>
<TcPlcObject Version="1.1.0.1" ProductVersion="3.1.4020.12">
  <POU Name="ShutterFSM" Id="{bb014c99-9246-4485-a45b-7048ac4294d5}" SpecialFunc="None">
    <Declaration><![CDATA[FUNCTION_BLOCK ShutterFSM
VAR_IN_OUT
	axis  : ARRAY [XP .. XM] OF AxisGroup;
	command : Commands;
	
	//statemachine
	shutterMode	: Mode;
	
	//other variables
	speed : LREAL;
	
END_VAR
VAR_INPUT

		

END_VAR
VAR_OUTPUT
END_VAR
VAR
	 //used in tracking Action
	 xorResult : BOOL;
	
	//state-machine
	stateLVL1	: States;
	stateLVL2 : INT;
	initStateLVL2 : BOOL;
	motionBusy : BOOL;
	
	//FSM flag
	normalModeFlag	: BOOL;
	engModeFlag		: BOOL;
	
	//counter
	i 	: INT :=0;
	
	//used in homeShutter Action
	homeDelay : TON;
	
	//counters and flags
	takingExposure : BOOL;
	
END_VAR
VAR CONSTANT
	BRAKE_OFF_C		: BOOL	:= TRUE;
	BRAKE_ON_C		: BOOL	:= FALSE;
	SCAN_VEL_C		: LREAL := 60;
	HOME_VEL_C		: LREAL	:= 3;
	CALIBRATE_VEL_C	: LREAL	:= 100;
	POSITION_VEL_C	: LREAL := 300;
	POS_START_C		: LREAL := 0;
	POS_END_C		: LREAL := 751;
	HOMEOFFSET_XP_C	: LREAL	:= (POS_START_C+35);
	HOMEOFFSET_XM_C	: LREAL	:= (POS_END_C-84);
	
	//SIZE_HALL_SW_C 	: LREAL := SIZEOF(GVL.hallPosCalXP);
	
	//For indexing axis
	XP : INT := 0;
	XM : INT := 1;
END_VAR]]></Declaration>
    <Implementation>
      <ST><![CDATA[(*
This function block contains all the motion of the shutter. There are two state machine in this module - stateLVL1 and stateLVL2.
stateLVL1 is used to switch between motions. stateLVL2 is used to operate the statemachine within the particular motion.
Motions are split into different action objects for readibility and maintainability. 
*)

//update Axis_Ref status
axis[XP].axisRef.ReadStatus();
axis[XM].axisRef.ReadStatus();


//mode Select
CASE shutterMode OF
	Mode.prod: 
		normalModeFlag 	:= TRUE;
		engModeFlag		:= FALSE;
	Mode.maint:
		normalModeFlag 	:= FALSE;
		engModeFlag		:= TRUE;
END_CASE

//normal mode FSM
IF command = commands.stopAllMotion THEN
	stateLVL1 := States.error;
	command := commands.noCommand;
END_IF
IF command = commands.clearAllFaults THEN
	stateLVL1 := States.reset;
	command := commands.noCommand;
END_IF
IF command = commands.reinit THEN
	stateLVL1 := States.init;
	command := commands.noCommand;
END_IF

IF normalModeFlag THEN
	CASE stateLVL1 OF
		States.error:
			axis[XP].mcPower(Axis := axis[XP].axisRef, Enable := TRUE, Enable_Positive := FALSE, Enable_Negative := FALSE);
			axis[XM].mcPower(Axis := axis[XM].axisRef, Enable := TRUE, Enable_Positive := FALSE, Enable_Negative := FALSE);	
			axis[XP].mcHome(Axis := axis[XP].axisRef, Execute := FALSE);
			axis[XM].mcHome(Axis := axis[XP].axisRef, Execute := FALSE);
			axis[XP].mcReset(Axis := axis[XP].axisRef, Execute := FALSE);
			axis[XM].mcReset(Axis := axis[XM].axisRef, Execute := FALSE);
			axis[XP].brake 	:= BRAKE_ON_C;
			axis[XM].brake 	:= BRAKE_ON_C;
			GVL.fbWaitTimer(IN:=FALSE);
	
		States.reset:
			motionBusy := FALSE;
			initStateLVL2 := FALSE;
			stateLVL2	:=0;
			axis[XP].mcReset(Axis := axis[XP].axisRef, Execute := TRUE, ErrorID => axis[XP].errorID);
			axis[XM].mcReset(Axis := axis[XM].axisRef, Execute := TRUE, ErrorID => axis[XM].errorID);
			IF axis[XP].mcReset.Done AND axis[XM].mcReset.Done THEN
				axis[XP].mcPower(Axis := axis[XP].axisRef, Enable := TRUE, Enable_Positive := TRUE, Enable_Negative := TRUE);
				axis[XM].mcPower(Axis := axis[XM].axisRef, Enable := TRUE, Enable_Positive := TRUE, Enable_Negative := TRUE);
				axis[XP].mcReset(Axis := axis[XP].axisRef, Execute := FALSE);
				axis[XM].mcReset(Axis := axis[XM].axisRef, Execute := FALSE);
				axis[XP].mcHome(Axis := axis[XP].axisRef, Execute := FALSE);
				axis[XM].mcHome(Axis := axis[XM].axisRef, Execute := FALSE);
				axis[XP].mcMoveAbs(Axis := axis[XP].axisRef, Execute := FALSE);
				axis[XM].mcMoveAbs(Axis := axis[XM].axisRef, Execute := FALSE);
				axis[XP].mcJog(Axis := axis[XP].axisRef, JogForward := FALSE, JogBackwards := FALSE);
				axis[XM].mcJog(Axis := axis[XM].axisRef, JogForward := FALSE, JogBackwards := FALSE);
				axis[XP].brake := BRAKE_OFF_C;
				axis[XM].brake := BRAKE_OFF_C;
				axis[XP].mcStop(Axis:=axis[XP].axisRef, Execute:=FALSE);
				axis[XM].mcStop(Axis:=axis[XM].axisRef, Execute:=FALSE);
				GVL.fbWaitTimer(IN:=FALSE);	
				stateLVL1 := States.ready;
			END_IF

			
		States.init:
			homeShutter();
			calibrateXP();
			calibrateXM();
			speed := POSITION_VEL_C;
			closeShutterPX();
			IF motionBusy = FALSE THEN
				speed := 0;
				stateLVL1 := States.closedPX;
			END_IF
			
		States.ready:
			idle();
			IF axis[XP].axisRef.Status.Homed AND axis[XM].axisRef.Status.Homed THEN
				CASE command OF
					commands.openShutter: 		stateLVL1 := states.openingPX;
					commands.closeShutterMX:	stateLVL1 := states.closingMX;
					commands.closeShutterPX:	stateLVL1 := states.closingPX;
					commands.reinit:			stateLVL1 := states.init;
				END_CASE
			END_IF
				
		States.openingPX:
			openShutter();
			IF takingExposure THEN
				GVL.fbWaitTimer(IN:=TRUE, PT:=GVL.expoTime,);
			END_IF
			IF motionBusy = FALSE THEN
				stateLVL1 := States.openedPX;
			END_IF
			IF GVL.fbWaitTimer.Q THEN
				initStateLVL2 := FALSE;
				stateLVL2 := 0;
				motionBusy := FALSE;
				axis[XM].mcMoveAbs(Axis:=axis[XM].axisRef, Execute:=FALSE); //disabled so it can be re-enabled in travllingMX, otherwise it won't work.
				stateLVL1 := States.travellingPX;
			END_IF		
			
		States.openedPX:
			idle();
			IF takingExposure THEN
				GVL.fbWaitTimer(IN:=TRUE, PT:=GVL.expoTime);
			END_IF
			IF command = Commands.closeShutterPX OR GVL.fbWaitTimer.Q THEN
				stateLVL1 := States.closingPX;
			END_IF
			IF command = Commands.closeShutterMX THEN
				stateLVL1 := States.closingMX;
			END_IF
			
		States.closingPX:
			closeShutterPX();
			IF motionBusy = FALSE THEN
				stateLVL1 := States.closedPX;
			END_IF
		
		States.closedPX:
			idle();
			IF command = Commands.openShutter THEN
				stateLVL1 := States.openingMX;
			ELSIF command = Commands.takeExposure THEN
				takingExposure := TRUE;
				stateLVL1 := States.openingMX;
			END_IF
			
		States.openingMX:
			openshutter();
			IF takingExposure THEN
				GVL.fbWaitTimer(IN:=TRUE, PT:=GVL.expoTime);
			END_IF
			IF motionbusy = FALSE THEN
				stateLVL1 := States.openedMX;
			END_IF
			IF GVL.fbWaitTimer.Q THEN
				initStateLVL2 := FALSE;
				stateLVL2 := 0;
				motionBusy := FALSE;
				axis[XP].mcMoveAbs(Axis:=axis[XP].axisRef, Execute:=FALSE); //disabled so it can be re-enabled in travllingMX, otherwise it won't work.
				stateLVL1 := States.travellingMX;
			END_IF
		
		States.openedMX:
			idle();
			IF takingExposure THEN
				GVL.fbWaitTimer(IN:=TRUE, PT:=GVL.expoTime);
			END_IF
			IF command = Commands.closeShutterMX OR GVL.fbWaitTimer.Q THEN
				stateLVL1 := States.closingMX;
			END_IF
			IF command = Commands.closeShutterPX THEN
				stateLVL1 := States.closingPX;
			END_IF
		
		States.closingMX:
			closeShutterMX();
			IF motionBusy = FALSE THEN
				stateLVL1 := States.closedMX;
			END_IF
		
		States.closedMX:
			idle();
			takingExposure := FALSE;
			IF command = Commands.openShutter THEN
				stateLVL1 := States.openingPX;
			ELSIF command = Commands.takeExposure THEN
				takingExposure := TRUE;
				stateLVL1 := States.openingPX;
			END_IF
		
		States.travellingPX:
			axis[XM].mcMoveAbs(Axis:=axis[XM].axisRef, Position:= POS_START_C, Velocity:=speed, Execute:=TRUE);
			axis[XP].mcMoveAbs(Axis:=axis[XP].axisRef, Position:= POS_START_C, Velocity:=speed, Execute:=TRUE);
			IF axis[XP].mcMoveAbs.Done AND axis[XM].mcMoveAbs.Done THEN
				axis[XP].mcMoveAbs(Axis:=axis[XP].axisRef, Execute:=FALSE);
				axis[XM].mcMoveAbs(Axis:=axis[XM].axisRef, Execute:=FALSE);
				motionbusy := FALSE;
				stateLVL1 := States.closedPX; 
			END_IF
			
		States.travellingMX:
			axis[XM].mcMoveAbs(Axis:=axis[XM].axisRef, Position:= POS_END_C, Velocity:=speed, Execute:=TRUE);
			axis[XP].mcMoveAbs(Axis:=axis[XP].axisRef, Position:= POS_END_C, Velocity:=speed, Execute:=TRUE);
			IF axis[XP].mcMoveAbs.Done AND axis[XM].mcMoveAbs.Done THEN
				axis[XP].mcMoveAbs(Axis:=axis[XP].axisRef, Execute:=FALSE);
				axis[XM].mcMoveAbs(Axis:=axis[XM].axisRef, Execute:=FALSE);
				motionbusy := FALSE;
				stateLVL1 := States.closedMX; 
			END_IF
		
			
	END_CASE
END_IF	


IF GVL.fbWaitTimer.Q THEN
	GVL.fbWaitTimer(IN:=FALSE);
END_IF
	
//reset command
IF command <> Commands.noCommand THEN
	command := Commands.noCommand;
END_IF

//track motion of both blades
tracking();]]></ST>
    </Implementation>
    <Action Name="calibrateXM" Id="{61d38d51-eb99-4428-a557-1aa6b49bb9c1}">
      <Implementation>
        <ST><![CDATA[//////////////////////////////////////////////////
//perform software calibration of axisXM blade. //
//////////////////////////////////////////////////

IF initStateLVL2 = FALSE THEN
	initStateLVL2 := TRUE;
	stateLVL2 :=9010;
	motionBusy := TRUE;
END_IF	

CASE stateLVL2 OF
	
	9010: //Clear previous Calibration value
		FOR i:=0 TO GVL.tripCount_C BY 1 DO
			axis[XM].hallPosCal[0,i]:=0;
			axis[XM].hallPosCal[1,i]:=0;
		END_FOR
		axis[XM].tripCount := 0;
		axis[XM].isCalibrated := FALSE;
		stateLVL2:=9020;
		
	9020: //Put Shutter in Open Position
		axis[XP].mcMoveAbs(Axis:=axis[XP].axisRef, Position:= POS_START_C, Velocity:=POSITION_VEL_C, Execute:=TRUE);
		axis[XM].mcMoveAbs(Axis:=axis[XM].axisRef, Position:= POS_END_C, Velocity:=POSITION_VEL_C, Execute:=TRUE);
		IF axis[XP].mcMoveAbs.Done AND axis[XM].mcMoveAbs.Done THEN
			axis[XP].mcMoveAbs(Axis:=axis[XP].axisRef, Execute:=FALSE);
			axis[XM].mcMoveAbs(Axis:=axis[XM].axisRef, Execute:=FALSE);
			stateLVL2:=9030;
		END_IF
		
		//This section is required to get rid of false trigger when system starts up
		FOR i:=GVL.hallLower_C TO GVL.hallUpper_C BY 1 DO
			axis[XM].hallSigCal_rtrig[i](CLK:=GVL.hallSwitch[i]);
			axis[XM].hallSigCal_ftrig[i](CLK:=GVL.hallSwitch[i]);
			IF axis[XM].hallSigCal_rtrig[i].Q OR axis[XM].hallSigCal_ftrig[i].Q THEN
				; //do nothing
			END_IF
		END_FOR	
	
	9030: //Calibrate AxisXM twoards X+ side.
		//record position and sequence of hall trips at rising and falling edge.
		FOR i:=GVL.hallLower_C TO GVL.hallUpper_C BY 1 DO
			axis[XM].hallSigCal_rtrig[i](CLK:=GVL.hallSwitch[i]);
			axis[XM].hallSigCal_ftrig[i](CLK:=GVL.hallSwitch[i]);
			IF axis[XM].hallSigCal_rtrig[i].Q OR axis[XM].hallSigCal_ftrig[i].Q THEN	
				
				axis[XM].hallSequence[GVL.dirNeg_C, axis[XM].tripCount].0 := axis[XM].hallSigCal_rtrig[0].Q OR axis[XM].hallSigCal_ftrig[0].Q;
				axis[XM].hallSequence[GVL.dirNeg_C, axis[XM].tripCount].1 := axis[XM].hallSigCal_rtrig[1].Q OR axis[XM].hallSigCal_ftrig[1].Q;
				axis[XM].hallSequence[GVL.dirNeg_C, axis[XM].tripCount].2 := axis[XM].hallSigCal_rtrig[2].Q OR axis[XM].hallSigCal_ftrig[2].Q;
				axis[XM].hallSequence[GVL.dirNeg_C, axis[XM].tripCount].3 := axis[XM].hallSigCal_rtrig[3].Q OR axis[XM].hallSigCal_ftrig[3].Q;
				axis[XM].hallSequence[GVL.dirNeg_C, axis[XM].tripCount].4 := axis[XM].hallSigCal_rtrig[4].Q OR axis[XM].hallSigCal_ftrig[4].Q;
				axis[XM].hallSequence[GVL.dirNeg_C, axis[XM].tripCount].5 := axis[XM].hallSigCal_rtrig[5].Q OR axis[XM].hallSigCal_ftrig[5].Q;
				axis[XM].hallSequence[GVL.dirNeg_C, axis[XM].tripCount].6 := axis[XM].hallSigCal_rtrig[6].Q OR axis[XM].hallSigCal_ftrig[6].Q;
				axis[XM].hallSequence[GVL.dirNeg_C, axis[XM].tripCount].7 := axis[XM].hallSigCal_rtrig[7].Q OR axis[XM].hallSigCal_ftrig[7].Q;
				axis[XM].hallSequence[GVL.dirNeg_C, axis[XM].tripCount].8 := axis[XM].hallSigCal_rtrig[8].Q OR axis[XM].hallSigCal_ftrig[8].Q;
				axis[XM].hallSequence[GVL.dirNeg_C, axis[XM].tripCount].9 := axis[XM].hallSigCal_rtrig[9].Q OR axis[XM].hallSigCal_ftrig[9].Q;
				axis[XM].hallSequence[GVL.dirNeg_C, axis[XM].tripCount].10 := axis[XM].hallSigCal_rtrig[10].Q OR axis[XM].hallSigCal_ftrig[10].Q;
				axis[XM].hallSequence[GVL.dirNeg_C, axis[XM].tripCount].11 := axis[XM].hallSigCal_rtrig[11].Q OR axis[XM].hallSigCal_ftrig[11].Q;
				axis[XM].hallSequence[GVL.dirNeg_C, axis[XM].tripCount].12 := axis[XM].hallSigCal_rtrig[12].Q OR axis[XM].hallSigCal_ftrig[12].Q;
				axis[XM].hallSequence[GVL.dirNeg_C, axis[XM].tripCount].13 := axis[XM].hallSigCal_rtrig[13].Q OR axis[XM].hallSigCal_ftrig[13].Q;
				axis[XM].hallSequence[GVL.dirNeg_C, axis[XM].tripCount].14 := axis[XM].hallSigCal_rtrig[14].Q OR axis[XM].hallSigCal_ftrig[14].Q;
				
				axis[XM].hallPosCal[GVL.dirNeg_C, axis[XM].tripCount] := axis[XM].axisRef.NcToPlc.ActPos;
				
				axis[XM].tripCount := axis[XM].tripCount + 1;		

			END_IF
		END_FOR

		//start moving axisXP towards x+ side
		axis[XM].mcMoveAbs(Axis:=axis[XM].axisRef, Position:=POS_START_C, Velocity:=CALIBRATE_VEL_C, Execute:=TRUE);
		IF axis[XM].mcMoveAbs.Done THEN
			axis[XM].mcMoveAbs(Axis:=axis[XP].axisRef, Execute:=FALSE);
			stateLVL2:= 9040;
		END_IF
	
	
	9040: //Calibrate AxisXM twoards X- side.
		//record position and sequence of hall trips at rising and falling edge.
		FOR i:=GVL.hallLower_C TO GVL.hallUpper_C BY 1 DO
			axis[XM].hallSigCal_rtrig[i](CLK:=GVL.hallSwitch[i]);
			axis[XM].hallSigCal_ftrig[i](CLK:=GVL.hallSwitch[i]);
			IF axis[XM].hallSigCal_rtrig[i].Q OR axis[XM].hallSigCal_ftrig[i].Q THEN	
				
				axis[XM].hallSequence[GVL.dirPos_C, axis[XM].tripCount].0 := axis[XM].hallSigCal_rtrig[0].Q OR axis[XM].hallSigCal_ftrig[0].Q;
				axis[XM].hallSequence[GVL.dirPos_C, axis[XM].tripCount].1 := axis[XM].hallSigCal_rtrig[1].Q OR axis[XM].hallSigCal_ftrig[1].Q;
				axis[XM].hallSequence[GVL.dirPos_C, axis[XM].tripCount].2 := axis[XM].hallSigCal_rtrig[2].Q OR axis[XM].hallSigCal_ftrig[2].Q;
				axis[XM].hallSequence[GVL.dirPos_C, axis[XM].tripCount].3 := axis[XM].hallSigCal_rtrig[3].Q OR axis[XM].hallSigCal_ftrig[3].Q;
				axis[XM].hallSequence[GVL.dirPos_C, axis[XM].tripCount].4 := axis[XM].hallSigCal_rtrig[4].Q OR axis[XM].hallSigCal_ftrig[4].Q;
				axis[XM].hallSequence[GVL.dirPos_C, axis[XM].tripCount].5 := axis[XM].hallSigCal_rtrig[5].Q OR axis[XM].hallSigCal_ftrig[5].Q;
				axis[XM].hallSequence[GVL.dirPos_C, axis[XM].tripCount].6 := axis[XM].hallSigCal_rtrig[6].Q OR axis[XM].hallSigCal_ftrig[6].Q;
				axis[XM].hallSequence[GVL.dirPos_C, axis[XM].tripCount].7 := axis[XM].hallSigCal_rtrig[7].Q OR axis[XM].hallSigCal_ftrig[7].Q;
				axis[XM].hallSequence[GVL.dirPos_C, axis[XM].tripCount].8 := axis[XM].hallSigCal_rtrig[8].Q OR axis[XM].hallSigCal_ftrig[8].Q;
				axis[XM].hallSequence[GVL.dirPos_C, axis[XM].tripCount].9 := axis[XM].hallSigCal_rtrig[9].Q OR axis[XM].hallSigCal_ftrig[9].Q;
				axis[XM].hallSequence[GVL.dirPos_C, axis[XM].tripCount].10 := axis[XM].hallSigCal_rtrig[10].Q OR axis[XM].hallSigCal_ftrig[10].Q;
				axis[XM].hallSequence[GVL.dirPos_C, axis[XM].tripCount].11 := axis[XM].hallSigCal_rtrig[11].Q OR axis[XM].hallSigCal_ftrig[11].Q;
				axis[XM].hallSequence[GVL.dirPos_C, axis[XM].tripCount].12 := axis[XM].hallSigCal_rtrig[12].Q OR axis[XM].hallSigCal_ftrig[12].Q;
				axis[XM].hallSequence[GVL.dirPos_C, axis[XM].tripCount].13 := axis[XM].hallSigCal_rtrig[13].Q OR axis[XM].hallSigCal_ftrig[13].Q;
				axis[XM].hallSequence[GVL.dirPos_C, axis[XM].tripCount].14 := axis[XM].hallSigCal_rtrig[14].Q OR axis[XM].hallSigCal_ftrig[14].Q;
			
				axis[XM].hallPosCal[GVL.dirPos_C, axis[XM].tripCount] := axis[XM].axisRef.NcToPlc.ActPos;
				axis[XM].tripCount := axis[XM].tripCount - 1;	
			END_IF
		END_FOR
	
		//start moving axisXP towards x- side
		axis[XM].mcMoveAbs(Axis:=axis[XM].axisRef, Position:=POS_END_C, Velocity:=CALIBRATE_VEL_C, Execute:=TRUE);
		IF axis[XM].mcMoveAbs.Done THEN
			axis[XM].mcMoveAbs(Axis:=axis[XM].axisRef, Execute:=FALSE);
			stateLVL2 := 9050;
		END_IF
		
	9050: 
		axis[XM].mcJog(Axis := axis[XM].axisRef, Mode := MC_JOGMODE_CONTINOUS, Velocity := SCAN_VEL_C, JogBackwards := axis[XM].limitHome);
		IF NOT axis[XM].limitHome THEN
			axis[XM].mcJog(Axis := axis[XM].axisRef, Mode := MC_JOGMODE_CONTINOUS, JogBackwards := FALSE);
			stateLVL2 := 9060;
		END_IF

	9060: //slowly homed back to switch
		axis[XM].mcJog(Axis := axis[XM].axisRef, Mode := MC_JOGMODE_CONTINOUS, Velocity := HOME_VEL_C, JogForward := NOT axis[XM].limitHome);
		IF axis[XM].limitHome THEN
			axis[XM].mcJog(Axis := axis[XM].axisRef, Mode := MC_JOGMODE_CONTINOUS, JogForward := FALSE);
			stateLVL2 := 9070;
			axis[XM].isCalibrated := TRUE;
		END_IF			
		
	9070: //End action
		initStateLVL2 := FALSE;
		stateLVL2 := 0;
		motionBusy := FALSE;


END_CASE
]]></ST>
      </Implementation>
    </Action>
    <Action Name="calibrateXP" Id="{a4fafec0-b2b5-4f99-856c-e54f9fb5fe2a}">
      <Implementation>
        <ST><![CDATA[//////////////////////////////////////////////////
//perform software calibration of axisXP blade. //
//////////////////////////////////////////////////

IF initStateLVL2 = FALSE THEN
	initStateLVL2 := TRUE;
	stateLVL2 :=8010;
	motionBusy := TRUE;
END_IF	

CASE stateLVL2 OF

	8010: //Clear previous Calibration value
		FOR i:=0 TO GVL.tripCount_C BY 1 DO
			axis[XP].hallPosCal[0,i]:=0;
			axis[XP].hallPosCal[1,i]:=0;
		END_FOR
		axis[XP].tripCount := 0;	
		axis[XP].isCalibrated := FALSE;
		stateLVL2:=8020;
		
	8020: //Put Shutter in Open Position
		axis[XP].mcMoveAbs(Axis:=axis[XP].axisRef, Position:= POS_START_C, Velocity:=POSITION_VEL_C, Execute:=TRUE);
		axis[XM].mcMoveAbs(Axis:=axis[XM].axisRef, Position:= POS_END_C, Velocity:=POSITION_VEL_C, Execute:=TRUE);
		IF axis[XP].mcMoveAbs.Done AND axis[XM].mcMoveAbs.Done THEN
			axis[XP].mcMoveAbs(Axis:=axis[XP].axisRef, Execute:=FALSE);
			axis[XM].mcMoveAbs(Axis:=axis[XM].axisRef, Execute:=FALSE);
			stateLVL2:=8030;
		END_IF
		
		//This section is required to get rid of false trigger when system starts up
		FOR i:=GVL.hallLower_C TO GVL.hallUpper_C BY 1 DO
			axis[XP].hallSigCal_rtrig[i](CLK:=GVL.hallSwitch[i]);
			axis[XP].hallSigCal_ftrig[i](CLK:=GVL.hallSwitch[i]);
			IF axis[XP].hallSigCal_rtrig[i].Q OR axis[XP].hallSigCal_ftrig[i].Q THEN
				; //do nothing
			END_IF
		END_FOR

	8030: //Calibrate AxisXP towards X- side.
		//record position and sequence of hall trips at rising and falling edge.
		FOR i:=GVL.hallLower_C TO GVL.hallUpper_C BY 1 DO
			axis[XP].hallSigCal_rtrig[i](CLK:=GVL.hallSwitch[i]);
			axis[XP].hallSigCal_ftrig[i](CLK:=GVL.hallSwitch[i]);
			IF axis[XP].hallSigCal_rtrig[i].Q OR axis[XP].hallSigCal_ftrig[i].Q THEN	

				axis[XP].hallSequence[GVL.dirPos_C, axis[XP].tripCount].0 := axis[XP].hallSigCal_rtrig[0].Q OR axis[XP].hallSigCal_ftrig[0].Q;
				axis[XP].hallSequence[GVL.dirPos_C, axis[XP].tripCount].1 := axis[XP].hallSigCal_rtrig[1].Q OR axis[XP].hallSigCal_ftrig[1].Q;
				axis[XP].hallSequence[GVL.dirPos_C, axis[XP].tripCount].2 := axis[XP].hallSigCal_rtrig[2].Q OR axis[XP].hallSigCal_ftrig[2].Q;
				axis[XP].hallSequence[GVL.dirPos_C, axis[XP].tripCount].3 := axis[XP].hallSigCal_rtrig[3].Q OR axis[XP].hallSigCal_ftrig[3].Q;
				axis[XP].hallSequence[GVL.dirPos_C, axis[XP].tripCount].4 := axis[XP].hallSigCal_rtrig[4].Q OR axis[XP].hallSigCal_ftrig[4].Q;
				axis[XP].hallSequence[GVL.dirPos_C, axis[XP].tripCount].5 := axis[XP].hallSigCal_rtrig[5].Q OR axis[XP].hallSigCal_ftrig[5].Q;
				axis[XP].hallSequence[GVL.dirPos_C, axis[XP].tripCount].6 := axis[XP].hallSigCal_rtrig[6].Q OR axis[XP].hallSigCal_ftrig[6].Q;
				axis[XP].hallSequence[GVL.dirPos_C, axis[XP].tripCount].7 := axis[XP].hallSigCal_rtrig[7].Q OR axis[XP].hallSigCal_ftrig[7].Q;
				axis[XP].hallSequence[GVL.dirPos_C, axis[XP].tripCount].8 := axis[XP].hallSigCal_rtrig[8].Q OR axis[XP].hallSigCal_ftrig[8].Q;
				axis[XP].hallSequence[GVL.dirPos_C, axis[XP].tripCount].9 := axis[XP].hallSigCal_rtrig[9].Q OR axis[XP].hallSigCal_ftrig[9].Q;
				axis[XP].hallSequence[GVL.dirPos_C, axis[XP].tripCount].10 := axis[XP].hallSigCal_rtrig[10].Q OR axis[XP].hallSigCal_ftrig[10].Q;
				axis[XP].hallSequence[GVL.dirPos_C, axis[XP].tripCount].11 := axis[XP].hallSigCal_rtrig[11].Q OR axis[XP].hallSigCal_ftrig[11].Q;
				axis[XP].hallSequence[GVL.dirPos_C, axis[XP].tripCount].12 := axis[XP].hallSigCal_rtrig[12].Q OR axis[XP].hallSigCal_ftrig[12].Q;
				axis[XP].hallSequence[GVL.dirPos_C, axis[XP].tripCount].13 := axis[XP].hallSigCal_rtrig[13].Q OR axis[XP].hallSigCal_ftrig[13].Q;
				axis[XP].hallSequence[GVL.dirPos_C, axis[XP].tripCount].14 := axis[XP].hallSigCal_rtrig[14].Q OR axis[XP].hallSigCal_ftrig[14].Q;

				axis[XP].hallPosCal[GVL.dirPos_C, axis[XP].tripCount] := axis[XP].axisRef.NcToPlc.ActPos;
				axis[XP].tripCount := axis[XP].tripCount + 1;		

			END_IF
		END_FOR
	
		//start moving axisXP towards x- side
		axis[XP].mcMoveAbs(Axis:=axis[XP].axisRef, Position:=POS_END_C, Velocity:=CALIBRATE_VEL_C, Execute:=TRUE);
		IF axis[XP].mcMoveAbs.Done THEN
			axis[XP].mcMoveAbs(Axis:=axis[XP].axisRef, Execute:=FALSE);
			stateLVL2:= 8040;
		END_IF
	
	8040: //Calibrate AxisXP towards X+ side.
		//record position and sequence of hall trips at rising and falling edge
		FOR i:=GVL.hallLower_C TO GVL.hallUpper_C BY 1 DO
			axis[XP].hallSigCal_rtrig[i](CLK:=GVL.hallSwitch[i]);
			axis[XP].hallSigCal_ftrig[i](CLK:=GVL.hallSwitch[i]);
			IF axis[XP].hallSigCal_rtrig[i].Q OR axis[XP].hallSigCal_ftrig[i].Q THEN
				
				axis[XP].hallSequence[GVL.dirNeg_C, axis[XP].tripCount].0 := axis[XP].hallSigCal_rtrig[0].Q OR axis[XP].hallSigCal_ftrig[0].Q;
				axis[XP].hallSequence[GVL.dirNeg_C, axis[XP].tripCount].1 := axis[XP].hallSigCal_rtrig[1].Q OR axis[XP].hallSigCal_ftrig[1].Q;
				axis[XP].hallSequence[GVL.dirNeg_C, axis[XP].tripCount].2 := axis[XP].hallSigCal_rtrig[2].Q OR axis[XP].hallSigCal_ftrig[2].Q;
				axis[XP].hallSequence[GVL.dirNeg_C, axis[XP].tripCount].3 := axis[XP].hallSigCal_rtrig[3].Q OR axis[XP].hallSigCal_ftrig[3].Q;
				axis[XP].hallSequence[GVL.dirNeg_C, axis[XP].tripCount].4 := axis[XP].hallSigCal_rtrig[4].Q OR axis[XP].hallSigCal_ftrig[4].Q;
				axis[XP].hallSequence[GVL.dirNeg_C, axis[XP].tripCount].5 := axis[XP].hallSigCal_rtrig[5].Q OR axis[XP].hallSigCal_ftrig[5].Q;
				axis[XP].hallSequence[GVL.dirNeg_C, axis[XP].tripCount].6 := axis[XP].hallSigCal_rtrig[6].Q OR axis[XP].hallSigCal_ftrig[6].Q;
				axis[XP].hallSequence[GVL.dirNeg_C, axis[XP].tripCount].7 := axis[XP].hallSigCal_rtrig[7].Q OR axis[XP].hallSigCal_ftrig[7].Q;
				axis[XP].hallSequence[GVL.dirNeg_C, axis[XP].tripCount].8 := axis[XP].hallSigCal_rtrig[8].Q OR axis[XP].hallSigCal_ftrig[8].Q;
				axis[XP].hallSequence[GVL.dirNeg_C, axis[XP].tripCount].9 := axis[XP].hallSigCal_rtrig[9].Q OR axis[XP].hallSigCal_ftrig[9].Q;
				axis[XP].hallSequence[GVL.dirNeg_C, axis[XP].tripCount].10 := axis[XP].hallSigCal_rtrig[10].Q OR axis[XP].hallSigCal_ftrig[10].Q;
				axis[XP].hallSequence[GVL.dirNeg_C, axis[XP].tripCount].11 := axis[XP].hallSigCal_rtrig[11].Q OR axis[XP].hallSigCal_ftrig[11].Q;
				axis[XP].hallSequence[GVL.dirNeg_C, axis[XP].tripCount].12 := axis[XP].hallSigCal_rtrig[12].Q OR axis[XP].hallSigCal_ftrig[12].Q;
				axis[XP].hallSequence[GVL.dirNeg_C, axis[XP].tripCount].13 := axis[XP].hallSigCal_rtrig[13].Q OR axis[XP].hallSigCal_ftrig[13].Q;
				axis[XP].hallSequence[GVL.dirNeg_C, axis[XP].tripCount].14 := axis[XP].hallSigCal_rtrig[14].Q OR axis[XP].hallSigCal_ftrig[14].Q;
			
				axis[XP].hallPosCal[GVL.dirNeg_C, axis[XP].tripCount] := axis[XP].axisRef.NcToPlc.ActPos;
				axis[XP].tripCount := axis[XP].tripCount - 1;	
			END_IF
		END_FOR
	
		//start moving axisXP towards x+ side
		axis[XP].mcMoveAbs(Axis:=axis[XP].axisRef, Position:=POS_START_C, Velocity:=CALIBRATE_VEL_C, Execute:=TRUE);
		IF axis[XP].mcMoveAbs.Done THEN
			axis[XP].mcMoveAbs(Axis:=axis[XP].axisRef, Execute:=FALSE);
			stateLVL2 := 8050;
		END_IF
	
	8050: 
		axis[XP].mcJog(Axis := axis[XP].axisRef, Mode := MC_JOGMODE_CONTINOUS, Velocity := SCAN_VEL_C, JogForward := axis[XP].limitHome);
		IF NOT axis[XP].limitHome THEN
			axis[XP].mcJog(Axis := axis[XM].axisRef, Mode := MC_JOGMODE_CONTINOUS, JogForward := FALSE);
			stateLVL2 := 8060;
		END_IF

	8060: //slowly homed back to switch
		axis[XP].mcJog(Axis := axis[XP].axisRef, Mode := MC_JOGMODE_CONTINOUS, Velocity := HOME_VEL_C, JogBackwards := NOT axis[XP].limitHome);
		IF axis[XP].limitHome THEN
			axis[XP].mcJog(Axis := axis[XP].axisRef, Mode := MC_JOGMODE_CONTINOUS, JogBackwards := FALSE);
			stateLVL2 := 8070;
			axis[XP].isCalibrated := TRUE;
		END_IF			
		
	8070: //End action
		initStateLVL2 := FALSE;
		stateLVL2 := 0;
		motionBusy := FALSE;

	
END_CASE]]></ST>
      </Implementation>
    </Action>
    <Action Name="closeShutterMX" Id="{5726d40f-02e9-4608-bbe9-5052244c0eb1}">
      <Implementation>
        <ST><![CDATA[//////////////////////////////////////////////////
//Closes shutter in -X position					//
//////////////////////////////////////////////////

IF initStateLVL2 = FALSE THEN
	initStateLVL2 := TRUE;
	stateLVL2 :=1210;
	motionBusy := TRUE;
END_IF

CASE stateLVL2 OF
	
	1210://Close shutter towards X- side. AxisXM retracts to its HOME position (~750 mm)
		axis[XM].mcMoveAbs(Axis:=axis[XM].axisRef, Position:= POS_END_C, Velocity:=speed, Execute:=TRUE);
		IF axis[XM].mcMoveAbs.Done THEN
			axis[XM].mcMoveAbs(Axis:=axis[XM].axisRef, Execute:=FALSE);
			stateLVL2:=1220;
		END_IF
		
	1220: //Close shutter towards X- side. AxisXP extends to its DEPLOYED position
		axis[XP].mcMoveAbs(Axis:=axis[XP].axisRef, Position:= POS_END_C, Velocity:=speed, Execute:=TRUE);
		IF axis[XP].mcMoveAbs.Done THEN
			axis[XP].mcMoveAbs(Axis:=axis[XP].axisRef, Execute:=FALSE);
			stateLVL2 := 1230;
		END_IF
		
	1230: //End Action
		initStateLVL2 := FALSE;
		stateLVL2 := 0;
		motionBusy := FALSE;
END_CASE
]]></ST>
      </Implementation>
    </Action>
    <Action Name="closeShutterPX" Id="{9522b8d4-64d7-441c-bfce-9f5d3b7ab8d3}">
      <Implementation>
        <ST><![CDATA[//////////////////////////////////////////////////
//Closes shutter in +X position					//
//////////////////////////////////////////////////

IF initStateLVL2 = FALSE THEN
	initStateLVL2 := TRUE;
	stateLVL2 :=1110;
	motionBusy := TRUE;
END_IF

CASE stateLVL2 OF
	
	1110: //Close shutter towards X+ side. axisXP retracts to its HOME position
		axis[XP].mcMoveAbs(Axis:=axis[XP].axisRef, Position:= POS_START_C, Velocity:=speed, Execute:=TRUE);
		IF axis[XP].mcMoveAbs.Done THEN
			axis[XP].mcMoveAbs(Axis:=axis[XP].axisRef, Execute:=FALSE);
			stateLVL2:=1120;
		END_IF
		
	1120: //Close shutter towards X+ side. AxisXM extends to its DEPLOYED position 
		axis[XM].mcMoveAbs(Axis:=axis[XM].axisRef, Position:= POS_START_C, Velocity:=speed, Execute:=TRUE);
		IF axis[XM].mcMoveAbs.Done THEN
			axis[XM].mcMoveAbs(Axis:=axis[XM].axisRef, Execute:=FALSE);
			stateLVL2 := 1130;
		END_IF
	
	1130: //End Action
		initStateLVL2 := FALSE;
		stateLVL2 := 0;
		motionBusy := FALSE;
END_CASE
]]></ST>
      </Implementation>
    </Action>
    <Action Name="cycler" Id="{54cf646d-089d-4e80-a3d3-5882b83c4a94}">
      <Implementation>
        <ST><![CDATA[///////////////////////////////////////////////////////
//Performs open/close motion until commanded to stop.//
///////////////////////////////////////////////////////
(*
IF initStateLVL2 = FALSE THEN
	initStateLVL2 := TRUE;
	stateLVL2 :=3010;
	motionBusy := TRUE;
END_IF	

CASE stateLVL2 OF

	3010: 
		motionBusy := TRUE;
		GVL.fbWaitTimer(IN:=TRUE, PT:=GVL.expoTime,);
		axis[XM].mcMoveAbs(Axis:=axis[XM].axisRef, Position:= POS_END_C, Velocity:=speed, Execute:=TRUE);
		IF GVL.fbWaitTimer.Q THEN
			axis[XP].mcMoveAbs(Axis:=axis[XP].axisRef, Position:= POS_END_C, Velocity:=speed, Execute:=TRUE);
		END_IF
		IF axis[XP].mcMoveAbs.Done AND axis[XM].mcMoveAbs.Done THEN
			GVL.strokeXP := GVL.strokeXP + 1;
			GVL.strokeXM := GVL.strokeXM + 1;
			GVL.fbWaitTimer(IN:=FALSE);
			axis[XP].mcMoveAbs(Axis:=axis[XP].axisRef, Execute:=FALSE);
			axis[XM].mcMoveAbs(Axis:=axis[XM].axisRef, Execute:=FALSE);
			stateLVL2:=3020;
		END_IF
		
	3020:
		GVL.fbWaitTimer(IN:=TRUE, PT:=T#100MS,);
		IF GVL.fbWaitTimer.Q THEN
			GVL.fbWaitTimer(IN:=FALSE);
			IF stopRequest THEN
				stopRequest:=FALSE;
				stateLVL2:=3999;
			ELSE
				stateLVL2:=3030;
			END_IF
		END_IF
		
	3030: 
		GVL.fbWaitTimer(IN:=TRUE, PT:=GVL.expoTime,);
		axis[XP].mcMoveAbs(Axis:=axis[XP].axisRef, Position:= POS_START_C, Velocity:=speed, Execute:=TRUE);
		IF GVL.fbWaitTimer.Q THEN
			axis[XM].mcMoveAbs(Axis:=axis[XM].axisRef, Position:= POS_START_C, Velocity:=speed, Execute:=TRUE);
		END_IF
		IF axis[XP].mcMoveAbs.Done AND axis[XM].mcMoveAbs.Done THEN
			GVL.strokeXP := GVL.strokeXP + 1;
			GVL.strokeXM := GVL.strokeXM + 1;
			GVL.fbWaitTimer(IN:=FALSE);
			axis[XP].mcMoveAbs(Axis:=axis[XP].axisRef, Execute:=FALSE);
			axis[XM].mcMoveAbs(Axis:=axis[XM].axisRef, Execute:=FALSE);
			stateLVL2:=3040;
		END_IF	
		
	3040:
		GVL.fbWaitTimer(IN:=TRUE, PT:=T#100MS,);
		IF GVL.fbWaitTimer.Q THEN
			GVL.fbWaitTimer(IN:=FALSE);
			IF stopRequest THEN
				stopRequest:=FALSE;
				stateLVL2:=3999;
			ELSE
				stateLVL2:=3010;
			END_IF
		END_IF

		
	3999: //End action
		initStateLVL2 := FALSE;
		stateLVL2 := 0;
		motionBusy := FALSE;
END_CASE
*)]]></ST>
      </Implementation>
    </Action>
    <Action Name="homeShutter" Id="{651efd51-ee65-4a00-b003-9b136bf29f06}">
      <Implementation>
        <ST><![CDATA[//////////////////////////////////////////////////
//Performs homing routine						//
//////////////////////////////////////////////////

IF initStateLVL2 = FALSE THEN
	initStateLVL2 := TRUE;
	stateLVL2 :=410;
	motionBusy := TRUE;
END_IF	

CASE stateLVL2 OF
	
	410: //Clear Homed flag and calibrated flag
		axis[XP].mcHome(Axis := axis[XP].axisRef, HomingMode := MC_ResetCalibration, bCalibrationCam := TRUE, Execute := TRUE);
		axis[XM].mcHome(Axis := axis[XM].axisRef, HomingMode := MC_ResetCalibration, bCalibrationCam := TRUE, Execute := TRUE);
		axis[XP].isCalibrated := FALSE;
		axis[XM].isCalibrated := FALSE;
		IF axis[XP].mcHome.Done AND axis[XM].mcHome.Done THEN
			stateLVL2 := 420;
		END_IF
		
	420: //Scan for home switch
		axis[XP].mcHome(Axis := axis[XP].axisRef, Execute := FALSE);
		axis[XM].mcHome(Axis := axis[XM].axisRef, Execute := FALSE);
		axis[XP].mcJog(Axis := axis[XP].axisRef, Mode := MC_JOGMODE_CONTINOUS, Velocity := SCAN_VEL_C, JogBackwards := NOT axis[XP].limitHome);
		axis[XM].mcJog(Axis := axis[XM].axisRef, Mode := MC_JOGMODE_CONTINOUS, Velocity := SCAN_VEL_C, JogForward := NOT axis[XM].limitHome);
		IF axis[XP].limitHome AND axis[XM].limitHome THEN
			axis[XP].mcJog(Axis := axis[XP].axisRef, Mode := MC_JOGMODE_CONTINOUS, JogBackwards := FALSE);
			axis[XM].mcJog(Axis := axis[XM].axisRef, Mode := MC_JOGMODE_CONTINOUS, JogForward := FALSE);
			stateLVL2 := 430;
		END_IF

	430: //back off from switch
		axis[XP].mcJog(Axis := axis[XP].axisRef, Mode := MC_JOGMODE_CONTINOUS, Velocity := SCAN_VEL_C, JogForward := axis[XP].limitHome);
		axis[XM].mcJog(Axis := axis[XM].axisRef, Mode := MC_JOGMODE_CONTINOUS, Velocity := SCAN_VEL_C, JogBackwards := axis[XM].limitHome);
		IF NOT axis[XP].limitHome AND NOT axis[XM].limitHome THEN
			axis[XP].mcJog(Axis := axis[XP].axisRef, Mode := MC_JOGMODE_CONTINOUS, JogForward := FALSE);
			axis[XM].mcJog(Axis := axis[XM].axisRef, Mode := MC_JOGMODE_CONTINOUS, JogBackwards := FALSE);
			stateLVL2 := 440;
		END_IF
		
	440: //slowly homed back to switch
		axis[XP].mcJog(Axis := axis[XP].axisRef, Mode := MC_JOGMODE_CONTINOUS, Velocity := HOME_VEL_C, JogBackwards := NOT axis[XP].limitHome);
		axis[XM].mcJog(Axis := axis[XM].axisRef, Mode := MC_JOGMODE_CONTINOUS, Velocity := HOME_VEL_C, JogForward := NOT axis[XM].limitHome);
		IF axis[XP].limitHome AND axis[XM].limitHome THEN
			axis[XP].mcJog(Axis := axis[XP].axisRef, Mode := MC_JOGMODE_CONTINOUS, JogBackwards := FALSE);
			axis[XM].mcJog(Axis := axis[XM].axisRef, Mode := MC_JOGMODE_CONTINOUS, JogForward := FALSE);
			stateLVL2 := 450;
		END_IF	

	450://delay
		homeDelay(IN:=TRUE, PT:=T#100MS);
		IF homeDelay.Q THEN
			homeDelay(IN:=FALSE);	
			stateLVL2 := 460;
		END_IF
		
	460://set home
		axis[XP].mcHome(Axis := axis[XP].axisRef, Position := POS_START_C, HomingMode := MC_DIRECT, Execute := TRUE);
		axis[XM].mcHome(Axis := axis[XM].axisRef, Position := POS_END_C, HomingMode := MC_DIRECT, Execute := TRUE);	
		IF axis[XP].mcHome.Done AND axis[XM].mcHome.Done THEN
			axis[XP].mcHome(Axis := axis[XP].axisRef, Execute := FALSE);
			axis[XM].mcHome(Axis := axis[XM].axisRef, Execute := FALSE);
			stateLVL2 := 470;
		END_IF	
		
		
	470: //End Action
		initStateLVL2 := FALSE;
		stateLVL2 := 0;
		motionBusy := FALSE;
END_CASE]]></ST>
      </Implementation>
    </Action>
    <Action Name="idle" Id="{3f6b251e-d39d-4a6c-8587-a5d78d4ebfbd}">
      <Implementation>
        <ST><![CDATA[//////////////////////////////////////////////////
//idle state    			 					//
//////////////////////////////////////////////////

	axis[XP].mcMoveAbs(Axis := axis[XP].axisRef, Execute := FALSE);
	axis[XM].mcMoveAbs(Axis := axis[XM].axisRef, Execute := FALSE);
	axis[XP].mcJog(Axis:=axis[XP].axisRef, JogForward:=FALSE, JogBackwards:=FALSE);
	axis[XM].mcJog(Axis:=axis[XM].axisRef, JogForward:=FALSE, JogBackwards:=FALSE);
	axis[XP].mcHome(Axis := axis[XP].axisRef, Execute := FALSE);
	axis[XM].mcHome(Axis := axis[XP].axisRef, Execute := FALSE);
	stateLVL2 := 0;
		
]]></ST>
      </Implementation>
    </Action>
    <Action Name="openShutter" Id="{8dd57fcc-2603-44a1-9743-be02b27fd1fa}">
      <Implementation>
        <ST><![CDATA[//////////////////////////////////////////////////
//Puts shutter in open position					//
//////////////////////////////////////////////////

IF initStateLVL2 = FALSE THEN
	initStateLVL2 := TRUE;
	stateLVL2 :=1010;
	motionBusy := TRUE;
END_IF	

CASE stateLVL2 OF
	
	1010:
		motionBusy := TRUE;
		axis[XP].mcMoveAbs(Axis:=axis[XP].axisRef, Position:= POS_START_C, Velocity:=speed, Execute:=TRUE);
		axis[XM].mcMoveAbs(Axis:=axis[XM].axisRef, Position:= POS_END_C, Velocity:=speed, Execute:=TRUE);
		IF axis[XP].mcMoveAbs.Done AND axis[XM].mcMoveAbs.Done THEN
			axis[XP].mcMoveAbs(Axis:=axis[XP].axisRef, Execute:=FALSE);
			axis[XM].mcMoveAbs(Axis:=axis[XM].axisRef, Execute:=FALSE);
			stateLVL2 := 1020;
		END_IF	
		
	1020: //End action
		initStateLVL2 := FALSE;
		stateLVL2 := 0;
		motionBusy := FALSE;
		
END_CASE]]></ST>
      </Implementation>
    </Action>
    <Action Name="takeExposure" Id="{bf74e5b5-13c0-4611-937e-1a5eb8136659}">
      <Implementation>
        <ST><![CDATA[//////////////////////////////////////////////////
//perform single visit motion					//
//////////////////////////////////////////////////

IF initStateLVL2 = FALSE THEN
	initStateLVL2 := TRUE;
	stateLVL2 :=2010;
	motionBusy := TRUE;
END_IF	

CASE stateLVL2 OF

	2010: 
		motionBusy := TRUE;
		GVL.fbWaitTimer(IN:=TRUE, PT:=GVL.expoTime,);
		axis[XM].mcMoveAbs(Axis:=axis[XM].axisRef, Position:= POS_END_C, Velocity:=speed, Execute:=TRUE);
		IF GVL.fbWaitTimer.Q THEN
			axis[XP].mcMoveAbs(Axis:=axis[XP].axisRef, Position:= POS_END_C, Velocity:=speed, Execute:=TRUE);
		END_IF
		IF axis[XP].mcMoveAbs.Done AND axis[XM].mcMoveAbs.Done THEN
			GVL.fbWaitTimer(IN:=FALSE);
			axis[XP].mcMoveAbs(Axis:=axis[XP].axisRef, Execute:=FALSE);
			axis[XM].mcMoveAbs(Axis:=axis[XM].axisRef, Execute:=FALSE);
			stateLVL2:=2020;
		END_IF
		
	2020:
		GVL.fbWaitTimer(IN:=TRUE, PT:=T#500MS,);
		IF GVL.fbWaitTimer.Q THEN
			GVL.fbWaitTimer(IN:=FALSE);
			stateLVL2:=2030;
		END_IF
		
	2030: 
		GVL.fbWaitTimer(IN:=TRUE, PT:=GVL.expoTime,);
		axis[XP].mcMoveAbs(Axis:=axis[XP].axisRef, Position:= POS_START_C, Velocity:=speed, Execute:=TRUE);
		IF GVL.fbWaitTimer.Q THEN
			axis[XM].mcMoveAbs(Axis:=axis[XM].axisRef, Position:= POS_START_C, Velocity:=speed, Execute:=TRUE);
		END_IF
		IF axis[XP].mcMoveAbs.Done AND axis[XM].mcMoveAbs.Done THEN
			GVL.fbWaitTimer(IN:=FALSE);
			axis[XP].mcMoveAbs(Axis:=axis[XP].axisRef, Execute:=FALSE);
			axis[XM].mcMoveAbs(Axis:=axis[XM].axisRef, Execute:=FALSE);
			stateLVL2:=2040;
		END_IF	

		
	2040: //End action
		initStateLVL2 := FALSE;
		stateLVL2 := 0;
		motionBusy := FALSE;
END_CASE]]></ST>
      </Implementation>
    </Action>
    <Action Name="tracking" Id="{ddca4a3f-c718-42e7-805e-9c2d83533b78}">
      <Implementation>
        <ST><![CDATA[//////////////////////////////////////////////////////////////
//Algorithm for tracking blade position using hall switches	//
//////////////////////////////////////////////////////////////

//Only one hall will ever trip for 1 set of blades. This flag is used to make sure the trip increment only once per cycle.
axis[XP].trackedFlag := FALSE;
axis[XM].trackedFlag := FALSE;

//Hall sensors position tracking for axis XP
FOR i:=GVL.hallLower_C TO GVL.hallUpper_C BY 1 DO
	axis[XP].hallSigCal_rtrig[i](CLK:=GVL.hallSwitch[i]);
	axis[XP].hallSigCal_ftrig[i](CLK:=GVL.hallSwitch[i]);
	IF (axis[XP].hallSigCal_rtrig[i].Q OR axis[XP].hallSigCal_ftrig[i].Q) AND axis[XP].axisRef.Status.Moving THEN
		axis[XP].trackedFlag := TRUE;
	END_IF
END_FOR
	
IF axis[XP].trackedFlag THEN
	//record trigger status of each hall sensor into hallSequence for comparing;
	GVL.hallSequence.0 := axis[XP].hallSigCal_rtrig[0].Q OR axis[XP].hallSigCal_ftrig[0].Q;
	GVL.hallSequence.1 := axis[XP].hallSigCal_rtrig[1].Q OR axis[XP].hallSigCal_ftrig[1].Q;
	GVL.hallSequence.2 := axis[XP].hallSigCal_rtrig[2].Q OR axis[XP].hallSigCal_ftrig[2].Q;
	GVL.hallSequence.3 := axis[XP].hallSigCal_rtrig[3].Q OR axis[XP].hallSigCal_ftrig[3].Q;
	GVL.hallSequence.4 := axis[XP].hallSigCal_rtrig[4].Q OR axis[XP].hallSigCal_ftrig[4].Q;
	GVL.hallSequence.5 := axis[XP].hallSigCal_rtrig[5].Q OR axis[XP].hallSigCal_ftrig[5].Q;
	GVL.hallSequence.6 := axis[XP].hallSigCal_rtrig[6].Q OR axis[XP].hallSigCal_ftrig[6].Q;
	GVL.hallSequence.7 := axis[XP].hallSigCal_rtrig[7].Q OR axis[XP].hallSigCal_ftrig[7].Q;
	GVL.hallSequence.8 := axis[XP].hallSigCal_rtrig[8].Q OR axis[XP].hallSigCal_ftrig[8].Q;
	GVL.hallSequence.9 := axis[XP].hallSigCal_rtrig[9].Q OR axis[XP].hallSigCal_ftrig[9].Q;
	GVL.hallSequence.10 := axis[XP].hallSigCal_rtrig[10].Q OR axis[XP].hallSigCal_ftrig[10].Q;
	GVL.hallSequence.11 := axis[XP].hallSigCal_rtrig[11].Q OR axis[XP].hallSigCal_ftrig[11].Q;
	GVL.hallSequence.12 := axis[XP].hallSigCal_rtrig[12].Q OR axis[XP].hallSigCal_ftrig[12].Q;
	GVL.hallSequence.13 := axis[XP].hallSigCal_rtrig[13].Q OR axis[XP].hallSigCal_ftrig[13].Q;
	GVL.hallSequence.14 := axis[XP].hallSigCal_rtrig[14].Q OR axis[XP].hallSigCal_ftrig[14].Q;	

	(* Unary XOR of hallSequence. With one blade running, 1 bit should be HIGH at a time .
		Result of 1 indicates presence of one blade sequence. Result of 0 indicates presence of two blade sequence *)
	xorResult := (GVL.hallSequence.0 XOR GVL.hallSequence.1 XOR GVL.hallSequence.2 XOR GVL.hallSequence.3 XOR GVL.hallSequence.4 XOR
		GVL.hallSequence.5 XOR GVL.hallSequence.6 XOR GVL.hallSequence.7 XOR GVL.hallSequence.8 XOR GVL.hallSequence.9 XOR
		GVL.hallSequence.10 XOR GVL.hallSequence.11 XOR GVL.hallSequence.12 XOR GVL.hallSequence.13 XOR GVL.hallSequence.14);
	IF xorResult THEN
		axis[XP].seqToCompare := GVL.hallSequence;
	ELSIF axis[XM].axisRef.status.PositiveDirection THEN
		axis[XP].seqToCompare := (GVL.hallSequence XOR axis[XM].hallSequence[GVL.dirPos_C, axis[XM].tripCount]);
	ELSIF axis[XM].axisRef.status.NegativeDirection THEN
		axis[XP].seqToCompare := (GVL.hallSequence XOR axis[XM].hallSequence[GVL.dirNeg_C, axis[XM].tripCount]);	
	ELSE
		; //Should generate error code here
	END_IF	

	//Compare current sequence with recorded sequence. Update position if match.
	IF axis[XP].axisRef.status.PositiveDirection AND axis[XP].hallSequence[GVL.dirPos_C, axis[XP].tripCount] = axis[XP].seqToCompare THEN
		axis[XP].hallPosAct := axis[XP].hallPosCal[GVL.dirPos_C, axis[XP].tripCount];
		axis[XP].tripCount := axis[XP].tripCount + 1;

		//testing purposes only. Will delete later.
		FOR i:= 1000 TO 1 BY -1 DO
			axis[XP].recordedPosition[i] := axis[XP].recordedPosition[i-1];
		END_FOR
		axis[XP].recordedPosition[1] := axis[XP].hallPosAct;
	
		
		//track difference between hall sensor and encoder data at trip point
		axis[XP].posDiffAtTrip := axis[XP].axisRef.NcToPlc.ActPos - axis[XP].hallPosAct;
	END_IF
	IF axis[XP].axisRef.status.NegativeDirection AND axis[XP].hallSequence[GVL.dirNeg_C, axis[XP].tripCount] = axis[XP].seqToCompare THEN
		axis[XP].hallPosAct := axis[XP].hallPosCal[GVL.dirNeg_C, axis[XP].tripCount];
		axis[XP].tripCount := axis[XP].tripCount - 1;	
		
		//testing purposes only. Will delete later.
		FOR i:= 1000 TO 1 BY -1 DO
			axis[XP].recordedPosition[i] := axis[XP].recordedPosition[i-1];
		END_FOR
		axis[XP].recordedPosition[1] := axis[XP].hallPosAct;		
		
		
		//track difference between hall sensor and encoder data at trip point
		axis[XP].posDiffAtTrip := axis[XP].axisRef.NcToPlc.ActPos - axis[XP].hallPosAct;
	END_IF
END_IF


//Hall sensors position tracking for axis XM
FOR i:=GVL.hallLower_C TO GVL.hallUpper_C BY 1 DO
	axis[XM].hallSigCal_rtrig[i](CLK:=GVL.hallSwitch[i]);
	axis[XM].hallSigCal_ftrig[i](CLK:=GVL.hallSwitch[i]);
	IF (axis[XM].hallSigCal_rtrig[i].Q OR axis[XM].hallSigCal_ftrig[i].Q) AND axis[XM].axisRef.Status.Moving AND NOT axis[XM].trackedFlag THEN
		axis[XM].trackedFlag := TRUE;
	END_IF
END_FOR

IF axis[XM].trackedFlag THEN
	
	//record trigger status of each hall sensor into hallSequence for comparing;
	GVL.hallSequence.0 := axis[XM].hallSigCal_rtrig[0].Q OR axis[XM].hallSigCal_ftrig[0].Q;
	GVL.hallSequence.1 := axis[XM].hallSigCal_rtrig[1].Q OR axis[XM].hallSigCal_ftrig[1].Q;
	GVL.hallSequence.2 := axis[XM].hallSigCal_rtrig[2].Q OR axis[XM].hallSigCal_ftrig[2].Q;
	GVL.hallSequence.3 := axis[XM].hallSigCal_rtrig[3].Q OR axis[XM].hallSigCal_ftrig[3].Q;
	GVL.hallSequence.4 := axis[XM].hallSigCal_rtrig[4].Q OR axis[XM].hallSigCal_ftrig[4].Q;
	GVL.hallSequence.5 := axis[XM].hallSigCal_rtrig[5].Q OR axis[XM].hallSigCal_ftrig[5].Q;
	GVL.hallSequence.6 := axis[XM].hallSigCal_rtrig[6].Q OR axis[XM].hallSigCal_ftrig[6].Q;
	GVL.hallSequence.7 := axis[XM].hallSigCal_rtrig[7].Q OR axis[XM].hallSigCal_ftrig[7].Q;
	GVL.hallSequence.8 := axis[XM].hallSigCal_rtrig[8].Q OR axis[XM].hallSigCal_ftrig[8].Q;
	GVL.hallSequence.9 := axis[XM].hallSigCal_rtrig[9].Q OR axis[XM].hallSigCal_ftrig[9].Q;
	GVL.hallSequence.10 := axis[XM].hallSigCal_rtrig[10].Q OR axis[XM].hallSigCal_ftrig[10].Q;
	GVL.hallSequence.11 := axis[XM].hallSigCal_rtrig[11].Q OR axis[XM].hallSigCal_ftrig[11].Q;
	GVL.hallSequence.12 := axis[XM].hallSigCal_rtrig[12].Q OR axis[XM].hallSigCal_ftrig[12].Q;
	GVL.hallSequence.13 := axis[XM].hallSigCal_rtrig[13].Q OR axis[XM].hallSigCal_ftrig[13].Q;
	GVL.hallSequence.14 := axis[XM].hallSigCal_rtrig[14].Q OR axis[XM].hallSigCal_ftrig[14].Q;			
	
	(* Unary XOR of hallSequence. With one blade running, 1 bit should be HIGH at a time .
		Result of 1 indicates presence of one blade sequence. Result of 0 indicates presence of two blade sequence *)
	xorResult := GVL.hallSequence.0 XOR GVL.hallSequence.1 XOR GVL.hallSequence.2 XOR GVL.hallSequence.3 XOR GVL.hallSequence.4 XOR
		GVL.hallSequence.5 XOR GVL.hallSequence.6 XOR GVL.hallSequence.7 XOR GVL.hallSequence.8 XOR GVL.hallSequence.9 XOR
		GVL.hallSequence.10 XOR GVL.hallSequence.11 XOR GVL.hallSequence.12 XOR GVL.hallSequence.13 XOR GVL.hallSequence.14;
	IF xorResult THEN
		axis[XM].seqToCompare := GVL.hallSequence;
	ELSIF axis[XP].axisRef.status.PositiveDirection THEN
		axis[XM].seqToCompare := (GVL.hallSequence XOR axis[XP].hallSequence[GVL.dirPos_C, axis[XP].tripCount-1]); //requires -1 since XP tripcount has already decremented
	ELSIF axis[XP].axisRef.status.NegativeDirection THEN
		axis[XM].seqToCompare := (GVL.hallSequence XOR axis[XP].hallSequence[GVL.dirNeg_C, axis[XP].tripCount+1]); //requires +1 since XP tripcount has already incremented
	ELSE
		; //Should generate error code here
	END_IF		

	//Compare current sequence with recorded sequence. Update position if match.	
	IF axis[XM].axisRef.status.PositiveDirection AND axis[XM].hallSequence[GVL.dirPos_C, axis[XM].tripCount] = axis[XM].seqToCompare THEN
		axis[XM].hallPosAct := axis[XM].hallPosCal[GVL.dirPos_C, axis[XM].tripCount];
		axis[XM].tripCount := axis[XM].tripCount - 1;	
		//track difference between hall sensor and encoder data at trip point
		axis[XM].posDiffAtTrip := axis[XM].axisRef.NcToPlc.ActPos - axis[XM].hallPosAct;
	END_IF
	IF axis[XM].axisRef.status.NegativeDirection AND axis[XM].hallSequence[GVL.dirNeg_C, axis[XM].tripCount] = axis[XM].seqToCompare THEN
		axis[XM].hallPosAct := axis[XM].hallPosCal[GVL.dirNeg_C, axis[XM].tripCount];
		axis[XM].tripCount := axis[XM].tripCount + 1;	
		//track difference between hall sensor and encoder data at trip point
		axis[XM].posDiffAtTrip := axis[XM].axisRef.NcToPlc.ActPos - axis[XM].hallPosAct;
	END_IF
END_IF



]]></ST>
      </Implementation>
    </Action>
    <Action Name="visit" Id="{22f43709-e463-4ca9-a12c-bff076021db5}">
      <Implementation>
        <ST><![CDATA[//////////////////////////////////////////////////
//perform single visit motion					//
//////////////////////////////////////////////////

IF initStateLVL2 = FALSE THEN
	initStateLVL2 := TRUE;
	stateLVL2 :=2010;
	motionBusy := TRUE;
END_IF	

CASE stateLVL2 OF

	2010: 
		motionBusy := TRUE;
		GVL.fbWaitTimer(IN:=TRUE, PT:=GVL.expoTime,);
		axis[XM].mcMoveAbs(Axis:=axis[XM].axisRef, Position:= POS_END_C, Velocity:=speed, Execute:=TRUE);
		IF GVL.fbWaitTimer.Q THEN
			axis[XP].mcMoveAbs(Axis:=axis[XP].axisRef, Position:= POS_END_C, Velocity:=speed, Execute:=TRUE);
		END_IF
		IF axis[XP].mcMoveAbs.Done AND axis[XM].mcMoveAbs.Done THEN
			GVL.fbWaitTimer(IN:=FALSE);
			axis[XP].mcMoveAbs(Axis:=axis[XP].axisRef, Execute:=FALSE);
			axis[XM].mcMoveAbs(Axis:=axis[XM].axisRef, Execute:=FALSE);
			stateLVL2:=2020;
		END_IF
		
	2020:
		GVL.fbWaitTimer(IN:=TRUE, PT:=T#500MS,);
		IF GVL.fbWaitTimer.Q THEN
			GVL.fbWaitTimer(IN:=FALSE);
			stateLVL2:=2030;
		END_IF
		
	2030: 
		GVL.fbWaitTimer(IN:=TRUE, PT:=GVL.expoTime,);
		axis[XP].mcMoveAbs(Axis:=axis[XP].axisRef, Position:= POS_START_C, Velocity:=speed, Execute:=TRUE);
		IF GVL.fbWaitTimer.Q THEN
			axis[XM].mcMoveAbs(Axis:=axis[XM].axisRef, Position:= POS_START_C, Velocity:=speed, Execute:=TRUE);
		END_IF
		IF axis[XP].mcMoveAbs.Done AND axis[XM].mcMoveAbs.Done THEN
			GVL.fbWaitTimer(IN:=FALSE);
			axis[XP].mcMoveAbs(Axis:=axis[XP].axisRef, Execute:=FALSE);
			axis[XM].mcMoveAbs(Axis:=axis[XM].axisRef, Execute:=FALSE);
			stateLVL2:=2040;
		END_IF	

		
	2040: //End action
		initStateLVL2 := FALSE;
		stateLVL2 := 0;
		motionBusy := FALSE;
END_CASE]]></ST>
      </Implementation>
    </Action>
    <LineIds Name="ShutterFSM">
      <LineId Id="60" Count="8" />
      <LineId Id="378" Count="0" />
      <LineId Id="318" Count="1" />
      <LineId Id="323" Count="0" />
      <LineId Id="334" Count="1" />
      <LineId Id="320" Count="0" />
      <LineId Id="337" Count="1" />
      <LineId Id="321" Count="0" />
      <LineId Id="326" Count="0" />
      <LineId Id="343" Count="0" />
      <LineId Id="595" Count="1" />
      <LineId Id="599" Count="0" />
      <LineId Id="597" Count="0" />
      <LineId Id="608" Count="1" />
      <LineId Id="611" Count="0" />
      <LineId Id="610" Count="0" />
      <LineId Id="600" Count="1" />
      <LineId Id="603" Count="0" />
      <LineId Id="602" Count="0" />
      <LineId Id="598" Count="0" />
      <LineId Id="226" Count="0" />
      <LineId Id="242" Count="0" />
      <LineId Id="590" Count="0" />
      <LineId Id="593" Count="0" />
      <LineId Id="644" Count="6" />
      <LineId Id="652" Count="0" />
      <LineId Id="591" Count="0" />
      <LineId Id="584" Count="1" />
      <LineId Id="625" Count="0" />
      <LineId Id="642" Count="0" />
      <LineId Id="705" Count="2" />
      <LineId Id="626" Count="0" />
      <LineId Id="632" Count="2" />
      <LineId Id="671" Count="1" />
      <LineId Id="676" Count="1" />
      <LineId Id="673" Count="1" />
      <LineId Id="635" Count="3" />
      <LineId Id="641" Count="0" />
      <LineId Id="710" Count="0" />
      <LineId Id="708" Count="0" />
      <LineId Id="668" Count="0" />
      <LineId Id="589" Count="0" />
      <LineId Id="287" Count="0" />
      <LineId Id="356" Count="2" />
      <LineId Id="379" Count="0" />
      <LineId Id="381" Count="0" />
      <LineId Id="365" Count="0" />
      <LineId Id="382" Count="0" />
      <LineId Id="366" Count="1" />
      <LineId Id="370" Count="0" />
      <LineId Id="839" Count="1" />
      <LineId Id="847" Count="0" />
      <LineId Id="841" Count="5" />
      <LineId Id="838" Count="0" />
      <LineId Id="848" Count="0" />
      <LineId Id="414" Count="0" />
      <LineId Id="424" Count="0" />
      <LineId Id="691" Count="2" />
      <LineId Id="766" Count="2" />
      <LineId Id="694" Count="0" />
      <LineId Id="769" Count="3" />
      <LineId Id="695" Count="1" />
      <LineId Id="429" Count="0" />
      <LineId Id="371" Count="0" />
      <LineId Id="431" Count="0" />
      <LineId Id="773" Count="2" />
      <LineId Id="564" Count="5" />
      <LineId Id="442" Count="0" />
      <LineId Id="417" Count="0" />
      <LineId Id="570" Count="3" />
      <LineId Id="432" Count="0" />
      <LineId Id="416" Count="0" />
      <LineId Id="373" Count="1" />
      <LineId Id="383" Count="0" />
      <LineId Id="681" Count="1" />
      <LineId Id="680" Count="0" />
      <LineId Id="517" Count="0" />
      <LineId Id="433" Count="0" />
      <LineId Id="372" Count="0" />
      <LineId Id="505" Count="0" />
      <LineId Id="683" Count="2" />
      <LineId Id="506" Count="2" />
      <LineId Id="737" Count="3" />
      <LineId Id="743" Count="0" />
      <LineId Id="741" Count="1" />
      <LineId Id="434" Count="0" />
      <LineId Id="386" Count="0" />
      <LineId Id="435" Count="0" />
      <LineId Id="686" Count="2" />
      <LineId Id="509" Count="2" />
      <LineId Id="537" Count="2" />
      <LineId Id="443" Count="0" />
      <LineId Id="418" Count="0" />
      <LineId Id="547" Count="0" />
      <LineId Id="549" Count="1" />
      <LineId Id="730" Count="0" />
      <LineId Id="729" Count="0" />
      <LineId Id="728" Count="0" />
      <LineId Id="727" Count="0" />
      <LineId Id="726" Count="0" />
      <LineId Id="725" Count="0" />
      <LineId Id="724" Count="0" />
      <LineId Id="554" Count="0" />
      <LineId Id="690" Count="0" />
      <LineId Id="556" Count="1" />
      <LineId Id="444" Count="0" />
      <LineId Id="387" Count="0" />
      <LineId Id="438" Count="0" />
      <LineId Id="697" Count="7" />
      <LineId Id="420" Count="0" />
      <LineId Id="528" Count="2" />
      <LineId Id="532" Count="1" />
      <LineId Id="536" Count="0" />
      <LineId Id="534" Count="1" />
      <LineId Id="439" Count="0" />
      <LineId Id="410" Count="0" />
      <LineId Id="348" Count="0" />
      <LineId Id="347" Count="0" />
      <LineId Id="230" Count="0" />
      <LineId Id="289" Count="1" />
      <LineId Id="545" Count="1" />
      <LineId Id="544" Count="0" />
      <LineId Id="291" Count="0" />
      <LineId Id="653" Count="2" />
      <LineId Id="292" Count="0" />
      <LineId Id="223" Count="1" />
      <LineId Id="9" Count="0" />
    </LineIds>
    <LineIds Name="ShutterFSM.calibrateXM">
      <LineId Id="2" Count="133" />
      <LineId Id="1" Count="0" />
    </LineIds>
    <LineIds Name="ShutterFSM.calibrateXP">
      <LineId Id="2" Count="130" />
      <LineId Id="1" Count="0" />
    </LineIds>
    <LineIds Name="ShutterFSM.closeShutterMX">
      <LineId Id="2" Count="30" />
      <LineId Id="1" Count="0" />
    </LineIds>
    <LineIds Name="ShutterFSM.closeShutterPX">
      <LineId Id="2" Count="30" />
      <LineId Id="1" Count="0" />
    </LineIds>
    <LineIds Name="ShutterFSM.cycler">
      <LineId Id="2" Count="72" />
      <LineId Id="1" Count="0" />
    </LineIds>
    <LineIds Name="ShutterFSM.homeShutter">
      <LineId Id="2" Count="70" />
      <LineId Id="1" Count="0" />
    </LineIds>
    <LineIds Name="ShutterFSM.idle">
      <LineId Id="43" Count="2" />
      <LineId Id="29" Count="6" />
      <LineId Id="22" Count="0" />
      <LineId Id="37" Count="0" />
      <LineId Id="1" Count="0" />
    </LineIds>
    <LineIds Name="ShutterFSM.openShutter">
      <LineId Id="2" Count="26" />
      <LineId Id="1" Count="0" />
    </LineIds>
    <LineIds Name="ShutterFSM.takeExposure">
      <LineId Id="2" Count="50" />
      <LineId Id="1" Count="0" />
    </LineIds>
    <LineIds Name="ShutterFSM.tracking">
      <LineId Id="2" Count="52" />
      <LineId Id="133" Count="0" />
      <LineId Id="140" Count="0" />
      <LineId Id="134" Count="0" />
      <LineId Id="138" Count="1" />
      <LineId Id="143" Count="0" />
      <LineId Id="136" Count="0" />
      <LineId Id="141" Count="0" />
      <LineId Id="55" Count="5" />
      <LineId Id="144" Count="1" />
      <LineId Id="147" Count="0" />
      <LineId Id="149" Count="2" />
      <LineId Id="148" Count="0" />
      <LineId Id="146" Count="0" />
      <LineId Id="61" Count="66" />
      <LineId Id="1" Count="0" />
    </LineIds>
    <LineIds Name="ShutterFSM.visit">
      <LineId Id="2" Count="50" />
      <LineId Id="1" Count="0" />
    </LineIds>
  </POU>
</TcPlcObject>
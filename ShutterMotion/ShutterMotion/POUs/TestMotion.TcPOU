<?xml version="1.0" encoding="utf-8"?>
<TcPlcObject Version="1.1.0.1" ProductVersion="3.1.4020.12">
  <POU Name="TestMotion" Id="{f5ec753e-2f53-4143-ab85-291d0817da2d}" SpecialFunc="None">
    <Declaration><![CDATA[FUNCTION_BLOCK TestMotion
VAR_IN_OUT
	axis  : ARRAY [XP .. XM] OF AxisGroup;
	nextInstruct, abortRequest, resetRequest, startRequest, stopRequest: BOOL;
	homeRequest : BYTE;
		
	//statemachine
	stateLVL1 : INT;
	
END_VAR
VAR_INPUT

	speed : LREAL;	

END_VAR
VAR_OUTPUT
END_VAR
VAR
	//testvar
	//test : INT;
	xorResult : BOOL; //used in tracking
	
	//state-machine
	stateLVL2 : INT;
	initStateLVL2 : BOOL;
	motionBusy : BOOL;
	
	//Direction
	directionXP : BOOL;
	
	//counter
	i 	: INT :=0;
	//j	: INT :=0;
	

END_VAR
VAR CONSTANT
	BRAKE_OFF_C		: BOOL	:= TRUE;
	BRAKE_ON_C		: BOOL	:= FALSE;
	HOME_VEL_C		: LREAL	:= 30;
	CALIBRATE_VEL_C	: LREAL	:= 200;//60;
	POSITION_VEL_C	: LREAL := 300;
	POS_START_C		: LREAL := 0;
	POS_END_C		: LREAL := 750;
	HOMEOFFSET_XP_C	: LREAL	:= (POS_START_C+35);
	HOMEOFFSET_XM_C	: LREAL	:= (POS_END_C-84);
	
	//SIZE_HALL_SW_C 	: LREAL := SIZEOF(GVL.hallPosCalXP);
	
	//For indexing axis
	XP : INT := 0;
	XM : INT := 1;
END_VAR]]></Declaration>
    <Implementation>
      <ST><![CDATA[axis[XP].axisRef.ReadStatus();
axis[XM].axisRef.ReadStatus();


//reset input
IF abortRequest THEN
	abortRequest := FALSE;
	stateLVL1 := -1; 
END_IF
IF resetRequest THEN
	resetRequest := FALSE;
	stateLVL1 := 0;
END_IF


CASE stateLVL1 OF
	-1: //Abort state. Disable movement
		axis[XP].mcPower(Axis := axis[XP].axisRef, Enable := TRUE, Enable_Positive := FALSE, Enable_Negative := FALSE);
		axis[XM].mcPower(Axis := axis[XM].axisRef, Enable := TRUE, Enable_Positive := FALSE, Enable_Negative := FALSE);	
		axis[XP].mcHome(Axis := axis[XP].axisRef, Execute := FALSE);
		axis[XM].mcHome(Axis := axis[XP].axisRef, Execute := FALSE);
		axis[XP].mcReset(Axis := axis[XP].axisRef, Execute := FALSE);
		axis[XM].mcReset(Axis := axis[XM].axisRef, Execute := FALSE);
		axis[XP].brake := BRAKE_ON_C;
		axis[XM].brake := BRAKE_ON_C;
		nextInstruct := FALSE;
		GVL.fbWaitTimer(IN:=FALSE);
		
	0: //reset state
		motionBusy := FALSE;
		initStateLVL2 := FALSE;
		nextInstruct := FALSE;
		axis[XP].mcReset(Axis := axis[XP].axisRef, Execute := TRUE, ErrorID => axis[XP].errorID);
		axis[XM].mcReset(Axis := axis[XM].axisRef, Execute := TRUE, ErrorID => axis[XM].errorID);
		IF axis[XP].mcReset.Error OR axis[XM].mcReset.Error THEN
			axis[XP].mcPower(Axis := axis[XP].axisRef, Enable := TRUE, Enable_Positive := FALSE, Enable_Negative := FALSE);
			axis[XM].mcPower(Axis := axis[XM].axisRef, Enable := TRUE, Enable_Positive := FALSE, Enable_Negative := FALSE);
			axis[XP].brake := BRAKE_ON_C;
			axis[XM].brake := BRAKE_ON_C;
			stateLVL1 		:= -1; //go to stop state
			stateLVL2		:=0;

			//Should report an error flag go to error handle state
		ELSIF axis[XP].mcReset.Done AND axis[XM].mcReset.Done THEN
			axis[XP].mcPower(Axis := axis[XP].axisRef, Enable := TRUE, Enable_Positive := TRUE, Enable_Negative := TRUE);
			axis[XM].mcPower(Axis := axis[XM].axisRef, Enable := TRUE, Enable_Positive := TRUE, Enable_Negative := TRUE);
			axis[XP].mcReset(Axis := axis[XP].axisRef, Execute := FALSE);
			axis[XM].mcReset(Axis := axis[XM].axisRef, Execute := FALSE);
			axis[XP].brake := BRAKE_OFF_C;
			axis[XM].brake := BRAKE_OFF_C;
			axis[XP].mcStop(Axis:=axis[XP].axisRef, Execute:=FALSE);
			axis[XM].mcStop(Axis:=axis[XM].axisRef, Execute:=FALSE);
			stateLVL1 	:= 100; //go to stop state
			stateLVL2	:=0;				
		END_IF

		
	100: //stop state
		axis[XP].mcMoveAbs(Axis := axis[XP].axisRef, Execute := FALSE);
		axis[XM].mcMoveAbs(Axis := axis[XM].axisRef, Execute := FALSE);
		axis[XP].mcJog(Axis:=axis[XP].axisRef, JogForward:=FALSE, JogBackwards:=FALSE);
		axis[XM].mcJog(Axis:=axis[XM].axisRef, JogForward:=FALSE, JogBackwards:=FALSE);
		axis[XP].mcHome(Axis := axis[XP].axisRef, Execute := FALSE);
		axis[XM].mcHome(Axis := axis[XP].axisRef, Execute := FALSE);
		stateLVL2 := 0;
		GVL.fbWaitTimer(IN:=FALSE);

	
	
	400: //Homing start for both blades
		homeShutter();
		IF motionBusy = FALSE THEN
			stateLVL1:=100;
		END_IF


	//States higher than 400 requires HOMING ROUTINE to be ran first.
	//////////////////////////////////////////////////////////////////////////////////////////////
	//Basic Motions
	//////////////////////////////////////////////////////////////////////////////////////////////	

	1000: //Open shutter
		openShutter();
		IF motionBusy = FALSE THEN
			stateLVL1:=100;
		END_IF
		
	1100: //Close shutter towards X+ side. 
		closeShutterPlus();
		IF motionBusy = FALSE THEN
			stateLVL1:=100;
		END_IF
		
	1200: //Close shutter towards X- side. 
		closeShutterMinus();
		IF motionBusy = FALSE THEN
			stateLVL1:=100;
		END_IF
		
	1300: //AxisXP absolute move
		axis[XP].mcMoveAbs(Axis:=axis[XP].axisRef, Position:=GVL.setPosition, Velocity:=speed, Execute:=TRUE);
		IF axis[XP].mcMoveAbs.Done THEN
			axis[XP].mcMoveAbs(Axis:=axis[XP].axisRef, Execute:=FALSE);
			stateLVL1 := 100;
		END_IF

	1400: //AxisXM move absolute
		axis[XM].mcMoveAbs(Axis:=axis[XM].axisRef, Position:=GVL.setPosition, Velocity:=speed, Execute:=TRUE);
		IF axis[XM].mcMoveAbs.Done THEN
			axis[XM].mcMoveAbs(Axis:=axis[XM].axisRef, Execute:=FALSE);
			stateLVL1 := 100;
		END_IF

	1500: //AxisXP Jog Forward
		axis[XP].mcJog(Axis:=axis[XP].axisRef, JogForward:=TRUE, JogBackwards:=FALSE, Mode:=MC_JOGMODE_STANDARD_SLOW);
	
	1600: //AxisXP Jog Backward
		axis[XP].mcJog(Axis:=axis[XP].axisRef, JogForward:=FALSE, JogBackwards:=TRUE, Mode:=MC_JOGMODE_STANDARD_SLOW);
		
	1700: //AxisXM Jog Backward
		axis[XM].mcJog(Axis:=axis[XM].axisRef, JogForward:=TRUE, JogBackwards:=FALSE, Mode:=MC_JOGMODE_STANDARD_SLOW);
	
	1800: //AxisXM Jog Forward
		axis[XM].mcJog(Axis:=axis[XM].axisRef, JogForward:=FALSE, JogBackwards:=TRUE, Mode:=MC_JOGMODE_STANDARD_SLOW);

	
	//////////////////////////////////////////////////////////////////////////////////////////////
	//Motion for visit - NORMAL MODE
	//////////////////////////////////////////////////////////////////////////////////////////////	

	2000: //Normal Visit. Put both blades in position at 0 mm - Shutter closed
		axis[XP].mcMoveAbs(Axis:=axis[XP].axisRef, Position:=POS_START_C, Velocity:=POSITION_VEL_C, Execute:=TRUE);
		IF axis[XP].mcMoveAbs.Done THEN
			axis[XP].mcMoveAbs(Axis:=axis[XP].axisRef, Execute:=FALSE);
			axis[XM].mcMoveAbs(Axis:=axis[XM].axisRef, Position:=POS_START_C, Velocity:=POSITION_VEL_C, Execute:=TRUE);
			IF  axis[XM].mcMoveAbs.Done THEN
				axis[XM].mcMoveAbs(Axis:=axis[XM].axisRef, Execute:=FALSE);
				stateLVL1:=2010;
			END_IF	
		END_IF
	
	2010: //Normal Visit. Blade in position. Wait for input to continue.
		IF nextInstruct THEN
			nextInstruct:=FALSE;
			stateLVL1:=2100;
		END_IF
		
	2100: //Normal Visit. Visit 1 sequence - axisXM travels to end of X- side after set time elapsed - Shutter open
		GVL.fbWaitTimer(IN:=TRUE, PT:=GVL.expoTime,);
		axis[XM].mcMoveAbs(Axis:=axis[XM].axisRef, Position:=POS_END_C, Velocity:=speed, Execute:=TRUE);
		IF axis[XM].mcMoveAbs.Done AND GVL.fbWaitTimer.Q THEN
			GVL.fbWaitTimer(IN:=FALSE);
			axis[XM].mcMoveAbs(Axis:=axis[XM].axisRef, Execute:=FALSE);
			stateLVL1:=2110;
		END_IF

	2110: //Normal Visit. Visit 1 sequence - axisXP travels to end of X- side - Shutter close
		axis[XP].mcMoveAbs(Axis:=axis[XP].axisRef, Position:=POS_END_C, Velocity:=speed, Execute:=TRUE);
		IF axis[XP].mcMoveAbs.Done THEN
			axis[XP].mcMoveAbs(Axis:=axis[XP].axisRef, Execute:=FALSE);
			stateLVL1:=2120;
		END_IF
		
	2120: //Normal Visit. Pause at the end of first visit. Wait for input to continue
		GVL.fbWaitTimer(IN:=TRUE, PT:=T#2S);
		IF nextInstruct OR GVL.fbWaitTimer.Q THEN
			GVL.fbWaitTimer(IN:=FALSE);
			nextInstruct:=FALSE;
			stateLVL1:=2200;
		END_IF
	
	2200: //Normal Visit. Visit 2 sequence - axisXP travels to X+ side - Shutter open
		GVL.fbWaitTimer(IN:=TRUE, PT:=GVL.expoTime,);
		axis[XP].mcMoveAbs(Axis:=axis[XP].axisRef, Position:=POS_START_C, Velocity:=speed, Execute:=TRUE);
		IF axis[XP].mcMoveAbs.Done AND GVL.fbWaitTimer.Q THEN
			GVL.fbWaitTimer(IN:=FALSE);
			axis[XP].mcMoveAbs(Axis:=axis[XP].axisRef, Execute:=FALSE);
			stateLVL1:=2210;
		END_IF
		
	2210: //Normal Visit. Visit 2 sequence - axisXM travels to X+ side - Shutter close
		axis[XM].mcMoveAbs(Axis:=axis[XM].axisRef, Position:=POS_START_C, Velocity:=speed, Execute:=TRUE);
		IF axis[XM].mcMoveAbs.Done THEN
			axis[XM].mcMoveAbs(Axis:=axis[XM].axisRef, Execute:=FALSE);
			stateLVL1:=100;
		END_IF
	

	//////////////////////////////////////////////////////////////////////////////////////////////
	//Cycler -- for use in testing shutter cycle
	//////////////////////////////////////////////////////////////////////////////////////////////
		
	3100: //Cycler sequence 
		cycler();
		IF motionBusy = FALSE THEN
			stateLVL1:=100;
		END_IF	

	//////////////////////////////////////////////////////////////////////////////////////////////
	//Soft Calibration
	//////////////////////////////////////////////////////////////////////////////////////////////

	8000: //Clear previous Calibration value
		calibrateXP();
		calibrateXM();
		//openShutter();
		IF motionBusy = FALSE THEN
			stateLVL1:=100;
		END_IF
		
	
		
	12345:
		travellingSlit();
		IF motionBusy = FALSE THEN
			stateLVL1:=100;
		END_IF

END_CASE

(*
//Need to rewrite this so that it will work with 2 axis running.------------------------------------------
IF stateLVL1 <> 400 THEN
	
	//Actual Position Calc AxisXP
	FOR i:=GVL.HALL_LL_XP_C TO GVL.HALL_UL_XP_C BY 1 DO
		axis[XP].hallSigCal_rtrig[i](CLK:=GVL.hallSwitch[i]);
		axis[XP].hallSigCal_ftrig[i](CLK:=GVL.hallSwitch[i]);
		IF axis[XP].hallSigCal_rtrig[i].Q OR axis[XP].hallSigCal_ftrig[i].Q THEN
			
				GVL.hallSequence.0 := axis[XP].hallSigCal_rtrig[0].Q OR axis[XP].hallSigCal_ftrig[0].Q;
				GVL.hallSequence.1 := axis[XP].hallSigCal_rtrig[1].Q OR axis[XP].hallSigCal_ftrig[1].Q;
				GVL.hallSequence.2 := axis[XP].hallSigCal_rtrig[2].Q OR axis[XP].hallSigCal_ftrig[2].Q;
				GVL.hallSequence.3 := axis[XP].hallSigCal_rtrig[3].Q OR axis[XP].hallSigCal_ftrig[3].Q;
				GVL.hallSequence.4 := axis[XP].hallSigCal_rtrig[4].Q OR axis[XP].hallSigCal_ftrig[4].Q;
				GVL.hallSequence.5 := axis[XP].hallSigCal_rtrig[5].Q OR axis[XP].hallSigCal_ftrig[5].Q;
				GVL.hallSequence.6 := axis[XP].hallSigCal_rtrig[6].Q OR axis[XP].hallSigCal_ftrig[6].Q;
				GVL.hallSequence.7 := axis[XP].hallSigCal_rtrig[7].Q OR axis[XP].hallSigCal_ftrig[7].Q;
				GVL.hallSequence.8 := axis[XP].hallSigCal_rtrig[8].Q OR axis[XP].hallSigCal_ftrig[8].Q;
				GVL.hallSequence.9 := axis[XP].hallSigCal_rtrig[9].Q OR axis[XP].hallSigCal_ftrig[9].Q;
				GVL.hallSequence.10 := axis[XP].hallSigCal_rtrig[10].Q OR axis[XP].hallSigCal_ftrig[10].Q;
				GVL.hallSequence.11 := axis[XP].hallSigCal_rtrig[11].Q OR axis[XP].hallSigCal_ftrig[11].Q;
				GVL.hallSequence.12 := axis[XP].hallSigCal_rtrig[12].Q OR axis[XP].hallSigCal_ftrig[12].Q;
				GVL.hallSequence.13 := axis[XP].hallSigCal_rtrig[13].Q OR axis[XP].hallSigCal_ftrig[13].Q;
				GVL.hallSequence.14 := axis[XP].hallSigCal_rtrig[14].Q OR axis[XP].hallSigCal_ftrig[14].Q;			
			
			IF (GVL.hallSequence.0 XOR GVL.hallSequence.1 XOR GVL.hallSequence.2 XOR GVL.hallSequence.3 XOR GVL.hallSequence.4 XOR
				GVL.hallSequence.5 XOR GVL.hallSequence.6 XOR GVL.hallSequence.7 XOR GVL.hallSequence.8 XOR GVL.hallSequence.9 XOR
				GVL.hallSequence.10 XOR GVL.hallSequence.11 XOR GVL.hallSequence.12 XOR GVL.hallSequence.13 XOR GVL.hallSequence.14) THEN
				axis[XP].seqToCompare := GVL.hallSequence;
				
				GVL.testINT := GVL.testINT +1;
				
			ELSE
				GVL.testINT2 := GVL.testINT2 +1;
				IF axis[XM].axisRef.status.PositiveDirection THEN
					axis[XP].seqToCompare := (GVL.hallSequence XOR axis[XM].hallSequence[1, axis[XM].seqCount]);	
				ELSIF axis[XM].axisRef.status.NegativeDirection THEN
					axis[XP].seqToCompare := (GVL.hallSequence XOR axis[XM].hallSequence[0, axis[XM].seqCount]);		
				ELSE
					; //PUT ERROR CODE HERE
				END_IF		
			END_IF	
			
			IF axis[XP].axisRef.status.PositiveDirection AND axis[XP].hallSequence[0, axis[XP].seqCount] = axis[XP].seqToCompare THEN
				axis[XP].hallPosAct := axis[XP].hallPosCal[0, i, axis[XP].tripCount[i]];
				axis[XP].tripCount[i] := axis[XP].tripCount[i] + 1;	
				axis[XP].seqCount := axis[XP].seqCount + 1;
				
			END_IF
			IF axis[XP].axisRef.status.NegativeDirection AND axis[XP].hallSequence[1, axis[XP].seqCount] = axis[XP].seqToCompare THEN
				axis[XP].hallPosAct := axis[XP].hallPosCal[1, i, axis[XP].tripCount[i]];
				axis[XP].tripCount[i] := axis[XP].tripCount[i] - 1;	
				axis[XP].seqCount := axis[XP].seqCount - 1;
			END_IF
			
		END_IF
	END_FOR
	//Actual Position Calc AxisXM
	FOR i:=GVL.HALL_LL_XM_C TO GVL.HALL_UL_XM_C BY 1 DO
		axis[XM].hallSigCal_rtrig[i](CLK:=GVL.hallSwitch[i]);
		axis[XM].hallSigCal_ftrig[i](CLK:=GVL.hallSwitch[i]);
		IF axis[XM].hallSigCal_rtrig[i].Q OR axis[XM].hallSigCal_ftrig[i].Q THEN
			
				GVL.hallSequence.0 := axis[XM].hallSigCal_rtrig[0].Q OR axis[XM].hallSigCal_ftrig[0].Q;
				GVL.hallSequence.1 := axis[XM].hallSigCal_rtrig[1].Q OR axis[XM].hallSigCal_ftrig[1].Q;
				GVL.hallSequence.2 := axis[XM].hallSigCal_rtrig[2].Q OR axis[XM].hallSigCal_ftrig[2].Q;
				GVL.hallSequence.3 := axis[XM].hallSigCal_rtrig[3].Q OR axis[XM].hallSigCal_ftrig[3].Q;
				GVL.hallSequence.4 := axis[XM].hallSigCal_rtrig[4].Q OR axis[XM].hallSigCal_ftrig[4].Q;
				GVL.hallSequence.5 := axis[XM].hallSigCal_rtrig[5].Q OR axis[XM].hallSigCal_ftrig[5].Q;
				GVL.hallSequence.6 := axis[XM].hallSigCal_rtrig[6].Q OR axis[XM].hallSigCal_ftrig[6].Q;
				GVL.hallSequence.7 := axis[XM].hallSigCal_rtrig[7].Q OR axis[XM].hallSigCal_ftrig[7].Q;
				GVL.hallSequence.8 := axis[XM].hallSigCal_rtrig[8].Q OR axis[XM].hallSigCal_ftrig[8].Q;
				GVL.hallSequence.9 := axis[XM].hallSigCal_rtrig[9].Q OR axis[XM].hallSigCal_ftrig[9].Q;
				GVL.hallSequence.10 := axis[XM].hallSigCal_rtrig[10].Q OR axis[XM].hallSigCal_ftrig[10].Q;
				GVL.hallSequence.11 := axis[XM].hallSigCal_rtrig[11].Q OR axis[XM].hallSigCal_ftrig[11].Q;
				GVL.hallSequence.12 := axis[XM].hallSigCal_rtrig[12].Q OR axis[XM].hallSigCal_ftrig[12].Q;
				GVL.hallSequence.13 := axis[XM].hallSigCal_rtrig[13].Q OR axis[XM].hallSigCal_ftrig[13].Q;
				GVL.hallSequence.14 := axis[XM].hallSigCal_rtrig[14].Q OR axis[XM].hallSigCal_ftrig[14].Q;			
			
			IF (GVL.hallSequence.0 XOR GVL.hallSequence.1 XOR GVL.hallSequence.2 XOR GVL.hallSequence.3 XOR GVL.hallSequence.4 XOR
				GVL.hallSequence.5 XOR GVL.hallSequence.6 XOR GVL.hallSequence.7 XOR GVL.hallSequence.8 XOR GVL.hallSequence.9 XOR
				GVL.hallSequence.10 XOR GVL.hallSequence.11 XOR GVL.hallSequence.12 XOR GVL.hallSequence.13 XOR GVL.hallSequence.14) THEN
				axis[XM].seqToCompare := GVL.hallSequence;
				
				GVL.testINT := GVL.testINT +1;
				
			ELSE
				GVL.testINT2 := GVL.testINT2 +1;
				IF axis[XP].axisRef.status.PositiveDirection THEN
					axis[XM].seqToCompare := (GVL.hallSequence XOR axis[XP].hallSequence[1, axis[XP].seqCount]);	
				ELSIF axis[XP].axisRef.status.NegativeDirection THEN
					axis[XM].seqToCompare := (GVL.hallSequence XOR axis[XP].hallSequence[0, axis[XP].seqCount]);		
				ELSE
					; //PUT ERROR CODE HERE
				END_IF		
			END_IF	
				
			IF axis[XM].axisRef.status.PositiveDirection AND axis[XM].hallSequence[0, axis[XM].seqCount] = axis[XM].seqToCompare THEN
				axis[XM].hallPosAct := axis[XM].hallPosCal[0, i, axis[XM].tripCount[i]];
				axis[XM].tripCount[i] := axis[XM].tripCount[i] - 1;	
				axis[XM].seqCount := axis[XM].seqCount - 1;
				
			END_IF
			IF axis[XM].axisRef.status.NegativeDirection AND axis[XM].hallSequence[1, axis[XM].seqCount] = axis[XM].seqToCompare THEN
				axis[XM].hallPosAct := axis[XM].hallPosCal[1, i, axis[XM].tripCount[i]];
				axis[XM].tripCount[i] := axis[XM].tripCount[i] + 1;	
				axis[XM].seqCount := axis[XM].seqCount + 1;
			END_IF
		END_IF
	END_FOR

ELSE
	
	FOR i:=GVL.HALL_LL_XP_C TO GVL.HALL_UL_XM_C BY 1 DO
			axis[XP].tripCount[i] := 0;	
			axis[XM].tripCount[i] := 0;
	END_FOR
	
END_IF
*)

tracking();]]></ST>
    </Implementation>
    <Action Name="calibrateXM" Id="{f55b06c7-6108-4c5a-8395-ce4a40ab5ee7}">
      <Implementation>
        <ST><![CDATA[IF initStateLVL2 = FALSE THEN
	initStateLVL2 := TRUE;
	stateLVL2 :=9010;
	motionBusy := TRUE;
END_IF	

CASE stateLVL2 OF
	
	9010: //Clear previous Calibration value
		FOR i:=0 TO GVL.tripCount_C BY 1 DO
			axis[XM].hallPosCal[0,i]:=0;
			axis[XM].hallPosCal[1,i]:=0;
		END_FOR
		axis[XM].tripCount := 0;	
		stateLVL2:=9020;
		
	9020: //Put Shutter in Open Position
		axis[XP].mcMoveAbs(Axis:=axis[XP].axisRef, Position:= POS_START_C, Velocity:=POSITION_VEL_C, Execute:=TRUE);
		axis[XM].mcMoveAbs(Axis:=axis[XM].axisRef, Position:= POS_END_C, Velocity:=POSITION_VEL_C, Execute:=TRUE);
		IF axis[XP].mcMoveAbs.Done AND axis[XM].mcMoveAbs.Done THEN
			axis[XP].mcMoveAbs(Axis:=axis[XP].axisRef, Execute:=FALSE);
			axis[XM].mcMoveAbs(Axis:=axis[XM].axisRef, Execute:=FALSE);
			stateLVL2:=9030;
		END_IF
		
		//This section is required to get rid of false trigger when system starts up
		FOR i:=GVL.hallLowerLimit_C TO GVL.hallUpperLimit_C BY 1 DO
			axis[XM].hallSigCal_rtrig[i](CLK:=GVL.hallSwitch[i]);
			axis[XM].hallSigCal_ftrig[i](CLK:=GVL.hallSwitch[i]);
			IF axis[XM].hallSigCal_rtrig[i].Q OR axis[XM].hallSigCal_ftrig[i].Q THEN
				; //do nothing
			END_IF
		END_FOR	
	
	9030: //Calibrate AxisXM twoards X+ side.
		//record hall trips at rising and falling edge
		FOR i:=GVL.hallLowerLimit_C TO GVL.hallUpperLimit_C BY 1 DO
			axis[XM].hallSigCal_rtrig[i](CLK:=GVL.hallSwitch[i]);
			axis[XM].hallSigCal_ftrig[i](CLK:=GVL.hallSwitch[i]);
			IF axis[XM].hallSigCal_rtrig[i].Q OR axis[XM].hallSigCal_ftrig[i].Q THEN	
				
				axis[XM].hallSequence[GVL.dirNeg_C, axis[XM].tripCount].0 := axis[XM].hallSigCal_rtrig[0].Q OR axis[XM].hallSigCal_ftrig[0].Q;
				axis[XM].hallSequence[GVL.dirNeg_C, axis[XM].tripCount].1 := axis[XM].hallSigCal_rtrig[1].Q OR axis[XM].hallSigCal_ftrig[1].Q;
				axis[XM].hallSequence[GVL.dirNeg_C, axis[XM].tripCount].2 := axis[XM].hallSigCal_rtrig[2].Q OR axis[XM].hallSigCal_ftrig[2].Q;
				axis[XM].hallSequence[GVL.dirNeg_C, axis[XM].tripCount].3 := axis[XM].hallSigCal_rtrig[3].Q OR axis[XM].hallSigCal_ftrig[3].Q;
				axis[XM].hallSequence[GVL.dirNeg_C, axis[XM].tripCount].4 := axis[XM].hallSigCal_rtrig[4].Q OR axis[XM].hallSigCal_ftrig[4].Q;
				axis[XM].hallSequence[GVL.dirNeg_C, axis[XM].tripCount].5 := axis[XM].hallSigCal_rtrig[5].Q OR axis[XM].hallSigCal_ftrig[5].Q;
				axis[XM].hallSequence[GVL.dirNeg_C, axis[XM].tripCount].6 := axis[XM].hallSigCal_rtrig[6].Q OR axis[XM].hallSigCal_ftrig[6].Q;
				axis[XM].hallSequence[GVL.dirNeg_C, axis[XM].tripCount].7 := axis[XM].hallSigCal_rtrig[7].Q OR axis[XM].hallSigCal_ftrig[7].Q;
				axis[XM].hallSequence[GVL.dirNeg_C, axis[XM].tripCount].8 := axis[XM].hallSigCal_rtrig[8].Q OR axis[XM].hallSigCal_ftrig[8].Q;
				axis[XM].hallSequence[GVL.dirNeg_C, axis[XM].tripCount].9 := axis[XM].hallSigCal_rtrig[9].Q OR axis[XM].hallSigCal_ftrig[9].Q;
				axis[XM].hallSequence[GVL.dirNeg_C, axis[XM].tripCount].10 := axis[XM].hallSigCal_rtrig[10].Q OR axis[XM].hallSigCal_ftrig[10].Q;
				axis[XM].hallSequence[GVL.dirNeg_C, axis[XM].tripCount].11 := axis[XM].hallSigCal_rtrig[11].Q OR axis[XM].hallSigCal_ftrig[11].Q;
				axis[XM].hallSequence[GVL.dirNeg_C, axis[XM].tripCount].12 := axis[XM].hallSigCal_rtrig[12].Q OR axis[XM].hallSigCal_ftrig[12].Q;
				axis[XM].hallSequence[GVL.dirNeg_C, axis[XM].tripCount].13 := axis[XM].hallSigCal_rtrig[13].Q OR axis[XM].hallSigCal_ftrig[13].Q;
				axis[XM].hallSequence[GVL.dirNeg_C, axis[XM].tripCount].14 := axis[XM].hallSigCal_rtrig[14].Q OR axis[XM].hallSigCal_ftrig[14].Q;
				
				axis[XM].hallPosCal[GVL.dirNeg_C, axis[XM].tripCount] := axis[XM].axisRef.NcToPlc.ActPos;
				
				axis[XM].tripCount := axis[XM].tripCount + 1;		

			END_IF
		END_FOR

		//start moving axisXP towards x+ side
		axis[XM].mcMoveAbs(Axis:=axis[XM].axisRef, Position:=POS_START_C, Velocity:=CALIBRATE_VEL_C, Execute:=TRUE);
		IF axis[XM].mcMoveAbs.Done THEN
			axis[XM].mcMoveAbs(Axis:=axis[XP].axisRef, Execute:=FALSE);
			stateLVL2:= 9040;
		END_IF
	
	
	9040: //Calibrate AxisXM twoards X- side.
		//record hall trips at rising and falling edge
		FOR i:=GVL.hallLowerLimit_C TO GVL.hallUpperLimit_C BY 1 DO
			axis[XM].hallSigCal_rtrig[i](CLK:=GVL.hallSwitch[i]);
			axis[XM].hallSigCal_ftrig[i](CLK:=GVL.hallSwitch[i]);
			IF axis[XM].hallSigCal_rtrig[i].Q OR axis[XM].hallSigCal_ftrig[i].Q THEN	
				
				axis[XM].hallSequence[GVL.dirPos_C, axis[XM].tripCount].0 := axis[XM].hallSigCal_rtrig[0].Q OR axis[XM].hallSigCal_ftrig[0].Q;
				axis[XM].hallSequence[GVL.dirPos_C, axis[XM].tripCount].1 := axis[XM].hallSigCal_rtrig[1].Q OR axis[XM].hallSigCal_ftrig[1].Q;
				axis[XM].hallSequence[GVL.dirPos_C, axis[XM].tripCount].2 := axis[XM].hallSigCal_rtrig[2].Q OR axis[XM].hallSigCal_ftrig[2].Q;
				axis[XM].hallSequence[GVL.dirPos_C, axis[XM].tripCount].3 := axis[XM].hallSigCal_rtrig[3].Q OR axis[XM].hallSigCal_ftrig[3].Q;
				axis[XM].hallSequence[GVL.dirPos_C, axis[XM].tripCount].4 := axis[XM].hallSigCal_rtrig[4].Q OR axis[XM].hallSigCal_ftrig[4].Q;
				axis[XM].hallSequence[GVL.dirPos_C, axis[XM].tripCount].5 := axis[XM].hallSigCal_rtrig[5].Q OR axis[XM].hallSigCal_ftrig[5].Q;
				axis[XM].hallSequence[GVL.dirPos_C, axis[XM].tripCount].6 := axis[XM].hallSigCal_rtrig[6].Q OR axis[XM].hallSigCal_ftrig[6].Q;
				axis[XM].hallSequence[GVL.dirPos_C, axis[XM].tripCount].7 := axis[XM].hallSigCal_rtrig[7].Q OR axis[XM].hallSigCal_ftrig[7].Q;
				axis[XM].hallSequence[GVL.dirPos_C, axis[XM].tripCount].8 := axis[XM].hallSigCal_rtrig[8].Q OR axis[XM].hallSigCal_ftrig[8].Q;
				axis[XM].hallSequence[GVL.dirPos_C, axis[XM].tripCount].9 := axis[XM].hallSigCal_rtrig[9].Q OR axis[XM].hallSigCal_ftrig[9].Q;
				axis[XM].hallSequence[GVL.dirPos_C, axis[XM].tripCount].10 := axis[XM].hallSigCal_rtrig[10].Q OR axis[XM].hallSigCal_ftrig[10].Q;
				axis[XM].hallSequence[GVL.dirPos_C, axis[XM].tripCount].11 := axis[XM].hallSigCal_rtrig[11].Q OR axis[XM].hallSigCal_ftrig[11].Q;
				axis[XM].hallSequence[GVL.dirPos_C, axis[XM].tripCount].12 := axis[XM].hallSigCal_rtrig[12].Q OR axis[XM].hallSigCal_ftrig[12].Q;
				axis[XM].hallSequence[GVL.dirPos_C, axis[XM].tripCount].13 := axis[XM].hallSigCal_rtrig[13].Q OR axis[XM].hallSigCal_ftrig[13].Q;
				axis[XM].hallSequence[GVL.dirPos_C, axis[XM].tripCount].14 := axis[XM].hallSigCal_rtrig[14].Q OR axis[XM].hallSigCal_ftrig[14].Q;
			
				axis[XM].hallPosCal[GVL.dirPos_C, axis[XM].tripCount] := axis[XM].axisRef.NcToPlc.ActPos;
				axis[XM].tripCount := axis[XM].tripCount - 1;	
			END_IF
		END_FOR
	
		//start moving axisXP towards x- side
		axis[XM].mcMoveAbs(Axis:=axis[XM].axisRef, Position:=POS_END_C, Velocity:=CALIBRATE_VEL_C, Execute:=TRUE);
		IF axis[XM].mcMoveAbs.Done THEN
			axis[XM].mcMoveAbs(Axis:=axis[XM].axisRef, Execute:=FALSE);
			stateLVL2 := 9050;
		END_IF

	9050: //End action
		initStateLVL2 := FALSE;
		stateLVL2 := 0;
		motionBusy := FALSE;


END_CASE
]]></ST>
      </Implementation>
    </Action>
    <Action Name="calibrateXP" Id="{79108831-3b18-418a-a130-e890c3b4b0b4}">
      <Implementation>
        <ST><![CDATA[IF initStateLVL2 = FALSE THEN
	initStateLVL2 := TRUE;
	stateLVL2 :=8010;
	motionBusy := TRUE;
END_IF	

CASE stateLVL2 OF

	8010: //Clear previous Calibration value
		FOR i:=0 TO GVL.tripCount_C BY 1 DO
			axis[XP].hallPosCal[0,i]:=0;
			axis[XP].hallPosCal[1,i]:=0;
		END_FOR
		axis[XP].tripCount := 0;	
		stateLVL2:=8020;
		
	8020: //Put Shutter in Open Position
		axis[XP].mcMoveAbs(Axis:=axis[XP].axisRef, Position:= POS_START_C, Velocity:=POSITION_VEL_C, Execute:=TRUE);
		axis[XM].mcMoveAbs(Axis:=axis[XM].axisRef, Position:= POS_END_C, Velocity:=POSITION_VEL_C, Execute:=TRUE);
		IF axis[XP].mcMoveAbs.Done AND axis[XM].mcMoveAbs.Done THEN
			axis[XP].mcMoveAbs(Axis:=axis[XP].axisRef, Execute:=FALSE);
			axis[XM].mcMoveAbs(Axis:=axis[XM].axisRef, Execute:=FALSE);
			stateLVL2:=8030;
		END_IF
		
		//This section is required to get rid of false trigger when system starts up
		FOR i:=GVL.hallLowerLimit_C TO GVL.hallUpperLimit_C BY 1 DO
			axis[XP].hallSigCal_rtrig[i](CLK:=GVL.hallSwitch[i]);
			axis[XP].hallSigCal_ftrig[i](CLK:=GVL.hallSwitch[i]);
			IF axis[XP].hallSigCal_rtrig[i].Q OR axis[XP].hallSigCal_ftrig[i].Q THEN
				; //do nothing
			END_IF
		END_FOR

	8030: //Calibrate AxisXP towards X- side.
		//record position of hall trips at rising and falling edge
		FOR i:=GVL.hallLowerLimit_C TO GVL.hallUpperLimit_C BY 1 DO
			axis[XP].hallSigCal_rtrig[i](CLK:=GVL.hallSwitch[i]);
			axis[XP].hallSigCal_ftrig[i](CLK:=GVL.hallSwitch[i]);
			IF axis[XP].hallSigCal_rtrig[i].Q OR axis[XP].hallSigCal_ftrig[i].Q THEN	

				axis[XP].hallSequence[GVL.dirPos_C, axis[XP].tripCount].0 := axis[XP].hallSigCal_rtrig[0].Q OR axis[XP].hallSigCal_ftrig[0].Q;
				axis[XP].hallSequence[GVL.dirPos_C, axis[XP].tripCount].1 := axis[XP].hallSigCal_rtrig[1].Q OR axis[XP].hallSigCal_ftrig[1].Q;
				axis[XP].hallSequence[GVL.dirPos_C, axis[XP].tripCount].2 := axis[XP].hallSigCal_rtrig[2].Q OR axis[XP].hallSigCal_ftrig[2].Q;
				axis[XP].hallSequence[GVL.dirPos_C, axis[XP].tripCount].3 := axis[XP].hallSigCal_rtrig[3].Q OR axis[XP].hallSigCal_ftrig[3].Q;
				axis[XP].hallSequence[GVL.dirPos_C, axis[XP].tripCount].4 := axis[XP].hallSigCal_rtrig[4].Q OR axis[XP].hallSigCal_ftrig[4].Q;
				axis[XP].hallSequence[GVL.dirPos_C, axis[XP].tripCount].5 := axis[XP].hallSigCal_rtrig[5].Q OR axis[XP].hallSigCal_ftrig[5].Q;
				axis[XP].hallSequence[GVL.dirPos_C, axis[XP].tripCount].6 := axis[XP].hallSigCal_rtrig[6].Q OR axis[XP].hallSigCal_ftrig[6].Q;
				axis[XP].hallSequence[GVL.dirPos_C, axis[XP].tripCount].7 := axis[XP].hallSigCal_rtrig[7].Q OR axis[XP].hallSigCal_ftrig[7].Q;
				axis[XP].hallSequence[GVL.dirPos_C, axis[XP].tripCount].8 := axis[XP].hallSigCal_rtrig[8].Q OR axis[XP].hallSigCal_ftrig[8].Q;
				axis[XP].hallSequence[GVL.dirPos_C, axis[XP].tripCount].9 := axis[XP].hallSigCal_rtrig[9].Q OR axis[XP].hallSigCal_ftrig[9].Q;
				axis[XP].hallSequence[GVL.dirPos_C, axis[XP].tripCount].10 := axis[XP].hallSigCal_rtrig[10].Q OR axis[XP].hallSigCal_ftrig[10].Q;
				axis[XP].hallSequence[GVL.dirPos_C, axis[XP].tripCount].11 := axis[XP].hallSigCal_rtrig[11].Q OR axis[XP].hallSigCal_ftrig[11].Q;
				axis[XP].hallSequence[GVL.dirPos_C, axis[XP].tripCount].12 := axis[XP].hallSigCal_rtrig[12].Q OR axis[XP].hallSigCal_ftrig[12].Q;
				axis[XP].hallSequence[GVL.dirPos_C, axis[XP].tripCount].13 := axis[XP].hallSigCal_rtrig[13].Q OR axis[XP].hallSigCal_ftrig[13].Q;
				axis[XP].hallSequence[GVL.dirPos_C, axis[XP].tripCount].14 := axis[XP].hallSigCal_rtrig[14].Q OR axis[XP].hallSigCal_ftrig[14].Q;

				axis[XP].hallPosCal[GVL.dirPos_C, axis[XP].tripCount] := axis[XP].axisRef.NcToPlc.ActPos;
				
				axis[XP].tripCount := axis[XP].tripCount + 1;		

			END_IF
		END_FOR
	
		//start moving axisXP towards x- side
		axis[XP].mcMoveAbs(Axis:=axis[XP].axisRef, Position:=POS_END_C, Velocity:=CALIBRATE_VEL_C, Execute:=TRUE);
		IF axis[XP].mcMoveAbs.Done THEN
			axis[XP].mcMoveAbs(Axis:=axis[XP].axisRef, Execute:=FALSE);
			stateLVL2:= 8040;
		END_IF
	
		
	8040: //Calibrate AxisXP towards X+ side.
		//record hall trips at rising and falling edge
		FOR i:=GVL.hallLowerLimit_C TO GVL.hallUpperLimit_C BY 1 DO
			axis[XP].hallSigCal_rtrig[i](CLK:=GVL.hallSwitch[i]);
			axis[XP].hallSigCal_ftrig[i](CLK:=GVL.hallSwitch[i]);
			IF axis[XP].hallSigCal_rtrig[i].Q OR axis[XP].hallSigCal_ftrig[i].Q THEN
				
				axis[XP].hallSequence[GVL.dirNeg_C, axis[XP].tripCount].0 := axis[XP].hallSigCal_rtrig[0].Q OR axis[XP].hallSigCal_ftrig[0].Q;
				axis[XP].hallSequence[GVL.dirNeg_C, axis[XP].tripCount].1 := axis[XP].hallSigCal_rtrig[1].Q OR axis[XP].hallSigCal_ftrig[1].Q;
				axis[XP].hallSequence[GVL.dirNeg_C, axis[XP].tripCount].2 := axis[XP].hallSigCal_rtrig[2].Q OR axis[XP].hallSigCal_ftrig[2].Q;
				axis[XP].hallSequence[GVL.dirNeg_C, axis[XP].tripCount].3 := axis[XP].hallSigCal_rtrig[3].Q OR axis[XP].hallSigCal_ftrig[3].Q;
				axis[XP].hallSequence[GVL.dirNeg_C, axis[XP].tripCount].4 := axis[XP].hallSigCal_rtrig[4].Q OR axis[XP].hallSigCal_ftrig[4].Q;
				axis[XP].hallSequence[GVL.dirNeg_C, axis[XP].tripCount].5 := axis[XP].hallSigCal_rtrig[5].Q OR axis[XP].hallSigCal_ftrig[5].Q;
				axis[XP].hallSequence[GVL.dirNeg_C, axis[XP].tripCount].6 := axis[XP].hallSigCal_rtrig[6].Q OR axis[XP].hallSigCal_ftrig[6].Q;
				axis[XP].hallSequence[GVL.dirNeg_C, axis[XP].tripCount].7 := axis[XP].hallSigCal_rtrig[7].Q OR axis[XP].hallSigCal_ftrig[7].Q;
				axis[XP].hallSequence[GVL.dirNeg_C, axis[XP].tripCount].8 := axis[XP].hallSigCal_rtrig[8].Q OR axis[XP].hallSigCal_ftrig[8].Q;
				axis[XP].hallSequence[GVL.dirNeg_C, axis[XP].tripCount].9 := axis[XP].hallSigCal_rtrig[9].Q OR axis[XP].hallSigCal_ftrig[9].Q;
				axis[XP].hallSequence[GVL.dirNeg_C, axis[XP].tripCount].10 := axis[XP].hallSigCal_rtrig[10].Q OR axis[XP].hallSigCal_ftrig[10].Q;
				axis[XP].hallSequence[GVL.dirNeg_C, axis[XP].tripCount].11 := axis[XP].hallSigCal_rtrig[11].Q OR axis[XP].hallSigCal_ftrig[11].Q;
				axis[XP].hallSequence[GVL.dirNeg_C, axis[XP].tripCount].12 := axis[XP].hallSigCal_rtrig[12].Q OR axis[XP].hallSigCal_ftrig[12].Q;
				axis[XP].hallSequence[GVL.dirNeg_C, axis[XP].tripCount].13 := axis[XP].hallSigCal_rtrig[13].Q OR axis[XP].hallSigCal_ftrig[13].Q;
				axis[XP].hallSequence[GVL.dirNeg_C, axis[XP].tripCount].14 := axis[XP].hallSigCal_rtrig[14].Q OR axis[XP].hallSigCal_ftrig[14].Q;
			
				axis[XP].hallPosCal[GVL.dirNeg_C, axis[XP].tripCount] := axis[XP].axisRef.NcToPlc.ActPos;
				axis[XP].tripCount := axis[XP].tripCount - 1;	
			END_IF
		END_FOR
	
		//start moving axisXP towards x+ side
		axis[XP].mcMoveAbs(Axis:=axis[XP].axisRef, Position:=POS_START_C, Velocity:=CALIBRATE_VEL_C, Execute:=TRUE);
		IF axis[XP].mcMoveAbs.Done THEN
			axis[XP].mcMoveAbs(Axis:=axis[XP].axisRef, Execute:=FALSE);
			stateLVL2 := 8050;
		END_IF
	
	8050: //End action
		initStateLVL2 := FALSE;
		stateLVL2 := 0;
		motionBusy := FALSE;

	
END_CASE]]></ST>
      </Implementation>
    </Action>
    <Action Name="closeShutterMinus" Id="{c8eebc4c-d2a0-42de-82dc-8e5673de86c8}">
      <Implementation>
        <ST><![CDATA[IF initStateLVL2 = FALSE THEN
	initStateLVL2 := TRUE;
	stateLVL2 :=1210;
	motionBusy := TRUE;
END_IF

CASE stateLVL2 OF
	
	1210://Close shutter towards X- side. AxisXM retracts to its HOME position (~750 mm)
		axis[XM].mcMoveAbs(Axis:=axis[XM].axisRef, Position:= POS_END_C, Velocity:=speed, Execute:=TRUE);
		IF axis[XM].mcMoveAbs.Done THEN
			axis[XM].mcMoveAbs(Axis:=axis[XM].axisRef, Execute:=FALSE);
			stateLVL2:=1220;
		END_IF
		
	1220: //Close shutter towards X- side. AxisXP extends to its DEPLOYED position
		axis[XP].mcMoveAbs(Axis:=axis[XP].axisRef, Position:= POS_END_C, Velocity:=speed, Execute:=TRUE);
		IF axis[XP].mcMoveAbs.Done THEN
			axis[XP].mcMoveAbs(Axis:=axis[XP].axisRef, Execute:=FALSE);
			stateLVL2 := 1230;
		END_IF
		
	1230: //End Action
		initStateLVL2 := FALSE;
		stateLVL2 := 0;
		motionBusy := FALSE;
END_CASE]]></ST>
      </Implementation>
    </Action>
    <Action Name="closeShutterPlus" Id="{43ef5e05-4492-480d-abe4-6a35baea3693}">
      <Implementation>
        <ST><![CDATA[IF initStateLVL2 = FALSE THEN
	initStateLVL2 := TRUE;
	stateLVL2 :=1110;
	motionBusy := TRUE;
END_IF

CASE stateLVL2 OF
	
	1110: //Close shutter towards X+ side. axisXP retracts to its HOME position
		axis[XP].mcMoveAbs(Axis:=axis[XP].axisRef, Position:= POS_START_C, Velocity:=speed, Execute:=TRUE);
		IF axis[XP].mcMoveAbs.Done THEN
			axis[XP].mcMoveAbs(Axis:=axis[XP].axisRef, Execute:=FALSE);
			stateLVL2:=1120;
		END_IF
		
	1120: //Close shutter towards X+ side. AxisXM extends to its DEPLOYED position 
		axis[XM].mcMoveAbs(Axis:=axis[XM].axisRef, Position:= POS_START_C, Velocity:=speed, Execute:=TRUE);
		IF axis[XM].mcMoveAbs.Done THEN
			axis[XM].mcMoveAbs(Axis:=axis[XM].axisRef, Execute:=FALSE);
			stateLVL2 := 1130;
		END_IF
	
	1130: //End Action
		initStateLVL2 := FALSE;
		stateLVL2 := 0;
		motionBusy := FALSE;
END_CASE
]]></ST>
      </Implementation>
    </Action>
    <Action Name="cycler" Id="{b3bb7fae-23b4-40ef-bb63-00745722aa1f}">
      <Implementation>
        <ST><![CDATA[IF initStateLVL2 = FALSE THEN
	initStateLVL2 := TRUE;
	stateLVL2 :=3010;
	motionBusy := TRUE;
END_IF	


CASE stateLVL2 OF
	3010: //Cycler sequence - axisXM travels to end of X- side after set time elapsed - Shutter open
		GVL.fbWaitTimer(IN:=TRUE, PT:=GVL.expoTime,);
		axis[XM].mcMoveAbs(Axis:=axis[XM].axisRef, Position:=POS_END_C, Velocity:=speed, Execute:=TRUE);
		IF axis[XM].mcMoveAbs.Done AND GVL.fbWaitTimer.Q THEN
			GVL.fbWaitTimer(IN:=FALSE);
			axis[XM].mcMoveAbs(Axis:=axis[XM].axisRef, Execute:=FALSE);
			stateLVL2:=3020;
			IF stopRequest THEN
				stopRequest:=FALSE;
				stateLVL2:=3070;
			END_IF
		END_IF


	3020: //Cycler sequence - axisXP travels to end of X- side - Shutter close
		axis[XP].mcMoveAbs(Axis:=axis[XP].axisRef, Position:=POS_END_C, Velocity:=speed, Execute:=TRUE);
		IF axis[XP].mcMoveAbs.Done THEN
			axis[XP].mcMoveAbs(Axis:=axis[XP].axisRef, Execute:=FALSE);
			stateLVL2:=3030;
			IF stopRequest THEN
				stopRequest:=FALSE;
				stateLVL2:=3070;
			END_IF
		END_IF
		
		
	3030: //Pause at the end of travel. Wait for input or timer to continue
		GVL.fbWaitTimer(IN:=TRUE, PT:=T#1S);
		IF nextInstruct OR GVL.fbWaitTimer.Q THEN
			GVL.fbWaitTimer(IN:=FALSE);
			nextInstruct:=FALSE;
			stateLVL2:=3040;
			IF stopRequest THEN
				stopRequest:=FALSE;
				stateLVL2:=3070;
			END_IF
		END_IF
	
	3040: //axisXP travels to X+ side - Shutter open
		GVL.fbWaitTimer(IN:=TRUE, PT:=GVL.expoTime,);
		axis[XP].mcMoveAbs(Axis:=axis[XP].axisRef, Position:=POS_START_C, Velocity:=speed, Execute:=TRUE);
		IF axis[XP].mcMoveAbs.Done AND GVL.fbWaitTimer.Q THEN
			GVL.fbWaitTimer(IN:=FALSE);
			axis[XP].mcMoveAbs(Axis:=axis[XP].axisRef, Execute:=FALSE);
			stateLVL2:=3050;
			IF stopRequest THEN
				stopRequest:=FALSE;
				stateLVL2:=3070;
			END_IF
		END_IF
		
	3050: //axisXM travels to X+ side - Shutter close
		axis[XM].mcMoveAbs(Axis:=axis[XM].axisRef, Position:=POS_START_C, Velocity:=speed, Execute:=TRUE);
		IF axis[XM].mcMoveAbs.Done THEN
			axis[XM].mcMoveAbs(Axis:=axis[XM].axisRef, Execute:=FALSE);
			stateLVL2:=3060;
			IF stopRequest THEN
				stopRequest:=FALSE;
				stateLVL2:=3070;
			END_IF
		END_IF
		
	3060: //Pause at the end of travel. Wait for input or timer to continue
		GVL.fbWaitTimer(IN:=TRUE, PT:=T#1S);
		IF nextInstruct OR GVL.fbWaitTimer.Q THEN
			GVL.fbWaitTimer(IN:=FALSE);
			nextInstruct:=FALSE;
			stateLVL2:=3010;
			IF stopRequest THEN
				stopRequest:=FALSE;
				stateLVL2:=3070;
			END_IF
		END_IF
		
	3070: //End Action
		initStateLVL2 := FALSE;
		stateLVL2 := 0;
		motionBusy := FALSE;
	
END_CASE]]></ST>
      </Implementation>
    </Action>
    <Action Name="homeShutter" Id="{d8e97ce7-cf41-48a3-a05c-454159a95cee}">
      <Implementation>
        <ST><![CDATA[IF initStateLVL2 = FALSE THEN
	initStateLVL2 := TRUE;
	stateLVL2 :=410;
	motionBusy := TRUE;
END_IF	

CASE stateLVL2 OF
	
	410: //Homing start for both blades
		axis[XP].mcHome(Axis := axis[XP].axisRef, Position := HOMEOFFSET_XP_C, bCalibrationCam := axis[XP].limitHome, Execute := TRUE);
		axis[XM].mcHome(Axis := axis[XM].axisRef, Position := HOMEOFFSET_XM_C, bCalibrationCam := axis[XM].limitHome, Execute := TRUE);
		IF axis[XP].mcHome.Done AND axis[XM].mcHome.Done THEN
			stateLVL2 := 420;
		END_IF
		
	420: //Homing running for both blades
		IF NOT axis[XP].mcHome.Error AND NOT axis[XM].mcHome.Error THEN
			axis[XP].mcHome(Axis := axis[XP].axisRef, Execute := FALSE);
			axis[XP].mcMoveAbs(Axis:=axis[XP].axisRef, Velocity:=HOME_VEL_C, Position:=POS_START_C, Execute:= TRUE,);
			axis[XM].mcHome(Axis := axis[XM].axisRef, Execute := FALSE);
			axis[XM].mcMoveAbs(Axis:=axis[XM].axisRef, Velocity:=HOME_VEL_C, Position:=POS_END_C, Execute:= TRUE);
			IF axis[XP].mcMoveAbs.Done AND axis[XM].mcMoveAbs.Done THEN
				axis[XP].mcMoveAbs(Axis:=axis[XP].axisRef, Execute:= FALSE);
				axis[XM].mcMoveAbs(Axis:=axis[XM].axisRef, Execute:= FALSE);
				stateLVL2 := 430;
			END_IF
		ELSE
			stateLVL2 := 430;
			//Should report an Error
		END_IF

	430: //End Action
		initStateLVL2 := FALSE;
		stateLVL2 := 0;
		motionBusy := FALSE;
END_CASE]]></ST>
      </Implementation>
    </Action>
    <Action Name="openShutter" Id="{f7febd62-8f52-4abd-992a-fedae8687624}">
      <Implementation>
        <ST><![CDATA[IF initStateLVL2 = FALSE THEN
	initStateLVL2 := TRUE;
	stateLVL2 :=1010;
	motionBusy := TRUE;
END_IF	

CASE stateLVL2 OF
	
	1010:
		motionBusy := TRUE;
		axis[XP].mcMoveAbs(Axis:=axis[XP].axisRef, Position:= POS_START_C, Velocity:=speed, Execute:=TRUE);
		axis[XM].mcMoveAbs(Axis:=axis[XM].axisRef, Position:= POS_END_C, Velocity:=speed, Execute:=TRUE);
		IF axis[XP].mcMoveAbs.Done AND axis[XM].mcMoveAbs.Done THEN
			axis[XP].mcMoveAbs(Axis:=axis[XP].axisRef, Execute:=FALSE);
			axis[XM].mcMoveAbs(Axis:=axis[XM].axisRef, Execute:=FALSE);
			stateLVL2 := 1020;
		END_IF	
		
	1020: //End action
		initStateLVL2 := FALSE;
		stateLVL2 := 0;
		motionBusy := FALSE;
		
END_CASE]]></ST>
      </Implementation>
    </Action>
    <Action Name="tracking" Id="{f70340f7-7c55-4a6a-973e-20bf0bb509c6}">
      <Implementation>
        <ST><![CDATA[

IF stateLVL1 <> 400 THEN
	
	//Actual Position Calc AxisXP
	FOR i:=GVL.hallLowerLimit_C TO GVL.hallUpperLimit_C BY 1 DO
		axis[XP].hallSigCal_rtrig[i](CLK:=GVL.hallSwitch[i]);
		axis[XP].hallSigCal_ftrig[i](CLK:=GVL.hallSwitch[i]);
		IF (axis[XP].hallSigCal_rtrig[i].Q OR axis[XP].hallSigCal_ftrig[i].Q) AND axis[XP].axisRef.Status.Moving THEN
			
				//put trigger status of each hall sensor into hallSequence for comparing;
				GVL.hallSequence.0 := axis[XP].hallSigCal_rtrig[0].Q OR axis[XP].hallSigCal_ftrig[0].Q;
				GVL.hallSequence.1 := axis[XP].hallSigCal_rtrig[1].Q OR axis[XP].hallSigCal_ftrig[1].Q;
				GVL.hallSequence.2 := axis[XP].hallSigCal_rtrig[2].Q OR axis[XP].hallSigCal_ftrig[2].Q;
				GVL.hallSequence.3 := axis[XP].hallSigCal_rtrig[3].Q OR axis[XP].hallSigCal_ftrig[3].Q;
				GVL.hallSequence.4 := axis[XP].hallSigCal_rtrig[4].Q OR axis[XP].hallSigCal_ftrig[4].Q;
				GVL.hallSequence.5 := axis[XP].hallSigCal_rtrig[5].Q OR axis[XP].hallSigCal_ftrig[5].Q;
				GVL.hallSequence.6 := axis[XP].hallSigCal_rtrig[6].Q OR axis[XP].hallSigCal_ftrig[6].Q;
				GVL.hallSequence.7 := axis[XP].hallSigCal_rtrig[7].Q OR axis[XP].hallSigCal_ftrig[7].Q;
				GVL.hallSequence.8 := axis[XP].hallSigCal_rtrig[8].Q OR axis[XP].hallSigCal_ftrig[8].Q;
				GVL.hallSequence.9 := axis[XP].hallSigCal_rtrig[9].Q OR axis[XP].hallSigCal_ftrig[9].Q;
				GVL.hallSequence.10 := axis[XP].hallSigCal_rtrig[10].Q OR axis[XP].hallSigCal_ftrig[10].Q;
				GVL.hallSequence.11 := axis[XP].hallSigCal_rtrig[11].Q OR axis[XP].hallSigCal_ftrig[11].Q;
				GVL.hallSequence.12 := axis[XP].hallSigCal_rtrig[12].Q OR axis[XP].hallSigCal_ftrig[12].Q;
				GVL.hallSequence.13 := axis[XP].hallSigCal_rtrig[13].Q OR axis[XP].hallSigCal_ftrig[13].Q;
				GVL.hallSequence.14 := axis[XP].hallSigCal_rtrig[14].Q OR axis[XP].hallSigCal_ftrig[14].Q;	
		
			(* Unary XOR of hallSequence. With one blade running, the 16-bit variable would only have 1 bit HIGH while the rest is LOW.
				Result of 1 indicates presence of one blade sequence. Result of 0 indicates presence of two blade sequence *)
			xorResult := (GVL.hallSequence.0 XOR GVL.hallSequence.1 XOR GVL.hallSequence.2 XOR GVL.hallSequence.3 XOR GVL.hallSequence.4 XOR
				GVL.hallSequence.5 XOR GVL.hallSequence.6 XOR GVL.hallSequence.7 XOR GVL.hallSequence.8 XOR GVL.hallSequence.9 XOR
				GVL.hallSequence.10 XOR GVL.hallSequence.11 XOR GVL.hallSequence.12 XOR GVL.hallSequence.13 XOR GVL.hallSequence.14);
			IF xorResult THEN
				axis[XP].seqToCompare := GVL.hallSequence;
			ELSIF axis[XM].axisRef.status.PositiveDirection THEN
				axis[XP].seqToCompare := (GVL.hallSequence XOR axis[XM].hallSequence[GVL.dirPos_C, axis[XM].tripCount+1]); //+1 required since XM tripCount does not update until further down
				IF axis[XP].seqToCompare > GVL.hallSequence THEN
					axis[XP].seqToCompare := (GVL.hallSequence XOR axis[XM].hallSequence[GVL.dirPos_C, axis[XM].tripCount]);
				END_IF	
			ELSIF axis[XM].axisRef.status.NegativeDirection THEN
				axis[XP].seqToCompare := (GVL.hallSequence XOR axis[XM].hallSequence[GVL.dirNeg_C, axis[XM].tripCount-1]);	
				IF axis[XP].seqToCompare > GVL.hallSequence THEN
					axis[XP].seqToCompare := (GVL.hallSequence XOR axis[XM].hallSequence[GVL.dirNeg_C, axis[XM].tripCount]);
				END_IF	
			ELSE
				; //PUT ERROR CODE HERE
			END_IF	
	
			
			//Compare current sequence with recorded sequence. Update position if match.
			IF axis[XP].axisRef.status.PositiveDirection AND axis[XP].hallSequence[GVL.dirPos_C, axis[XP].tripCount] = axis[XP].seqToCompare THEN
				axis[XP].hallPosAct := axis[XP].hallPosCal[GVL.dirPos_C, axis[XP].tripCount];
				axis[XP].tripCount := axis[XP].tripCount + 1;	
			END_IF
			IF axis[XP].axisRef.status.NegativeDirection AND axis[XP].hallSequence[GVL.dirNeg_C, axis[XP].tripCount] = axis[XP].seqToCompare THEN
				axis[XP].hallPosAct := axis[XP].hallPosCal[GVL.dirNeg_C, axis[XP].tripCount];
				axis[XP].tripCount := axis[XP].tripCount - 1;	
			END_IF
			
		END_IF
	END_FOR
	
	
	
	
	
	
	//Actual Position Calc AxisXM
	FOR i:=GVL.hallLowerLimit_C TO GVL.hallUpperLimit_C BY 1 DO
		axis[XM].hallSigCal_rtrig[i](CLK:=GVL.hallSwitch[i]);
		axis[XM].hallSigCal_ftrig[i](CLK:=GVL.hallSwitch[i]);
		IF (axis[XM].hallSigCal_rtrig[i].Q OR axis[XM].hallSigCal_ftrig[i].Q) AND axis[XM].axisRef.Status.Moving THEN
			
				GVL.hallSequence.0 := axis[XM].hallSigCal_rtrig[0].Q OR axis[XM].hallSigCal_ftrig[0].Q;
				GVL.hallSequence.1 := axis[XM].hallSigCal_rtrig[1].Q OR axis[XM].hallSigCal_ftrig[1].Q;
				GVL.hallSequence.2 := axis[XM].hallSigCal_rtrig[2].Q OR axis[XM].hallSigCal_ftrig[2].Q;
				GVL.hallSequence.3 := axis[XM].hallSigCal_rtrig[3].Q OR axis[XM].hallSigCal_ftrig[3].Q;
				GVL.hallSequence.4 := axis[XM].hallSigCal_rtrig[4].Q OR axis[XM].hallSigCal_ftrig[4].Q;
				GVL.hallSequence.5 := axis[XM].hallSigCal_rtrig[5].Q OR axis[XM].hallSigCal_ftrig[5].Q;
				GVL.hallSequence.6 := axis[XM].hallSigCal_rtrig[6].Q OR axis[XM].hallSigCal_ftrig[6].Q;
				GVL.hallSequence.7 := axis[XM].hallSigCal_rtrig[7].Q OR axis[XM].hallSigCal_ftrig[7].Q;
				GVL.hallSequence.8 := axis[XM].hallSigCal_rtrig[8].Q OR axis[XM].hallSigCal_ftrig[8].Q;
				GVL.hallSequence.9 := axis[XM].hallSigCal_rtrig[9].Q OR axis[XM].hallSigCal_ftrig[9].Q;
				GVL.hallSequence.10 := axis[XM].hallSigCal_rtrig[10].Q OR axis[XM].hallSigCal_ftrig[10].Q;
				GVL.hallSequence.11 := axis[XM].hallSigCal_rtrig[11].Q OR axis[XM].hallSigCal_ftrig[11].Q;
				GVL.hallSequence.12 := axis[XM].hallSigCal_rtrig[12].Q OR axis[XM].hallSigCal_ftrig[12].Q;
				GVL.hallSequence.13 := axis[XM].hallSigCal_rtrig[13].Q OR axis[XM].hallSigCal_ftrig[13].Q;
				GVL.hallSequence.14 := axis[XM].hallSigCal_rtrig[14].Q OR axis[XM].hallSigCal_ftrig[14].Q;			
			
			IF (GVL.hallSequence.0 XOR GVL.hallSequence.1 XOR GVL.hallSequence.2 XOR GVL.hallSequence.3 XOR GVL.hallSequence.4 XOR
				GVL.hallSequence.5 XOR GVL.hallSequence.6 XOR GVL.hallSequence.7 XOR GVL.hallSequence.8 XOR GVL.hallSequence.9 XOR
				GVL.hallSequence.10 XOR GVL.hallSequence.11 XOR GVL.hallSequence.12 XOR GVL.hallSequence.13 XOR GVL.hallSequence.14) THEN
				axis[XM].seqToCompare := GVL.hallSequence;
				
				GVL.testINT := GVL.testINT +1;
				
			ELSE
				GVL.testINT2 := GVL.testINT2 +1;
				IF axis[XP].axisRef.status.PositiveDirection THEN
					axis[XM].seqToCompare := (GVL.hallSequence XOR axis[XP].hallSequence[GVL.dirPos_C, axis[XP].tripCount-1]);	
					IF axis[XM].seqToCompare > GVL.hallSequence THEN
						axis[XM].seqToCompare := (GVL.hallSequence XOR axis[XP].hallSequence[GVL.dirPos_C, axis[XP].tripCount]);
					END_IF	
				ELSIF axis[XP].axisRef.status.NegativeDirection THEN
					axis[XM].seqToCompare := (GVL.hallSequence XOR axis[XP].hallSequence[GVL.dirNeg_C, axis[XP].tripCount+1]);	
					IF axis[XM].seqToCompare > GVL.hallSequence THEN
						axis[XM].seqToCompare := (GVL.hallSequence XOR axis[XP].hallSequence[GVL.dirNeg_C, axis[XP].tripCount]);
					END_IF		
				ELSE
					; //PUT ERROR CODE HERE
				END_IF		
			END_IF	
				
			IF axis[XM].axisRef.status.PositiveDirection AND axis[XM].hallSequence[GVL.dirPos_C, axis[XM].tripCount] = axis[XM].seqToCompare THEN
				axis[XM].hallPosAct := axis[XM].hallPosCal[GVL.dirPos_C, axis[XM].tripCount];
				axis[XM].tripCount := axis[XM].tripCount - 1;	
			END_IF
			IF axis[XM].axisRef.status.NegativeDirection AND axis[XM].hallSequence[GVL.dirNeg_C, axis[XM].tripCount] = axis[XM].seqToCompare THEN
				axis[XM].hallPosAct := axis[XM].hallPosCal[GVL.dirNeg_C, axis[XM].tripCount];
				axis[XM].tripCount := axis[XM].tripCount + 1;	
			END_IF
		END_IF
	END_FOR

ELSE
	axis[XP].tripCount := 0;	
	axis[XM].tripCount := 0;
END_IF
]]></ST>
      </Implementation>
    </Action>
    <Action Name="travellingSlit" Id="{010e22ff-7bc2-4993-b1b3-4a27b2699493}">
      <Implementation>
        <ST><![CDATA[IF initStateLVL2 = FALSE THEN
	initStateLVL2 := TRUE;
	stateLVL2 :=10000;
	motionBusy := TRUE;
END_IF	

CASE stateLVL2 OF
	
	10000:
		motionBusy := TRUE;
		axis[XP].mcMoveAbs(Axis:=axis[XP].axisRef, Position:= 0, Velocity:=300, Execute:=TRUE);
		axis[XM].mcMoveAbs(Axis:=axis[XM].axisRef, Position:= 166, Velocity:=300, Execute:=TRUE);
		IF axis[XP].mcMoveAbs.Done AND axis[XM].mcMoveAbs.Done THEN
			axis[XP].mcMoveAbs(Axis:=axis[XP].axisRef, Execute:=FALSE);
			axis[XM].mcMoveAbs(Axis:=axis[XM].axisRef, Execute:=FALSE);
			stateLVL2 := 10010;
		END_IF	
		
	10010:
		axis[XP].mcMoveAbs(Axis:=axis[XP].axisRef, Position:= 584, Velocity:=1666, Execute:=TRUE);
		axis[XM].mcMoveAbs(Axis:=axis[XM].axisRef, Position:= 750, Velocity:=1666, Execute:=TRUE);
		IF axis[XP].mcMoveAbs.Done AND axis[XM].mcMoveAbs.Done THEN
			axis[XP].mcMoveAbs(Axis:=axis[XP].axisRef, Execute:=FALSE);
			axis[XM].mcMoveAbs(Axis:=axis[XM].axisRef, Execute:=FALSE);
			stateLVL2 := 10020;
		END_IF			

	10020: //End action
		initStateLVL2 := FALSE;
		stateLVL2 := 0;
		motionBusy := FALSE;
		
END_CASE]]></ST>
      </Implementation>
    </Action>
    <LineIds Name="TestMotion">
      <LineId Id="2584" Count="1" />
      <LineId Id="30" Count="0" />
      <LineId Id="351" Count="0" />
      <LineId Id="150" Count="1" />
      <LineId Id="153" Count="0" />
      <LineId Id="152" Count="0" />
      <LineId Id="45" Count="0" />
      <LineId Id="146" Count="0" />
      <LineId Id="148" Count="0" />
      <LineId Id="147" Count="0" />
      <LineId Id="2395" Count="0" />
      <LineId Id="695" Count="0" />
      <LineId Id="31" Count="0" />
      <LineId Id="49" Count="0" />
      <LineId Id="368" Count="0" />
      <LineId Id="2075" Count="0" />
      <LineId Id="648" Count="1" />
      <LineId Id="2633" Count="1" />
      <LineId Id="2628" Count="1" />
      <LineId Id="571" Count="0" />
      <LineId Id="1895" Count="0" />
      <LineId Id="367" Count="0" />
      <LineId Id="36" Count="0" />
      <LineId Id="2473" Count="0" />
      <LineId Id="2477" Count="0" />
      <LineId Id="572" Count="0" />
      <LineId Id="77" Count="2" />
      <LineId Id="2777" Count="5" />
      <LineId Id="2795" Count="0" />
      <LineId Id="2783" Count="0" />
      <LineId Id="82" Count="2" />
      <LineId Id="165" Count="1" />
      <LineId Id="155" Count="0" />
      <LineId Id="2631" Count="0" />
      <LineId Id="2797" Count="1" />
      <LineId Id="2792" Count="1" />
      <LineId Id="85" Count="0" />
      <LineId Id="1690" Count="0" />
      <LineId Id="88" Count="0" />
      <LineId Id="60" Count="0" />
      <LineId Id="86" Count="1" />
      <LineId Id="3025" Count="1" />
      <LineId Id="101" Count="1" />
      <LineId Id="2478" Count="0" />
      <LineId Id="1894" Count="0" />
      <LineId Id="1447" Count="0" />
      <LineId Id="38" Count="0" />
      <LineId Id="121" Count="0" />
      <LineId Id="89" Count="0" />
      <LineId Id="2601" Count="0" />
      <LineId Id="90" Count="0" />
      <LineId Id="2599" Count="1" />
      <LineId Id="168" Count="0" />
      <LineId Id="329" Count="0" />
      <LineId Id="550" Count="0" />
      <LineId Id="556" Count="0" />
      <LineId Id="2621" Count="1" />
      <LineId Id="1976" Count="0" />
      <LineId Id="361" Count="0" />
      <LineId Id="2432" Count="0" />
      <LineId Id="2418" Count="0" />
      <LineId Id="2427" Count="1" />
      <LineId Id="401" Count="0" />
      <LineId Id="416" Count="1" />
      <LineId Id="2444" Count="0" />
      <LineId Id="2448" Count="1" />
      <LineId Id="431" Count="0" />
      <LineId Id="423" Count="0" />
      <LineId Id="2479" Count="3" />
      <LineId Id="495" Count="0" />
      <LineId Id="2593" Count="0" />
      <LineId Id="2598" Count="0" />
      <LineId Id="2602" Count="1" />
      <LineId Id="2605" Count="0" />
      <LineId Id="2604" Count="0" />
      <LineId Id="2594" Count="0" />
      <LineId Id="2607" Count="1" />
      <LineId Id="2701" Count="4" />
      <LineId Id="3005" Count="0" />
      <LineId Id="3022" Count="0" />
      <LineId Id="3007" Count="2" />
      <LineId Id="3003" Count="0" />
      <LineId Id="2609" Count="0" />
      <LineId Id="3011" Count="0" />
      <LineId Id="2999" Count="1" />
      <LineId Id="3012" Count="0" />
      <LineId Id="3021" Count="0" />
      <LineId Id="2613" Count="0" />
      <LineId Id="2611" Count="0" />
      <LineId Id="554" Count="0" />
      <LineId Id="553" Count="0" />
      <LineId Id="2612" Count="0" />
      <LineId Id="496" Count="1" />
      <LineId Id="504" Count="1" />
      <LineId Id="1701" Count="1" />
      <LineId Id="1705" Count="0" />
      <LineId Id="1703" Count="1" />
      <LineId Id="506" Count="0" />
      <LineId Id="509" Count="0" />
      <LineId Id="544" Count="0" />
      <LineId Id="546" Count="1" />
      <LineId Id="549" Count="0" />
      <LineId Id="548" Count="0" />
      <LineId Id="545" Count="0" />
      <LineId Id="518" Count="0" />
      <LineId Id="1473" Count="0" />
      <LineId Id="519" Count="0" />
      <LineId Id="521" Count="0" />
      <LineId Id="1476" Count="0" />
      <LineId Id="522" Count="0" />
      <LineId Id="524" Count="0" />
      <LineId Id="523" Count="0" />
      <LineId Id="520" Count="0" />
      <LineId Id="525" Count="0" />
      <LineId Id="531" Count="4" />
      <LineId Id="526" Count="1" />
      <LineId Id="1559" Count="2" />
      <LineId Id="536" Count="0" />
      <LineId Id="512" Count="1" />
      <LineId Id="498" Count="1" />
      <LineId Id="1477" Count="0" />
      <LineId Id="539" Count="1" />
      <LineId Id="1478" Count="0" />
      <LineId Id="541" Count="2" />
      <LineId Id="557" Count="2" />
      <LineId Id="561" Count="1" />
      <LineId Id="564" Count="0" />
      <LineId Id="563" Count="0" />
      <LineId Id="560" Count="0" />
      <LineId Id="2614" Count="3" />
      <LineId Id="1788" Count="0" />
      <LineId Id="1790" Count="0" />
      <LineId Id="2641" Count="0" />
      <LineId Id="1791" Count="0" />
      <LineId Id="2639" Count="1" />
      <LineId Id="1787" Count="0" />
      <LineId Id="2618" Count="2" />
      <LineId Id="538" Count="0" />
      <LineId Id="1160" Count="0" />
      <LineId Id="1166" Count="0" />
      <LineId Id="2623" Count="4" />
      <LineId Id="3113" Count="7" />
      <LineId Id="2304" Count="0" />
      <LineId Id="37" Count="0" />
      <LineId Id="696" Count="0" />
      <LineId Id="2939" Count="1" />
      <LineId Id="2855" Count="1" />
      <LineId Id="906" Count="0" />
      <LineId Id="1371" Count="3" />
      <LineId Id="3085" Count="1" />
      <LineId Id="3099" Count="13" />
      <LineId Id="3185" Count="0" />
      <LineId Id="3220" Count="0" />
      <LineId Id="3225" Count="1" />
      <LineId Id="3222" Count="0" />
      <LineId Id="3245" Count="0" />
      <LineId Id="3247" Count="0" />
      <LineId Id="3246" Count="0" />
      <LineId Id="3229" Count="0" />
      <LineId Id="3248" Count="0" />
      <LineId Id="3235" Count="0" />
      <LineId Id="3230" Count="0" />
      <LineId Id="3240" Count="0" />
      <LineId Id="3238" Count="0" />
      <LineId Id="3241" Count="1" />
      <LineId Id="3239" Count="0" />
      <LineId Id="3223" Count="0" />
      <LineId Id="3232" Count="0" />
      <LineId Id="1405" Count="1" />
      <LineId Id="1408" Count="0" />
      <LineId Id="3177" Count="0" />
      <LineId Id="3190" Count="0" />
      <LineId Id="1407" Count="0" />
      <LineId Id="1684" Count="0" />
      <LineId Id="1687" Count="1" />
      <LineId Id="3178" Count="0" />
      <LineId Id="1689" Count="0" />
      <LineId Id="3084" Count="0" />
      <LineId Id="1381" Count="1" />
      <LineId Id="2325" Count="5" />
      <LineId Id="3195" Count="15" />
      <LineId Id="3218" Count="0" />
      <LineId Id="3249" Count="15" />
      <LineId Id="3219" Count="0" />
      <LineId Id="3211" Count="5" />
      <LineId Id="2334" Count="2" />
      <LineId Id="3217" Count="0" />
      <LineId Id="2337" Count="2" />
      <LineId Id="1711" Count="0" />
      <LineId Id="2913" Count="0" />
      <LineId Id="2928" Count="0" />
      <LineId Id="2915" Count="0" />
      <LineId Id="2936" Count="0" />
      <LineId Id="2938" Count="0" />
      <LineId Id="2937" Count="0" />
      <LineId Id="2929" Count="0" />
      <LineId Id="2533" Count="0" />
      <LineId Id="1450" Count="0" />
      <LineId Id="3271" Count="1" />
      <LineId Id="9" Count="0" />
    </LineIds>
    <LineIds Name="TestMotion.calibrateXM">
      <LineId Id="71" Count="6" />
      <LineId Id="79" Count="0" />
      <LineId Id="128" Count="0" />
      <LineId Id="164" Count="1" />
      <LineId Id="133" Count="0" />
      <LineId Id="135" Count="0" />
      <LineId Id="137" Count="18" />
      <LineId Id="127" Count="0" />
      <LineId Id="81" Count="5" />
      <LineId Id="167" Count="1" />
      <LineId Id="317" Count="13" />
      <LineId Id="169" Count="0" />
      <LineId Id="334" Count="1" />
      <LineId Id="88" Count="0" />
      <LineId Id="201" Count="0" />
      <LineId Id="89" Count="16" />
      <LineId Id="336" Count="1" />
      <LineId Id="339" Count="13" />
      <LineId Id="338" Count="0" />
      <LineId Id="106" Count="11" />
      <LineId Id="157" Count="0" />
      <LineId Id="161" Count="0" />
      <LineId Id="163" Count="0" />
      <LineId Id="158" Count="1" />
      <LineId Id="80" Count="0" />
      <LineId Id="78" Count="0" />
      <LineId Id="2" Count="0" />
      <LineId Id="1" Count="0" />
    </LineIds>
    <LineIds Name="TestMotion.calibrateXP">
      <LineId Id="150" Count="5" />
      <LineId Id="80" Count="0" />
      <LineId Id="149" Count="0" />
      <LineId Id="81" Count="0" />
      <LineId Id="83" Count="0" />
      <LineId Id="168" Count="0" />
      <LineId Id="88" Count="0" />
      <LineId Id="90" Count="0" />
      <LineId Id="93" Count="25" />
      <LineId Id="169" Count="0" />
      <LineId Id="172" Count="0" />
      <LineId Id="221" Count="11" />
      <LineId Id="187" Count="1" />
      <LineId Id="173" Count="0" />
      <LineId Id="252" Count="1" />
      <LineId Id="120" Count="0" />
      <LineId Id="233" Count="0" />
      <LineId Id="121" Count="9" />
      <LineId Id="161" Count="0" />
      <LineId Id="131" Count="5" />
      <LineId Id="257" Count="1" />
      <LineId Id="261" Count="13" />
      <LineId Id="260" Count="0" />
      <LineId Id="256" Count="0" />
      <LineId Id="138" Count="10" />
      <LineId Id="162" Count="0" />
      <LineId Id="165" Count="1" />
      <LineId Id="163" Count="1" />
      <LineId Id="158" Count="1" />
      <LineId Id="1" Count="0" />
    </LineIds>
    <LineIds Name="TestMotion.closeShutterMinus">
      <LineId Id="2" Count="4" />
      <LineId Id="21" Count="0" />
      <LineId Id="23" Count="0" />
      <LineId Id="7" Count="12" />
      <LineId Id="24" Count="4" />
      <LineId Id="22" Count="0" />
      <LineId Id="1" Count="0" />
    </LineIds>
    <LineIds Name="TestMotion.closeShutterPlus">
      <LineId Id="23" Count="0" />
      <LineId Id="25" Count="0" />
      <LineId Id="29" Count="0" />
      <LineId Id="24" Count="0" />
      <LineId Id="28" Count="0" />
      <LineId Id="14" Count="0" />
      <LineId Id="21" Count="0" />
      <LineId Id="15" Count="0" />
      <LineId Id="2" Count="9" />
      <LineId Id="26" Count="0" />
      <LineId Id="13" Count="0" />
      <LineId Id="18" Count="0" />
      <LineId Id="31" Count="3" />
      <LineId Id="20" Count="0" />
      <LineId Id="35" Count="0" />
      <LineId Id="1" Count="0" />
    </LineIds>
    <LineIds Name="TestMotion.cycler">
      <LineId Id="78" Count="3" />
      <LineId Id="76" Count="0" />
      <LineId Id="83" Count="0" />
      <LineId Id="77" Count="0" />
      <LineId Id="2" Count="72" />
      <LineId Id="84" Count="1" />
      <LineId Id="75" Count="0" />
      <LineId Id="87" Count="1" />
      <LineId Id="86" Count="0" />
      <LineId Id="82" Count="0" />
      <LineId Id="1" Count="0" />
    </LineIds>
    <LineIds Name="TestMotion.homeShutter">
      <LineId Id="31" Count="3" />
      <LineId Id="29" Count="0" />
      <LineId Id="35" Count="1" />
      <LineId Id="30" Count="0" />
      <LineId Id="2" Count="17" />
      <LineId Id="40" Count="0" />
      <LineId Id="20" Count="2" />
      <LineId Id="38" Count="0" />
      <LineId Id="44" Count="2" />
      <LineId Id="39" Count="0" />
      <LineId Id="1" Count="0" />
    </LineIds>
    <LineIds Name="TestMotion.openShutter">
      <LineId Id="12" Count="3" />
      <LineId Id="10" Count="1" />
      <LineId Id="18" Count="1" />
      <LineId Id="2" Count="7" />
      <LineId Id="20" Count="0" />
      <LineId Id="23" Count="4" />
      <LineId Id="17" Count="0" />
      <LineId Id="1" Count="0" />
    </LineIds>
    <LineIds Name="TestMotion.tracking">
      <LineId Id="2" Count="0" />
      <LineId Id="4" Count="6" />
      <LineId Id="136" Count="0" />
      <LineId Id="11" Count="15" />
      <LineId Id="135" Count="0" />
      <LineId Id="27" Count="0" />
      <LineId Id="133" Count="0" />
      <LineId Id="147" Count="2" />
      <LineId Id="28" Count="0" />
      <LineId Id="31" Count="0" />
      <LineId Id="151" Count="0" />
      <LineId Id="38" Count="0" />
      <LineId Id="174" Count="0" />
      <LineId Id="176" Count="1" />
      <LineId Id="39" Count="1" />
      <LineId Id="179" Count="0" />
      <LineId Id="181" Count="1" />
      <LineId Id="41" Count="4" />
      <LineId Id="137" Count="0" />
      <LineId Id="46" Count="2" />
      <LineId Id="51" Count="3" />
      <LineId Id="56" Count="3" />
      <LineId Id="123" Count="5" />
      <LineId Id="60" Count="32" />
      <LineId Id="185" Count="2" />
      <LineId Id="93" Count="1" />
      <LineId Id="188" Count="2" />
      <LineId Id="95" Count="7" />
      <LineId Id="105" Count="3" />
      <LineId Id="110" Count="4" />
      <LineId Id="117" Count="1" />
      <LineId Id="121" Count="1" />
      <LineId Id="1" Count="0" />
    </LineIds>
    <LineIds Name="TestMotion.travellingSlit">
      <LineId Id="2" Count="16" />
      <LineId Id="25" Count="0" />
      <LineId Id="28" Count="6" />
      <LineId Id="26" Count="0" />
      <LineId Id="19" Count="5" />
      <LineId Id="1" Count="0" />
    </LineIds>
  </POU>
</TcPlcObject>
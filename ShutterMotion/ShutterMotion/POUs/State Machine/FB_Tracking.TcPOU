<?xml version="1.0" encoding="utf-8"?>
<TcPlcObject Version="1.1.0.1" ProductVersion="3.1.4020.12">
  <POU Name="FB_Tracking" Id="{462a5933-fe60-42d4-a574-27170521c4c5}" SpecialFunc="None">
    <Declaration><![CDATA[FUNCTION_BLOCK FB_Tracking
VAR_IN_OUT
	stAxis  : ARRAY [GVL.cXP .. GVL.cXM] OF ST_AxisGroup;	
END_VAR
VAR_INPUT
	eCommand 	: E_Commands;
	bMotionDone	: BOOL;
END_VAR
VAR_OUTPUT
	stOutMotionDone : ST_MotionDone;
END_VAR
VAR
	//used in tracking Action
	nSeqToCompare 	: ARRAY [0 .. 1] OF WORD;
	bEdgeToCompare	: ARRAY [0 .. 1] OF BOOL;
	nHallID			: ARRAY [0 .. 1] OF DINT;
	nAxisID			: INT;
	tTimeEnd		: T_DCTIME64;
	nMask			: ULINT := 16#FFFF_FFFF_0000_0000;
	tDcTime			: T_DCTIME64;
	fSpeed			: LREAL;
	
	
	//bXorResult 		: BOOL;
	nSeqTime		: ARRAY [0 .. 1] OF UDINT;
	bValidInput		: BOOL;
	bDoubleTrip		: BOOL;
	nGoNextSeq		: BOOL;
	
	fbMoving_Rtrig : ARRAY[0 .. 1] OF R_TRIG;
	fbRtrig		: ARRAY[GVL.cHallLower..GVL.cHallUpper] OF R_Trig;
	bInMotion	: BOOL;
	stMotionDone : ARRAY [0..1] OF ST_MotionDone;	
	nSequence	: DINT;
	
	//counter
	i, j	: INT :=0;
	
	//TestVar
	testInt: INT;
	testLREAL : LREAL;
END_VAR
]]></Declaration>
    <Implementation>
      <ST><![CDATA[//////////////////////////////////////////////////////////////
//Algorithm for tracking blade position using hall switches	//
//////////////////////////////////////////////////////////////
bValidInput:=FALSE;
bDoubleTrip:=FALSE;
nGoNextSeq := FALSE;
stAxis[GVL.cXP].bTrackedFlag:=FALSE;
stAxis[GVL.cXM].bTrackedFlag:=FALSE;
j:=0;

(*
//Check if command causes motion
IF (eCommand=E_Commands.calibrate) OR_ELSE
	(eCommand=E_Commands.closeShutter) OR_ELSE
	(eCommand=E_Commands.homeAxis) OR_ELSE
	(eCommand=E_Commands.moveAxisAbsolute) OR_ELSE
	(eCommand=E_Commands.moveAxisRelative) OR_ELSE
	(eCommand=E_Commands.openShutter) OR_ELSE
	(eCommand=E_Commands.takeExposure) THEN
		bInMotion := TRUE;
		tTimeStart := F_GetCurDcTaskTime64();
END_IF
*)
fbMoving_Rtrig[GVL.cXP](CLK:=stAxis[GVL.cXP].axisRef.Status.Moving);
IF fbMoving_Rtrig[GVL.cXP].Q THEN
	bInMotion:=TRUE;
	//AxisXP
	stMotionDone[GVL.cXP].axisNum := GVL.cXP;
	stMotionDone[GVL.cXP].nsamples := 0;
	stMotionDone[GVL.cXP].ntrans := 0;
	stMotionDone[gvl.cXP].startPos := stAxis[GVL.cXP].axisRef.NcToPlc.ActPos;
	stMotionDone[GVL.cXP].startTime := F_GetCurDcTaskTime64();
	stMotionDone[GVL.cXP].targetDur := LTIME#0D0H0M0S0MS0US0NS;
END_IF
fbMoving_Rtrig[GVL.cXM](CLK:=stAxis[GVL.cXM].axisRef.Status.Moving);
IF fbMoving_Rtrig[GVL.cXM].Q THEN
	bInMotion:=TRUE;
	//AxisXM
	stMotionDone[gvl.cXM].axisNum := GVL.cXM;
	stMotionDone[gvl.cXM].nsamples := 0;
	stMotionDone[gvl.cXM].ntrans := 0;
	stMotionDone[gvl.cXM].startPos := stAxis[GVL.cXM].axisRef.NcToPlc.ActPos;
	stMotionDone[gvl.cXM].startTime := F_GetCurDcTaskTime64();
	stMotionDone[gvl.cXM].targetDur := LTIME#0D0H0M0S0MS0US0NS;
END_IF

IF bMotionDone THEN
	IF MAIN.inReset.speed > 0 THEN
		fSpeed := MAIN.inReset.speed;
	ELSE
		fSpeed := 0.01;
	END_IF
	bInMotion := FALSE;
	nSequence := nSequence+1;
	tTimeEnd := F_GetCurDcTaskTime64();
	stMotionDone[nAxisID].actualDur := ULINT_TO_LTIME(tTimeEnd-stMotionDone[nAxisID].startTime);
	stMotionDone[nAxisID].targetDur := ULINT_TO_LTIME(tTimeEnd-stMotionDone[nAxisID].startTime); //Needs to be changed to actually calculate expected duration //LREAL_TO_LTIME((2*ABS(stMotionDone[nAxisID].startPos-stAxis[nAxisID].axisRef.NcToPlc.TargetPos)/fSpeed)*1000000000);//
	stMotionDone[nAxisID].targetPos := stAxis[nAxisID].axisRef.NcToPlc.TargetPos;
	stMotionDone[nAxisID].endPos := stAxis[nAxisID].axisRef.NcToPlc.ActPos;
	
	testLREAL :=(2*ABS(stMotionDone[nAxisID].startPos-stAxis[nAxisID].axisRef.NcToPlc.TargetPos)/fSpeed);//ULINT_TO_LTIME(tTimeEnd-tTimeStart);
	
	stOutMotionDone:=stMotionDone[nAxisID];
	stOutMotionDone.sequence:=nSequence;
END_IF

//Detect hall switch transitions
FOR i:=GVL.cHallLower TO GVL.cHallUpper BY 1 DO
	fbRtrig[i](CLK:=GVL.nNumOfInputs[i].0);
	IF fbRtrig[i].Q THEN
		//identifies which hall switch tripped
		nSeqToCompare[j] := INT_TO_WORD((i*10)+5);
		bEdgeToCompare[j] := GVL.bInputEventState[i];
		nHallID[j] := i;
		
		//along with the trip time
		stAxis[GVL.cXP].nHallTime := GVL.nInputEventTime[i];
		
		//increment the index
		j:=j+1;
		bValidInput:=TRUE;
		IF j=2 THEN
			bDoubleTrip:=TRUE;
		END_IF
	END_IF
	
	IF GVL.nNumOfInputs[i]=2 THEN
		testInt:=testint+1;
	END_IF
	
END_FOR
	
//Single blade motion tracking
IF bValidInput THEN
	
	//Hall sensors position tracking for axis XP
	IF stAxis[GVL.cXP].axisRef.Status.Moving AND NOT nGoNextSeq THEN
		//Compare current sequence with recorded sequence. Update position if match. Positive direction.
		IF stAxis[GVL.cXP].axisRef.status.PositiveDirection AND stAxis[GVL.cXP].stHall[GVL.cDirPos, stAxis[GVL.cXP].nTripCount].nSeq = nSeqToCompare[0] AND 
				stAxis[GVL.cXP].stHall[GVL.cDirPos, stAxis[GVL.cXP].nTripCount].bEdge = bEdgeToCompare[0] THEN
			stAxis[GVL.cXP].fHallPosAct := stAxis[GVL.cXP].fHallPosCal[GVL.cDirPos, stAxis[GVL.cXP].nTripCount];
			stAxis[GVL.cXP].nTripCount := stAxis[GVL.cXP].nTripCount + 1;
			//track difference between hall sensor and encoder data at trip point
			stAxis[GVL.cXP].fPosDiffAtTrip := stAxis[GVL.cXP].axisRef.NcToPlc.ActPos - stAxis[GVL.cXP].fHallPosAct;
			stAxis[GVL.cXP].bTrackedFlag:=TRUE;
			nGoNextSeq := TRUE;
			
			IF bInMotion AND MAIN.outShutterStatus.smState<>E_StatesMaint.Calibrating THEN
				nAxisID:= GVL.cXP;
				tDcTime:=F_GetCurDcTaskTime64() AND nMask;
				stMotionDone[GVL.cXP].trans[stMotionDone[GVL.cXP].ntrans].dcTime := GVL.nInputEventTime[nHallID[0]]+tDcTime;
				stMotionDone[GVL.cXP].trans[stMotionDone[GVL.cXP].ntrans].id := nHallID[0];
				stMotionDone[GVL.cXP].trans[stMotionDone[GVL.cXP].ntrans].on := bEdgeToCompare[0];
				stMotionDone[GVL.cXP].trans[stMotionDone[GVL.cXP].ntrans].pos := stAxis[GVL.cXP].fHallPosAct;
				stMotionDone[GVL.cXP].ntrans := stMotionDone[GVL.cXP].ntrans +1;
				
				stMotionDone[GVL.cXP].samples[stMotionDone[GVL.cXP].nsamples].dcTime := F_GetCurDcTaskTime64();
				stMotionDone[GVL.cXP].samples[stMotionDone[GVL.cXP].nsamples].pos := stAxis[GVL.cXP].axisRef.NcToPlc.ActPos;
				stMotionDone[GVL.cXP].nsamples := stMotionDone[GVL.cXP].nsamples + 1;
			END_IF
			
		END_IF
		//Compare current sequence with recorded sequence. Update position if match. Negative direction.
		IF stAxis[GVL.cXP].axisRef.status.NegativeDirection AND stAxis[GVL.cXP].stHall[GVL.cDirNeg, stAxis[GVL.cXP].nTripCount].nSeq = nSeqToCompare[0] AND
				stAxis[GVL.cXP].stHall[GVL.cDirNeg, stAxis[GVL.cXP].nTripCount].bEdge = bEdgeToCompare[0] THEN
			stAxis[GVL.cXP].fHallPosAct := stAxis[GVL.cXP].fHallPosCal[GVL.cDirNeg, stAxis[GVL.cXP].nTripCount];
			stAxis[GVL.cXP].nTripCount := stAxis[GVL.cXP].nTripCount - 1;		
			//track difference between hall sensor and encoder data at trip point
			stAxis[GVL.cXP].fPosDiffAtTrip := stAxis[GVL.cXP].axisRef.NcToPlc.ActPos - stAxis[GVL.cXP].fHallPosAct;
			stAxis[GVL.cXP].bTrackedFlag:=TRUE;
			nGoNextSeq := TRUE;
			
			IF bInMotion AND MAIN.outShutterStatus.smState<>E_StatesMaint.Calibrating THEN
				nAxisID:= GVL.cXP;
				tDcTime:=F_GetCurDcTaskTime64() AND nMask;
				stMotionDone[GVL.cXP].trans[stMotionDone[GVL.cXP].ntrans].dcTime := GVL.nInputEventTime[nHallID[0]]+tDcTime;
				stMotionDone[GVL.cXP].trans[stMotionDone[GVL.cXP].ntrans].id := nHallID[0];
				stMotionDone[GVL.cXP].trans[stMotionDone[GVL.cXP].ntrans].on := bEdgeToCompare[0];
				stMotionDone[GVL.cXP].trans[stMotionDone[GVL.cXP].ntrans].pos := stAxis[GVL.cXP].fHallPosAct;
				stMotionDone[GVL.cXP].ntrans := stMotionDone[GVL.cXP].ntrans +1;
				
				stMotionDone[GVL.cXP].samples[stMotionDone[GVL.cXP].nsamples].dcTime := F_GetCurDcTaskTime64();
				stMotionDone[GVL.cXP].samples[stMotionDone[GVL.cXP].nsamples].pos := stAxis[GVL.cXP].axisRef.NcToPlc.ActPos;
				stMotionDone[GVL.cXP].nsamples := stMotionDone[GVL.cXP].nsamples + 1;
			END_IF
			
		END_IF
	END_IF
	
	//Hall sensors position tracking for axis XM
	IF stAxis[GVL.cXM].axisRef.Status.Moving AND NOT nGoNextSeq THEN
		//Compare current sequence with recorded sequence. Update position if match. Positive direction.
		IF stAxis[GVL.cXM].axisRef.status.PositiveDirection AND stAxis[GVL.cXM].stHall[GVL.cDirPos, stAxis[GVL.cXM].nTripCount].nSeq = nSeqToCompare[0] AND
				stAxis[GVL.cXM].stHall[GVL.cDirPos, stAxis[GVL.cXM].nTripCount].bEdge = bEdgeToCompare[0] THEN
			stAxis[GVL.cXM].fHallPosAct := stAxis[GVL.cXM].fHallPosCal[GVL.cDirPos, stAxis[GVL.cXM].nTripCount];
			stAxis[GVL.cXM].nTripCount := stAxis[GVL.cXM].nTripCount - 1;	
			//track difference between hall sensor and encoder data at trip point
			stAxis[GVL.cXM].fPosDiffAtTrip := stAxis[GVL.cXM].axisRef.NcToPlc.ActPos - stAxis[GVL.cXM].fHallPosAct;
			stAxis[GVL.cXM].bTrackedFlag:=TRUE;
			nGoNextSeq := TRUE;
			
			IF bInMotion AND MAIN.outShutterStatus.smState<>E_StatesMaint.Calibrating THEN
				nAxisID:= GVL.cXM;
				tDcTime:=F_GetCurDcTaskTime64() AND nMask;
				stMotionDone[GVL.cXM].trans[stMotionDone[GVL.cXM].ntrans].dcTime := GVL.nInputEventTime[nHallID[1]]+tDcTime;
				stMotionDone[GVL.cXM].trans[stMotionDone[GVL.cXM].ntrans].id := nHallID[1];
				stMotionDone[GVL.cXM].trans[stMotionDone[GVL.cXM].ntrans].on := bEdgeToCompare[1];
				stMotionDone[GVL.cXM].trans[stMotionDone[GVL.cXM].ntrans].pos := stAxis[GVL.cXM].fHallPosAct;
				stMotionDone[GVL.cXM].ntrans := stMotionDone[GVL.cXM].ntrans +1;
				
				stMotionDone[GVL.cXM].samples[stMotionDone[GVL.cXM].nsamples].dcTime := F_GetCurDcTaskTime64();
				stMotionDone[GVL.cXM].samples[stMotionDone[GVL.cXM].nsamples].pos := stAxis[GVL.cXM].axisRef.NcToPlc.ActPos;
				stMotionDone[GVL.cXM].nsamples := stMotionDone[GVL.cXM].nsamples + 1;
			END_IF
			
		END_IF
		//Compare current sequence with recorded sequence. Update position if match. Negative direction.
		IF stAxis[GVL.cXM].axisRef.status.NegativeDirection AND stAxis[GVL.cXM].stHall[GVL.cDirNeg, stAxis[GVL.cXM].nTripCount].nSeq = nSeqToCompare[0] AND
				stAxis[GVL.cXM].stHall[GVL.cDirNeg, stAxis[GVL.cXM].nTripCount].bEdge = bEdgeToCompare[0] THEN
			stAxis[GVL.cXM].fHallPosAct := stAxis[GVL.cXM].fHallPosCal[GVL.cDirNeg, stAxis[GVL.cXM].nTripCount];
			stAxis[GVL.cXM].nTripCount := stAxis[GVL.cXM].nTripCount + 1;	
			//track difference between hall sensor and encoder data at trip point
			stAxis[GVL.cXM].fPosDiffAtTrip := stAxis[GVL.cXM].axisRef.NcToPlc.ActPos - stAxis[GVL.cXM].fHallPosAct;
			stAxis[GVL.cXM].bTrackedFlag:=TRUE;
			nGoNextSeq := TRUE;
			
			IF bInMotion AND MAIN.outShutterStatus.smState<>E_StatesMaint.Calibrating THEN
				nAxisID:= GVL.cXM;
				tDcTime:=F_GetCurDcTaskTime64() AND nMask;
				stMotionDone[GVL.cXM].trans[stMotionDone[GVL.cXM].ntrans].dcTime := GVL.nInputEventTime[nHallID[1]]+tDcTime;
				stMotionDone[GVL.cXM].trans[stMotionDone[GVL.cXM].ntrans].id := nHallID[1];
				stMotionDone[GVL.cXM].trans[stMotionDone[GVL.cXM].ntrans].on := bEdgeToCompare[1];
				stMotionDone[GVL.cXM].trans[stMotionDone[GVL.cXM].ntrans].pos := stAxis[GVL.cXM].fHallPosAct;
				stMotionDone[GVL.cXM].ntrans := stMotionDone[GVL.cXM].ntrans +1;
				
				stMotionDone[GVL.cXM].samples[stMotionDone[GVL.cXM].nsamples].dcTime := F_GetCurDcTaskTime64();
				stMotionDone[GVL.cXM].samples[stMotionDone[GVL.cXM].nsamples].pos := stAxis[GVL.cXM].axisRef.NcToPlc.ActPos;
				stMotionDone[GVL.cXM].nsamples := stMotionDone[GVL.cXM].nsamples + 1;
			END_IF
			
		END_IF
	END_IF
	
END_IF

//Double blade motion tracking. If not already tracked in the first sequence then second sequence MUST be for the untracked blade
IF bDoubleTrip THEN
	IF NOT stAxis[GVL.cXP].bTrackedFlag THEN
		//Compare current sequence with recorded sequence. Update position if match. Positive direction.
		IF stAxis[GVL.cXP].axisRef.status.PositiveDirection THEN
			stAxis[GVL.cXP].fHallPosAct := stAxis[GVL.cXP].fHallPosCal[GVL.cDirPos, stAxis[GVL.cXP].nTripCount];
			stAxis[GVL.cXP].nTripCount := stAxis[GVL.cXP].nTripCount + 1;
			//track difference between hall sensor and encoder data at trip point
			stAxis[GVL.cXP].fPosDiffAtTrip := stAxis[GVL.cXP].axisRef.NcToPlc.ActPos - stAxis[GVL.cXP].fHallPosAct;
			stAxis[GVL.cXP].bTrackedFlag:=TRUE;
			
	
		END_IF
		//Compare current sequence with recorded sequence. Update position if match. Negative direction.
		IF stAxis[GVL.cXP].axisRef.status.NegativeDirection THEN
			stAxis[GVL.cXP].fHallPosAct := stAxis[GVL.cXP].fHallPosCal[GVL.cDirNeg, stAxis[GVL.cXP].nTripCount];
			stAxis[GVL.cXP].nTripCount := stAxis[GVL.cXP].nTripCount - 1;		
			//track difference between hall sensor and encoder data at trip point
			stAxis[GVL.cXP].fPosDiffAtTrip := stAxis[GVL.cXP].axisRef.NcToPlc.ActPos - stAxis[GVL.cXP].fHallPosAct;
			stAxis[GVL.cXP].bTrackedFlag:=TRUE;
			

		END_IF
	END_IF
	
	IF NOT stAxis[GVL.cXM].bTrackedFlag THEN
		//Compare current sequence with recorded sequence. Update position if match. Positive direction.
		IF stAxis[GVL.cXM].axisRef.status.PositiveDirection THEN
			stAxis[GVL.cXM].fHallPosAct := stAxis[GVL.cXM].fHallPosCal[GVL.cDirPos, stAxis[GVL.cXM].nTripCount];
			stAxis[GVL.cXM].nTripCount := stAxis[GVL.cXM].nTripCount - 1;	
			//track difference between hall sensor and encoder data at trip point
			stAxis[GVL.cXM].fPosDiffAtTrip := stAxis[GVL.cXM].axisRef.NcToPlc.ActPos - stAxis[GVL.cXM].fHallPosAct;
			stAxis[GVL.cXM].bTrackedFlag:=TRUE;
			

		END_IF
		//Compare current sequence with recorded sequence. Update position if match. Negative direction.
		IF stAxis[GVL.cXM].axisRef.status.NegativeDirection THEN
			stAxis[GVL.cXM].fHallPosAct := stAxis[GVL.cXM].fHallPosCal[GVL.cDirNeg, stAxis[GVL.cXM].nTripCount];
			stAxis[GVL.cXM].nTripCount := stAxis[GVL.cXM].nTripCount + 1;	
			//track difference between hall sensor and encoder data at trip point
			stAxis[GVL.cXM].fPosDiffAtTrip := stAxis[GVL.cXM].axisRef.NcToPlc.ActPos - stAxis[GVL.cXM].fHallPosAct;
			stAxis[GVL.cXM].bTrackedFlag:=TRUE;
			
		END_IF
	END_IF
END_IF
]]></ST>
    </Implementation>
    <LineIds Name="FB_Tracking">
      <LineId Id="1021" Count="1" />
      <LineId Id="1024" Count="6" />
      <LineId Id="1818" Count="0" />
      <LineId Id="1288" Count="3" />
      <LineId Id="1294" Count="5" />
      <LineId Id="1544" Count="0" />
      <LineId Id="1815" Count="0" />
      <LineId Id="1822" Count="0" />
      <LineId Id="1816" Count="0" />
      <LineId Id="1819" Count="0" />
      <LineId Id="1835" Count="6" />
      <LineId Id="1820" Count="0" />
      <LineId Id="1824" Count="0" />
      <LineId Id="1817" Count="0" />
      <LineId Id="1826" Count="0" />
      <LineId Id="1842" Count="6" />
      <LineId Id="1827" Count="0" />
      <LineId Id="1825" Count="0" />
      <LineId Id="1347" Count="0" />
      <LineId Id="1852" Count="1" />
      <LineId Id="1855" Count="2" />
      <LineId Id="1311" Count="0" />
      <LineId Id="1313" Count="0" />
      <LineId Id="1425" Count="0" />
      <LineId Id="1550" Count="0" />
      <LineId Id="1543" Count="0" />
      <LineId Id="1814" Count="0" />
      <LineId Id="1670" Count="0" />
      <LineId Id="1551" Count="0" />
      <LineId Id="1859" Count="1" />
      <LineId Id="1421" Count="0" />
      <LineId Id="1507" Count="0" />
      <LineId Id="1426" Count="0" />
      <LineId Id="1287" Count="0" />
      <LineId Id="1031" Count="0" />
      <LineId Id="1141" Count="0" />
      <LineId Id="1032" Count="3" />
      <LineId Id="1462" Count="0" />
      <LineId Id="1468" Count="0" />
      <LineId Id="1471" Count="0" />
      <LineId Id="1036" Count="1" />
      <LineId Id="1472" Count="0" />
      <LineId Id="1038" Count="19" />
      <LineId Id="1459" Count="1" />
      <LineId Id="1059" Count="5" />
      <LineId Id="1315" Count="0" />
      <LineId Id="1338" Count="0" />
      <LineId Id="1380" Count="0" />
      <LineId Id="1717" Count="0" />
      <LineId Id="1388" Count="1" />
      <LineId Id="1381" Count="0" />
      <LineId Id="1386" Count="0" />
      <LineId Id="1385" Count="0" />
      <LineId Id="1390" Count="0" />
      <LineId Id="1378" Count="0" />
      <LineId Id="1340" Count="0" />
      <LineId Id="1316" Count="0" />
      <LineId Id="1065" Count="2" />
      <LineId Id="1463" Count="0" />
      <LineId Id="1068" Count="5" />
      <LineId Id="1317" Count="0" />
      <LineId Id="1391" Count="9" />
      <LineId Id="1337" Count="0" />
      <LineId Id="1318" Count="0" />
      <LineId Id="1074" Count="6" />
      <LineId Id="1464" Count="0" />
      <LineId Id="1081" Count="3" />
      <LineId Id="1142" Count="0" />
      <LineId Id="1085" Count="0" />
      <LineId Id="1319" Count="0" />
      <LineId Id="1401" Count="9" />
      <LineId Id="1336" Count="0" />
      <LineId Id="1320" Count="0" />
      <LineId Id="1086" Count="2" />
      <LineId Id="1465" Count="0" />
      <LineId Id="1089" Count="3" />
      <LineId Id="1143" Count="0" />
      <LineId Id="1093" Count="0" />
      <LineId Id="1335" Count="0" />
      <LineId Id="1411" Count="9" />
      <LineId Id="1321" Count="1" />
      <LineId Id="1094" Count="14" />
      <LineId Id="1334" Count="0" />
      <LineId Id="1324" Count="0" />
      <LineId Id="1109" Count="7" />
      <LineId Id="1333" Count="0" />
      <LineId Id="1326" Count="0" />
      <LineId Id="1117" Count="10" />
      <LineId Id="1332" Count="0" />
      <LineId Id="1328" Count="0" />
      <LineId Id="1128" Count="7" />
      <LineId Id="1329" Count="2" />
      <LineId Id="1136" Count="2" />
      <LineId Id="9" Count="0" />
      <LineId Id="236" Count="1" />
      <LineId Id="240" Count="3" />
      <LineId Id="2" Count="0" />
    </LineIds>
  </POU>
</TcPlcObject>
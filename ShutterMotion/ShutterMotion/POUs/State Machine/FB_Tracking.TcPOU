<?xml version="1.0" encoding="utf-8"?>
<TcPlcObject Version="1.1.0.1" ProductVersion="3.1.4022.18">
  <POU Name="FB_Tracking" Id="{462a5933-fe60-42d4-a574-27170521c4c5}" SpecialFunc="None">
    <Declaration><![CDATA[FUNCTION_BLOCK FB_Tracking
VAR_IN_OUT
	stAxis  : ARRAY [GVL.cXP .. GVL.cXM] OF ST_AxisGroup;	
END_VAR
VAR
	//used in tracking Action
	bXorResult : BOOL;
	
	//counter
	i 	: INT :=0;
END_VAR
]]></Declaration>
    <Implementation>
      <ST><![CDATA[//////////////////////////////////////////////////////////////
//Algorithm for tracking blade position using hall switches	//
//////////////////////////////////////////////////////////////

//Only one hall will ever trip for 1 set of blades. This flag is used to make sure the trip increment only once per cycle.
stAxis[GVL.cXP].bTrackedFlag := FALSE;
stAxis[GVL.cXM].bTrackedFlag := FALSE;

//Hall sensors position tracking for axis XP
FOR i:=GVL.cHallLower TO GVL.cHallUpper BY 1 DO
	stAxis[GVL.cXP].fbHallSigCal_rtrig[i](CLK:=GVL.bHallSwitch[i]);
	stAxis[GVL.cXP].fbHallSigCal_ftrig[i](CLK:=GVL.bHallSwitch[i]);
	IF (stAxis[GVL.cXP].fbHallSigCal_rtrig[i].Q OR stAxis[GVL.cXP].fbHallSigCal_ftrig[i].Q) AND stAxis[GVL.cXP].axisRef.Status.Moving THEN
		stAxis[GVL.cXP].bTrackedFlag := TRUE;
	END_IF
END_FOR
	
IF stAxis[GVL.cXP].bTrackedFlag THEN
	//record trigger status of each hall sensor into hallSequence for comparing;
	GVL.nHallSequence.0 := stAxis[GVL.cXP].fbHallSigCal_rtrig[0].Q OR stAxis[GVL.cXP].fbHallSigCal_ftrig[0].Q;
	GVL.nHallSequence.1 := stAxis[GVL.cXP].fbHallSigCal_rtrig[1].Q OR stAxis[GVL.cXP].fbHallSigCal_ftrig[1].Q;
	GVL.nHallSequence.2 := stAxis[GVL.cXP].fbHallSigCal_rtrig[2].Q OR stAxis[GVL.cXP].fbHallSigCal_ftrig[2].Q;
	GVL.nHallSequence.3 := stAxis[GVL.cXP].fbHallSigCal_rtrig[3].Q OR stAxis[GVL.cXP].fbHallSigCal_ftrig[3].Q;
	GVL.nHallSequence.4 := stAxis[GVL.cXP].fbHallSigCal_rtrig[4].Q OR stAxis[GVL.cXP].fbHallSigCal_ftrig[4].Q;
	GVL.nHallSequence.5 := stAxis[GVL.cXP].fbHallSigCal_rtrig[5].Q OR stAxis[GVL.cXP].fbHallSigCal_ftrig[5].Q;
	GVL.nHallSequence.6 := stAxis[GVL.cXP].fbHallSigCal_rtrig[6].Q OR stAxis[GVL.cXP].fbHallSigCal_ftrig[6].Q;
	GVL.nHallSequence.7 := stAxis[GVL.cXP].fbHallSigCal_rtrig[7].Q OR stAxis[GVL.cXP].fbHallSigCal_ftrig[7].Q;
	GVL.nHallSequence.8 := stAxis[GVL.cXP].fbHallSigCal_rtrig[8].Q OR stAxis[GVL.cXP].fbHallSigCal_ftrig[8].Q;
	GVL.nHallSequence.9 := stAxis[GVL.cXP].fbHallSigCal_rtrig[9].Q OR stAxis[GVL.cXP].fbHallSigCal_ftrig[9].Q;
	GVL.nHallSequence.10 := stAxis[GVL.cXP].fbHallSigCal_rtrig[10].Q OR stAxis[GVL.cXP].fbHallSigCal_ftrig[10].Q;
	GVL.nHallSequence.11 := stAxis[GVL.cXP].fbHallSigCal_rtrig[11].Q OR stAxis[GVL.cXP].fbHallSigCal_ftrig[11].Q;
	GVL.nHallSequence.12 := stAxis[GVL.cXP].fbHallSigCal_rtrig[12].Q OR stAxis[GVL.cXP].fbHallSigCal_ftrig[12].Q;
	GVL.nHallSequence.13 := stAxis[GVL.cXP].fbHallSigCal_rtrig[13].Q OR stAxis[GVL.cXP].fbHallSigCal_ftrig[13].Q;
	GVL.nHallSequence.14 := stAxis[GVL.cXP].fbHallSigCal_rtrig[14].Q OR stAxis[GVL.cXP].fbHallSigCal_ftrig[14].Q;	

	(* Unary XOR of hallSequence. With one blade running, 1 bit should be HIGH at a time .
		Result of 1 indicates presence of one blade sequence. Result of 0 indicates presence of two blade sequence *)
	bXorResult := (GVL.nHallSequence.0 XOR GVL.nHallSequence.1 XOR GVL.nHallSequence.2 XOR GVL.nHallSequence.3 XOR GVL.nHallSequence.4 XOR
		GVL.nHallSequence.5 XOR GVL.nHallSequence.6 XOR GVL.nHallSequence.7 XOR GVL.nHallSequence.8 XOR GVL.nHallSequence.9 XOR
		GVL.nHallSequence.10 XOR GVL.nHallSequence.11 XOR GVL.nHallSequence.12 XOR GVL.nHallSequence.13 XOR GVL.nHallSequence.14);
	IF bXorResult THEN
		stAxis[GVL.cXP].nSeqToCompare := GVL.nHallSequence;
	ELSIF stAxis[GVL.cXM].axisRef.status.PositiveDirection THEN
		stAxis[GVL.cXP].nSeqToCompare := (GVL.nHallSequence XOR stAxis[GVL.cXM].nHallSequence[GVL.cDirPos, stAxis[GVL.cXM].nTripCount]);
	ELSIF stAxis[GVL.cXM].axisRef.status.NegativeDirection THEN
		stAxis[GVL.cXP].nSeqToCompare := (GVL.nHallSequence XOR stAxis[GVL.cXM].nHallSequence[GVL.cDirNeg, stAxis[GVL.cXM].nTripCount]);	
	ELSE
		; //Should generate error code here
	END_IF	

	//Compare current sequence with recorded sequence. Update position if match.
	IF stAxis[GVL.cXP].axisRef.status.PositiveDirection AND stAxis[GVL.cXP].nHallSequence[GVL.cDirPos, stAxis[GVL.cXP].nTripCount] = stAxis[GVL.cXP].nSeqToCompare THEN
		stAxis[GVL.cXP].fHallPosAct := stAxis[GVL.cXP].fHallPosCal[GVL.cDirPos, stAxis[GVL.cXP].nTripCount];
		stAxis[GVL.cXP].nTripCount := stAxis[GVL.cXP].nTripCount + 1;

		//testing purposes only. Will delete later.
		FOR i:= 1000 TO 1 BY -1 DO
			stAxis[GVL.cXP].fRecordedPosition[i] := stAxis[GVL.cXP].fRecordedPosition[i-1];
		END_FOR
		stAxis[GVL.cXP].fRecordedPosition[1] := stAxis[GVL.cXP].fHallPosAct;
	
		
		//track difference between hall sensor and encoder data at trip point
		stAxis[GVL.cXP].fPosDiffAtTrip := stAxis[GVL.cXP].axisRef.NcToPlc.ActPos - stAxis[GVL.cXP].fHallPosAct;
	END_IF
	IF stAxis[GVL.cXP].axisRef.status.NegativeDirection AND stAxis[GVL.cXP].nHallSequence[GVL.cDirNeg, stAxis[GVL.cXP].nTripCount] = stAxis[GVL.cXP].nSeqToCompare THEN
		stAxis[GVL.cXP].fHallPosAct := stAxis[GVL.cXP].fHallPosCal[GVL.cDirNeg, stAxis[GVL.cXP].nTripCount];
		stAxis[GVL.cXP].nTripCount := stAxis[GVL.cXP].nTripCount - 1;	
		
		//testing purposes only. Will delete later.
		FOR i:= 1000 TO 1 BY -1 DO
			stAxis[GVL.cXP].fRecordedPosition[i] := stAxis[GVL.cXP].fRecordedPosition[i-1];
		END_FOR
		stAxis[GVL.cXP].fRecordedPosition[1] := stAxis[GVL.cXP].fHallPosAct;		
		
		
		//track difference between hall sensor and encoder data at trip point
		stAxis[GVL.cXP].fPosDiffAtTrip := stAxis[GVL.cXP].axisRef.NcToPlc.ActPos - stAxis[GVL.cXP].fHallPosAct;
	END_IF
END_IF


//Hall sensors position tracking for axis XM
FOR i:=GVL.cHallLower TO GVL.cHallUpper BY 1 DO
	stAxis[GVL.cXM].fbHallSigCal_rtrig[i](CLK:=GVL.bHallSwitch[i]);
	stAxis[GVL.cXM].fbHallSigCal_ftrig[i](CLK:=GVL.bHallSwitch[i]);
	IF (stAxis[GVL.cXM].fbHallSigCal_rtrig[i].Q OR stAxis[GVL.cXM].fbHallSigCal_ftrig[i].Q) AND stAxis[GVL.cXM].axisRef.Status.Moving AND NOT stAxis[GVL.cXM].bTrackedFlag THEN
		stAxis[GVL.cXM].bTrackedFlag := TRUE;
	END_IF
END_FOR

IF stAxis[GVL.cXM].bTrackedFlag THEN
	
	//record trigger status of each hall sensor into hallSequence for comparing;
	GVL.nHallSequence.0 := stAxis[GVL.cXM].fbHallSigCal_rtrig[0].Q OR stAxis[GVL.cXM].fbHallSigCal_ftrig[0].Q;
	GVL.nHallSequence.1 := stAxis[GVL.cXM].fbHallSigCal_rtrig[1].Q OR stAxis[GVL.cXM].fbHallSigCal_ftrig[1].Q;
	GVL.nHallSequence.2 := stAxis[GVL.cXM].fbHallSigCal_rtrig[2].Q OR stAxis[GVL.cXM].fbHallSigCal_ftrig[2].Q;
	GVL.nHallSequence.3 := stAxis[GVL.cXM].fbHallSigCal_rtrig[3].Q OR stAxis[GVL.cXM].fbHallSigCal_ftrig[3].Q;
	GVL.nHallSequence.4 := stAxis[GVL.cXM].fbHallSigCal_rtrig[4].Q OR stAxis[GVL.cXM].fbHallSigCal_ftrig[4].Q;
	GVL.nHallSequence.5 := stAxis[GVL.cXM].fbHallSigCal_rtrig[5].Q OR stAxis[GVL.cXM].fbHallSigCal_ftrig[5].Q;
	GVL.nHallSequence.6 := stAxis[GVL.cXM].fbHallSigCal_rtrig[6].Q OR stAxis[GVL.cXM].fbHallSigCal_ftrig[6].Q;
	GVL.nHallSequence.7 := stAxis[GVL.cXM].fbHallSigCal_rtrig[7].Q OR stAxis[GVL.cXM].fbHallSigCal_ftrig[7].Q;
	GVL.nHallSequence.8 := stAxis[GVL.cXM].fbHallSigCal_rtrig[8].Q OR stAxis[GVL.cXM].fbHallSigCal_ftrig[8].Q;
	GVL.nHallSequence.9 := stAxis[GVL.cXM].fbHallSigCal_rtrig[9].Q OR stAxis[GVL.cXM].fbHallSigCal_ftrig[9].Q;
	GVL.nHallSequence.10 := stAxis[GVL.cXM].fbHallSigCal_rtrig[10].Q OR stAxis[GVL.cXM].fbHallSigCal_ftrig[10].Q;
	GVL.nHallSequence.11 := stAxis[GVL.cXM].fbHallSigCal_rtrig[11].Q OR stAxis[GVL.cXM].fbHallSigCal_ftrig[11].Q;
	GVL.nHallSequence.12 := stAxis[GVL.cXM].fbHallSigCal_rtrig[12].Q OR stAxis[GVL.cXM].fbHallSigCal_ftrig[12].Q;
	GVL.nHallSequence.13 := stAxis[GVL.cXM].fbHallSigCal_rtrig[13].Q OR stAxis[GVL.cXM].fbHallSigCal_ftrig[13].Q;
	GVL.nHallSequence.14 := stAxis[GVL.cXM].fbHallSigCal_rtrig[14].Q OR stAxis[GVL.cXM].fbHallSigCal_ftrig[14].Q;			
	
	(* Unary XOR of hallSequence. With one blade running, 1 bit should be HIGH at a time .
		Result of 1 indicates presence of one blade sequence. Result of 0 indicates presence of two blade sequence *)
	bXorResult := GVL.nHallSequence.0 XOR GVL.nHallSequence.1 XOR GVL.nHallSequence.2 XOR GVL.nHallSequence.3 XOR GVL.nHallSequence.4 XOR
		GVL.nHallSequence.5 XOR GVL.nHallSequence.6 XOR GVL.nHallSequence.7 XOR GVL.nHallSequence.8 XOR GVL.nHallSequence.9 XOR
		GVL.nHallSequence.10 XOR GVL.nHallSequence.11 XOR GVL.nHallSequence.12 XOR GVL.nHallSequence.13 XOR GVL.nHallSequence.14;
	IF bXorResult THEN
		stAxis[GVL.cXM].nSeqToCompare := GVL.nHallSequence;
	ELSIF stAxis[GVL.cXP].axisRef.status.PositiveDirection THEN
		stAxis[GVL.cXM].nSeqToCompare := (GVL.nHallSequence XOR stAxis[GVL.cXP].nHallSequence[GVL.cDirPos, stAxis[GVL.cXP].nTripCount-1]); //requires -1 since XP tripcount has already decremented
	ELSIF stAxis[GVL.cXP].axisRef.status.NegativeDirection THEN
		stAxis[GVL.cXM].nSeqToCompare := (GVL.nHallSequence XOR stAxis[GVL.cXP].nHallSequence[GVL.cDirNeg, stAxis[GVL.cXP].nTripCount+1]); //requires +1 since XP tripcount has already incremented
	ELSE
		; //Should generate error code here
	END_IF		

	//Compare current sequence with recorded sequence. Update position if match.	
	IF stAxis[GVL.cXM].axisRef.status.PositiveDirection AND stAxis[GVL.cXM].nHallSequence[GVL.cDirPos, stAxis[GVL.cXM].nTripCount] = stAxis[GVL.cXM].nSeqToCompare THEN
		stAxis[GVL.cXM].fHallPosAct := stAxis[GVL.cXM].fHallPosCal[GVL.cDirPos, stAxis[GVL.cXM].nTripCount];
		stAxis[GVL.cXM].nTripCount := stAxis[GVL.cXM].nTripCount - 1;	
		//track difference between hall sensor and encoder data at trip point
		stAxis[GVL.cXM].fPosDiffAtTrip := stAxis[GVL.cXM].axisRef.NcToPlc.ActPos - stAxis[GVL.cXM].fHallPosAct;
	END_IF
	IF stAxis[GVL.cXM].axisRef.status.NegativeDirection AND stAxis[GVL.cXM].nHallSequence[GVL.cDirNeg, stAxis[GVL.cXM].nTripCount] = stAxis[GVL.cXM].nSeqToCompare THEN
		stAxis[GVL.cXM].fHallPosAct := stAxis[GVL.cXM].fHallPosCal[GVL.cDirNeg, stAxis[GVL.cXM].nTripCount];
		stAxis[GVL.cXM].nTripCount := stAxis[GVL.cXM].nTripCount + 1;	
		//track difference between hall sensor and encoder data at trip point
		stAxis[GVL.cXM].fPosDiffAtTrip := stAxis[GVL.cXM].axisRef.NcToPlc.ActPos - stAxis[GVL.cXM].fHallPosAct;
	END_IF
END_IF



]]></ST>
    </Implementation>
    <LineIds Name="FB_Tracking">
      <LineId Id="10" Count="141" />
      <LineId Id="9" Count="0" />
    </LineIds>
  </POU>
</TcPlcObject>
<?xml version="1.0" encoding="utf-8"?>
<TcPlcObject Version="1.1.0.1" ProductVersion="3.1.4020.12">
  <POU Name="FB_Tracking" Id="{462a5933-fe60-42d4-a574-27170521c4c5}" SpecialFunc="None">
    <Declaration><![CDATA[FUNCTION_BLOCK FB_Tracking
VAR_IN_OUT
	stAxis  : ARRAY [GVL.cXP .. GVL.cXM] OF ST_AxisGroup;	
END_VAR
VAR
	//used in tracking Action
	nSeqToCompare : ARRAY [0 ..  1] OF WORD;
	bXorResult 	: BOOL;
	nSeqTime	: ARRAY [0 .. 1] OF UDINT;
	bValidInput	: BOOL;
	bDoubleTrip	: BOOL;
	nGoNextSeq	: BOOL;
	
	fbRtrig		: ARRAY[GVL.cHallLower..GVL.cHallUpper] OF R_Trig;
	
	//counter
	i, j	: INT :=0;
	
	//TestVar
	testInt: INT;
END_VAR
]]></Declaration>
    <Implementation>
      <ST><![CDATA[(*
//////////////////////////////////////////////////////////////
//Algorithm for tracking blade position using hall switches	//
//////////////////////////////////////////////////////////////
//Only one hall will ever trip for 1 set of blades. This flag is used to make sure the trip increment only once per cycle.
bValidInput:=FALSE;
bDoubleTrip:=FALSE;
nGoNextSeq := FALSE;
stAxis[GVL.cXP].bTrackedFlag:=FALSE;
stAxis[GVL.cXM].bTrackedFlag:=FALSE;
j:=0;
//Detect hall switch transitions
FOR i:=GVL.cHallLower TO GVL.cHallUpper BY 1 DO
	IF GVL.nNumOfInputs[i]=1 THEN
		//identifies which hall switch tripped
		nSeqToCompare[j] := INT_TO_WORD((i*10)+5);
		//along with the trip time
		stAxis[GVL.cXP].nHallTime := GVL.nInputEventTime[i];
		//increment the index
		j:=j+1;
		bValidInput:=TRUE;
		IF j=2 THEN
			bDoubleTrip:=TRUE;
		END_IF
	END_IF
	
	IF GVL.nNumOfInputs[i]=2 THEN
		testInt:=testint+1;
	END_IF
	
END_FOR
	
//Single blade motion tracking
IF bValidInput THEN
	
	//Hall sensors position tracking for axis XP
	IF stAxis[GVL.cXP].axisRef.Status.Moving AND NOT nGoNextSeq THEN
		//Compare current sequence with recorded sequence. Update position if match. Positive direction.
		IF stAxis[GVL.cXP].axisRef.status.PositiveDirection AND stAxis[GVL.cXP].nHallSequence[GVL.cDirPos, stAxis[GVL.cXP].nTripCount] = nSeqToCompare[0] THEN
			stAxis[GVL.cXP].fHallPosAct := stAxis[GVL.cXP].fHallPosCal[GVL.cDirPos, stAxis[GVL.cXP].nTripCount];
			stAxis[GVL.cXP].nTripCount := stAxis[GVL.cXP].nTripCount + 1;
			//track difference between hall sensor and encoder data at trip point
			stAxis[GVL.cXP].fPosDiffAtTrip := stAxis[GVL.cXP].axisRef.NcToPlc.ActPos - stAxis[GVL.cXP].fHallPosAct;
			stAxis[GVL.cXP].bTrackedFlag:=TRUE;
			nGoNextSeq := TRUE;
		END_IF
		//Compare current sequence with recorded sequence. Update position if match. Negative direction.
		IF stAxis[GVL.cXP].axisRef.status.NegativeDirection AND stAxis[GVL.cXP].nHallSequence[GVL.cDirNeg, stAxis[GVL.cXP].nTripCount] = nSeqToCompare[0] THEN
			stAxis[GVL.cXP].fHallPosAct := stAxis[GVL.cXP].fHallPosCal[GVL.cDirNeg, stAxis[GVL.cXP].nTripCount];
			stAxis[GVL.cXP].nTripCount := stAxis[GVL.cXP].nTripCount - 1;		
			//track difference between hall sensor and encoder data at trip point
			stAxis[GVL.cXP].fPosDiffAtTrip := stAxis[GVL.cXP].axisRef.NcToPlc.ActPos - stAxis[GVL.cXP].fHallPosAct;
			stAxis[GVL.cXP].bTrackedFlag:=TRUE;
			nGoNextSeq := TRUE;
		END_IF
	END_IF
	
	//Hall sensors position tracking for axis XM
	IF stAxis[GVL.cXM].axisRef.Status.Moving AND NOT nGoNextSeq THEN
		//Compare current sequence with recorded sequence. Update position if match. Positive direction.
		IF stAxis[GVL.cXM].axisRef.status.PositiveDirection AND stAxis[GVL.cXM].nHallSequence[GVL.cDirPos, stAxis[GVL.cXM].nTripCount] = nSeqToCompare[0] THEN
			stAxis[GVL.cXM].fHallPosAct := stAxis[GVL.cXM].fHallPosCal[GVL.cDirPos, stAxis[GVL.cXM].nTripCount];
			stAxis[GVL.cXM].nTripCount := stAxis[GVL.cXM].nTripCount - 1;	
			//track difference between hall sensor and encoder data at trip point
			stAxis[GVL.cXM].fPosDiffAtTrip := stAxis[GVL.cXM].axisRef.NcToPlc.ActPos - stAxis[GVL.cXM].fHallPosAct;
			stAxis[GVL.cXM].bTrackedFlag:=TRUE;
		END_IF
		//Compare current sequence with recorded sequence. Update position if match. Negative direction.
		IF stAxis[GVL.cXM].axisRef.status.NegativeDirection AND stAxis[GVL.cXM].nHallSequence[GVL.cDirNeg, stAxis[GVL.cXM].nTripCount] = nSeqToCompare[0] THEN
			stAxis[GVL.cXM].fHallPosAct := stAxis[GVL.cXM].fHallPosCal[GVL.cDirNeg, stAxis[GVL.cXM].nTripCount];
			stAxis[GVL.cXM].nTripCount := stAxis[GVL.cXM].nTripCount + 1;	
			//track difference between hall sensor and encoder data at trip point
			stAxis[GVL.cXM].fPosDiffAtTrip := stAxis[GVL.cXM].axisRef.NcToPlc.ActPos - stAxis[GVL.cXM].fHallPosAct;
			stAxis[GVL.cXM].bTrackedFlag:=TRUE;
		END_IF
	END_IF
	
END_IF

//Double blade motion tracking. If not already tracked in the first sequence then second sequence MUST be for the untracked blade
IF bDoubleTrip THEN
	IF NOT stAxis[GVL.cXP].bTrackedFlag THEN
		//Compare current sequence with recorded sequence. Update position if match. Positive direction.
		IF stAxis[GVL.cXP].axisRef.status.PositiveDirection THEN
			stAxis[GVL.cXP].fHallPosAct := stAxis[GVL.cXP].fHallPosCal[GVL.cDirPos, stAxis[GVL.cXP].nTripCount];
			stAxis[GVL.cXP].nTripCount := stAxis[GVL.cXP].nTripCount + 1;
			//track difference between hall sensor and encoder data at trip point
			stAxis[GVL.cXP].fPosDiffAtTrip := stAxis[GVL.cXP].axisRef.NcToPlc.ActPos - stAxis[GVL.cXP].fHallPosAct;
			stAxis[GVL.cXP].bTrackedFlag:=TRUE;
		END_IF
		//Compare current sequence with recorded sequence. Update position if match. Negative direction.
		IF stAxis[GVL.cXP].axisRef.status.NegativeDirection THEN
			stAxis[GVL.cXP].fHallPosAct := stAxis[GVL.cXP].fHallPosCal[GVL.cDirNeg, stAxis[GVL.cXP].nTripCount];
			stAxis[GVL.cXP].nTripCount := stAxis[GVL.cXP].nTripCount - 1;		
			//track difference between hall sensor and encoder data at trip point
			stAxis[GVL.cXP].fPosDiffAtTrip := stAxis[GVL.cXP].axisRef.NcToPlc.ActPos - stAxis[GVL.cXP].fHallPosAct;
			stAxis[GVL.cXP].bTrackedFlag:=TRUE;
		END_IF
	END_IF
	
	IF NOT stAxis[GVL.cXM].bTrackedFlag THEN
		//Compare current sequence with recorded sequence. Update position if match. Positive direction.
		IF stAxis[GVL.cXM].axisRef.status.PositiveDirection THEN
			stAxis[GVL.cXM].fHallPosAct := stAxis[GVL.cXM].fHallPosCal[GVL.cDirPos, stAxis[GVL.cXM].nTripCount];
			stAxis[GVL.cXM].nTripCount := stAxis[GVL.cXM].nTripCount - 1;	
			//track difference between hall sensor and encoder data at trip point
			stAxis[GVL.cXM].fPosDiffAtTrip := stAxis[GVL.cXM].axisRef.NcToPlc.ActPos - stAxis[GVL.cXM].fHallPosAct;
			stAxis[GVL.cXM].bTrackedFlag:=TRUE;
		END_IF
		//Compare current sequence with recorded sequence. Update position if match. Negative direction.
		IF stAxis[GVL.cXM].axisRef.status.NegativeDirection THEN
			stAxis[GVL.cXM].fHallPosAct := stAxis[GVL.cXM].fHallPosCal[GVL.cDirNeg, stAxis[GVL.cXM].nTripCount];
			stAxis[GVL.cXM].nTripCount := stAxis[GVL.cXM].nTripCount + 1;	
			//track difference between hall sensor and encoder data at trip point
			stAxis[GVL.cXM].fPosDiffAtTrip := stAxis[GVL.cXM].axisRef.NcToPlc.ActPos - stAxis[GVL.cXM].fHallPosAct;
			stAxis[GVL.cXM].bTrackedFlag:=TRUE;
		END_IF
	END_IF
END_IF
*)


//////////////////////////////////////////////////////////////
//Algorithm for tracking blade position using hall switches	//
//////////////////////////////////////////////////////////////
bValidInput:=FALSE;
bDoubleTrip:=FALSE;
nGoNextSeq := FALSE;
stAxis[GVL.cXP].bTrackedFlag:=FALSE;
stAxis[GVL.cXM].bTrackedFlag:=FALSE;
j:=0;
//Detect hall switch transitions
FOR i:=GVL.cHallLower TO GVL.cHallUpper BY 1 DO
	fbRtrig[i](CLK:=GVL.nNumOfInputs[i].0);
	IF fbRtrig[i].Q THEN
		//identifies which hall switch tripped
		nSeqToCompare[j] := INT_TO_WORD((i*10)+5);
		//along with the trip time
		stAxis[GVL.cXP].nHallTime := GVL.nInputEventTime[i];
		//increment the index
		j:=j+1;
		bValidInput:=TRUE;
		IF j=2 THEN
			bDoubleTrip:=TRUE;
		END_IF
	END_IF
	
	IF GVL.nNumOfInputs[i]=2 THEN
		testInt:=testint+1;
	END_IF
	
END_FOR
	
//Single blade motion tracking
IF bValidInput THEN
	
	//Hall sensors position tracking for axis XP
	IF stAxis[GVL.cXP].axisRef.Status.Moving AND NOT nGoNextSeq THEN
		//Compare current sequence with recorded sequence. Update position if match. Positive direction.
		IF stAxis[GVL.cXP].axisRef.status.PositiveDirection AND stAxis[GVL.cXP].nHallSequence[GVL.cDirPos, stAxis[GVL.cXP].nTripCount] = nSeqToCompare[0] THEN
			stAxis[GVL.cXP].fHallPosAct := stAxis[GVL.cXP].fHallPosCal[GVL.cDirPos, stAxis[GVL.cXP].nTripCount];
			stAxis[GVL.cXP].nTripCount := stAxis[GVL.cXP].nTripCount + 1;
			//track difference between hall sensor and encoder data at trip point
			stAxis[GVL.cXP].fPosDiffAtTrip := stAxis[GVL.cXP].axisRef.NcToPlc.ActPos - stAxis[GVL.cXP].fHallPosAct;
			stAxis[GVL.cXP].bTrackedFlag:=TRUE;
			nGoNextSeq := TRUE;
		END_IF
		//Compare current sequence with recorded sequence. Update position if match. Negative direction.
		IF stAxis[GVL.cXP].axisRef.status.NegativeDirection AND stAxis[GVL.cXP].nHallSequence[GVL.cDirNeg, stAxis[GVL.cXP].nTripCount] = nSeqToCompare[0] THEN
			stAxis[GVL.cXP].fHallPosAct := stAxis[GVL.cXP].fHallPosCal[GVL.cDirNeg, stAxis[GVL.cXP].nTripCount];
			stAxis[GVL.cXP].nTripCount := stAxis[GVL.cXP].nTripCount - 1;		
			//track difference between hall sensor and encoder data at trip point
			stAxis[GVL.cXP].fPosDiffAtTrip := stAxis[GVL.cXP].axisRef.NcToPlc.ActPos - stAxis[GVL.cXP].fHallPosAct;
			stAxis[GVL.cXP].bTrackedFlag:=TRUE;
			nGoNextSeq := TRUE;
		END_IF
	END_IF
	
	//Hall sensors position tracking for axis XM
	IF stAxis[GVL.cXM].axisRef.Status.Moving AND NOT nGoNextSeq THEN
		//Compare current sequence with recorded sequence. Update position if match. Positive direction.
		IF stAxis[GVL.cXM].axisRef.status.PositiveDirection AND stAxis[GVL.cXM].nHallSequence[GVL.cDirPos, stAxis[GVL.cXM].nTripCount] = nSeqToCompare[0] THEN
			stAxis[GVL.cXM].fHallPosAct := stAxis[GVL.cXM].fHallPosCal[GVL.cDirPos, stAxis[GVL.cXM].nTripCount];
			stAxis[GVL.cXM].nTripCount := stAxis[GVL.cXM].nTripCount - 1;	
			//track difference between hall sensor and encoder data at trip point
			stAxis[GVL.cXM].fPosDiffAtTrip := stAxis[GVL.cXM].axisRef.NcToPlc.ActPos - stAxis[GVL.cXM].fHallPosAct;
			stAxis[GVL.cXM].bTrackedFlag:=TRUE;
			nGoNextSeq := TRUE;
		END_IF
		//Compare current sequence with recorded sequence. Update position if match. Negative direction.
		IF stAxis[GVL.cXM].axisRef.status.NegativeDirection AND stAxis[GVL.cXM].nHallSequence[GVL.cDirNeg, stAxis[GVL.cXM].nTripCount] = nSeqToCompare[0] THEN
			stAxis[GVL.cXM].fHallPosAct := stAxis[GVL.cXM].fHallPosCal[GVL.cDirNeg, stAxis[GVL.cXM].nTripCount];
			stAxis[GVL.cXM].nTripCount := stAxis[GVL.cXM].nTripCount + 1;	
			//track difference between hall sensor and encoder data at trip point
			stAxis[GVL.cXM].fPosDiffAtTrip := stAxis[GVL.cXM].axisRef.NcToPlc.ActPos - stAxis[GVL.cXM].fHallPosAct;
			stAxis[GVL.cXM].bTrackedFlag:=TRUE;
			nGoNextSeq := TRUE;
		END_IF
	END_IF
	
END_IF

//Double blade motion tracking. If not already tracked in the first sequence then second sequence MUST be for the untracked blade
IF bDoubleTrip THEN
	IF NOT stAxis[GVL.cXP].bTrackedFlag THEN
		//Compare current sequence with recorded sequence. Update position if match. Positive direction.
		IF stAxis[GVL.cXP].axisRef.status.PositiveDirection THEN
			stAxis[GVL.cXP].fHallPosAct := stAxis[GVL.cXP].fHallPosCal[GVL.cDirPos, stAxis[GVL.cXP].nTripCount];
			stAxis[GVL.cXP].nTripCount := stAxis[GVL.cXP].nTripCount + 1;
			//track difference between hall sensor and encoder data at trip point
			stAxis[GVL.cXP].fPosDiffAtTrip := stAxis[GVL.cXP].axisRef.NcToPlc.ActPos - stAxis[GVL.cXP].fHallPosAct;
			stAxis[GVL.cXP].bTrackedFlag:=TRUE;
		END_IF
		//Compare current sequence with recorded sequence. Update position if match. Negative direction.
		IF stAxis[GVL.cXP].axisRef.status.NegativeDirection THEN
			stAxis[GVL.cXP].fHallPosAct := stAxis[GVL.cXP].fHallPosCal[GVL.cDirNeg, stAxis[GVL.cXP].nTripCount];
			stAxis[GVL.cXP].nTripCount := stAxis[GVL.cXP].nTripCount - 1;		
			//track difference between hall sensor and encoder data at trip point
			stAxis[GVL.cXP].fPosDiffAtTrip := stAxis[GVL.cXP].axisRef.NcToPlc.ActPos - stAxis[GVL.cXP].fHallPosAct;
			stAxis[GVL.cXP].bTrackedFlag:=TRUE;
		END_IF
	END_IF
	
	IF NOT stAxis[GVL.cXM].bTrackedFlag THEN
		//Compare current sequence with recorded sequence. Update position if match. Positive direction.
		IF stAxis[GVL.cXM].axisRef.status.PositiveDirection THEN
			stAxis[GVL.cXM].fHallPosAct := stAxis[GVL.cXM].fHallPosCal[GVL.cDirPos, stAxis[GVL.cXM].nTripCount];
			stAxis[GVL.cXM].nTripCount := stAxis[GVL.cXM].nTripCount - 1;	
			//track difference between hall sensor and encoder data at trip point
			stAxis[GVL.cXM].fPosDiffAtTrip := stAxis[GVL.cXM].axisRef.NcToPlc.ActPos - stAxis[GVL.cXM].fHallPosAct;
			stAxis[GVL.cXM].bTrackedFlag:=TRUE;
		END_IF
		//Compare current sequence with recorded sequence. Update position if match. Negative direction.
		IF stAxis[GVL.cXM].axisRef.status.NegativeDirection THEN
			stAxis[GVL.cXM].fHallPosAct := stAxis[GVL.cXM].fHallPosCal[GVL.cDirNeg, stAxis[GVL.cXM].nTripCount];
			stAxis[GVL.cXM].nTripCount := stAxis[GVL.cXM].nTripCount + 1;	
			//track difference between hall sensor and encoder data at trip point
			stAxis[GVL.cXM].fPosDiffAtTrip := stAxis[GVL.cXM].axisRef.NcToPlc.ActPos - stAxis[GVL.cXM].fHallPosAct;
			stAxis[GVL.cXM].bTrackedFlag:=TRUE;
		END_IF
	END_IF
END_IF
]]></ST>
    </Implementation>
    <LineIds Name="FB_Tracking">
      <LineId Id="1017" Count="0" />
      <LineId Id="475" Count="2" />
      <LineId Id="480" Count="0" />
      <LineId Id="936" Count="0" />
      <LineId Id="990" Count="0" />
      <LineId Id="695" Count="0" />
      <LineId Id="816" Count="0" />
      <LineId Id="606" Count="0" />
      <LineId Id="481" Count="1" />
      <LineId Id="485" Count="0" />
      <LineId Id="652" Count="0" />
      <LineId Id="651" Count="0" />
      <LineId Id="653" Count="0" />
      <LineId Id="673" Count="0" />
      <LineId Id="654" Count="0" />
      <LineId Id="609" Count="0" />
      <LineId Id="661" Count="0" />
      <LineId Id="933" Count="2" />
      <LineId Id="490" Count="0" />
      <LineId Id="1003" Count="1" />
      <LineId Id="1006" Count="0" />
      <LineId Id="1016" Count="0" />
      <LineId Id="1005" Count="0" />
      <LineId Id="491" Count="1" />
      <LineId Id="940" Count="0" />
      <LineId Id="931" Count="0" />
      <LineId Id="938" Count="0" />
      <LineId Id="656" Count="0" />
      <LineId Id="493" Count="0" />
      <LineId Id="526" Count="5" />
      <LineId Id="670" Count="0" />
      <LineId Id="987" Count="0" />
      <LineId Id="532" Count="0" />
      <LineId Id="818" Count="0" />
      <LineId Id="533" Count="4" />
      <LineId Id="669" Count="0" />
      <LineId Id="988" Count="0" />
      <LineId Id="538" Count="1" />
      <LineId Id="696" Count="0" />
      <LineId Id="553" Count="1" />
      <LineId Id="588" Count="5" />
      <LineId Id="668" Count="0" />
      <LineId Id="594" Count="0" />
      <LineId Id="817" Count="0" />
      <LineId Id="595" Count="4" />
      <LineId Id="667" Count="0" />
      <LineId Id="600" Count="1" />
      <LineId Id="937" Count="0" />
      <LineId Id="602" Count="0" />
      <LineId Id="941" Count="2" />
      <LineId Id="949" Count="0" />
      <LineId Id="985" Count="0" />
      <LineId Id="950" Count="15" />
      <LineId Id="967" Count="17" />
      <LineId Id="966" Count="0" />
      <LineId Id="945" Count="0" />
      <LineId Id="716" Count="0" />
      <LineId Id="1018" Count="4" />
      <LineId Id="1024" Count="7" />
      <LineId Id="1141" Count="0" />
      <LineId Id="1032" Count="52" />
      <LineId Id="1142" Count="0" />
      <LineId Id="1085" Count="7" />
      <LineId Id="1143" Count="0" />
      <LineId Id="1093" Count="45" />
      <LineId Id="9" Count="0" />
    </LineIds>
  </POU>
</TcPlcObject>